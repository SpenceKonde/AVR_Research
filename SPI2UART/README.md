# SPI2UART
This is a sketch that will run unmodified on any tinyAVR 0/1/2-series part with at least 14 pins. It will output all data received over SPI over serial at 921600 baud (if your adapters can do it crank, this as high as they'll go, up to 1/8th the tinyAVR's system clock). 2mbaud is a standard speed and can be done above 16 MHz, and the FT232RL claims to support 3mbaud, which an overclocked tinyAVR running at 24 MHz can do. We want it as high as possible because SPI clock speeds of a couple MHz are considered slow, but in order to ensure no data is lost, we need to be able to send 8 bits plus the start and stop bits via the UART!

## What this is for
UART serial communication requires that the two devices have a shared concept of time. When you are tuning the internal oscillator, you do not really have that. While I could have had the tuning sketch painstakingly recalculate the baud rates every iteration for the baud rate it calculates from the timebase and it's internal counter, this seemed more generally useful. It is also a way to get SPI debugging to do the kind of thing that one normally does with Serial debugging - when you can't use a USART (for example, either don't have or can't spare a UART nor deal with the downsides of software serial, or because the clock speed is changing, or because you're running it from an incredibly low system clock rate such that you are not able to get fast enough USART output for  what you'd want to receive it with  (though obviously, the settings it comes with by default are optimized for higher speeds... )

In any event, during development it was used to capture a table of the internal oscillator speed for every calibration value, in order to reproduce the cal curve. Quadratic best fit line that Excel found matched the data perfectly (with different coefficients for different specimens)

## Tuning next steps
The next step, which I haven't taken, would be to see if we could tune without ANY exernal timebase - a "bootstrap" tuning sketch, if you will.

I know the internal 32k oscillator is very crude, but we do have a known reference in the high speed one, particularly on the 2-series:  we know that at default calibration, the main oscillator is very close and we have the oscillator error in the SIGROW. In parts per 1024. So we calculate from that and VDD what we think our system clock is. Get the PIT onto an event channel running from internal 32kHz. Time with a TCB, then that combined with our estimated internal HF oscillator speed gives the actual speed of the internal 32kHz oscillator. Measure against that with some other values for the cal register...  cal = 0 gives the intercept, and two more after that is enough to get the other two coefficients, and then from those, calculate what calibratiom values would achieve any desired system clock! The only thing it *really* depends on is whether the 32k oscillator is reasonably stable. And a zero-timebase tuning sketch would be awesome.

Obviously SPI debug output during development, with this sketch translating it to serial, would be required to make that a reality.
