
C:\Users\Spence\AppData\Local\Temp\arduino_build_434784/rngBetterTest.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	59 c0       	rjmp	.+178    	; 0xb4 <__ctors_end>
       2:	00 00       	nop
../../../../crt1/gcrt1.S:67
       4:	95 c0       	rjmp	.+298    	; 0x130 <__bad_interrupt>
       6:	00 00       	nop
../../../../crt1/gcrt1.S:68
       8:	93 c0       	rjmp	.+294    	; 0x130 <__bad_interrupt>
       a:	00 00       	nop
../../../../crt1/gcrt1.S:69
       c:	91 c0       	rjmp	.+290    	; 0x130 <__bad_interrupt>
       e:	00 00       	nop
../../../../crt1/gcrt1.S:70
      10:	8f c0       	rjmp	.+286    	; 0x130 <__bad_interrupt>
      12:	00 00       	nop
../../../../crt1/gcrt1.S:71
      14:	8d c0       	rjmp	.+282    	; 0x130 <__bad_interrupt>
      16:	00 00       	nop
../../../../crt1/gcrt1.S:72
      18:	8b c0       	rjmp	.+278    	; 0x130 <__bad_interrupt>
      1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
      1c:	89 c0       	rjmp	.+274    	; 0x130 <__bad_interrupt>
      1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
      20:	87 c0       	rjmp	.+270    	; 0x130 <__bad_interrupt>
      22:	00 00       	nop
../../../../crt1/gcrt1.S:75
      24:	85 c0       	rjmp	.+266    	; 0x130 <__bad_interrupt>
      26:	00 00       	nop
../../../../crt1/gcrt1.S:76
      28:	83 c0       	rjmp	.+262    	; 0x130 <__bad_interrupt>
      2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
      2c:	81 c0       	rjmp	.+258    	; 0x130 <__bad_interrupt>
      2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
      30:	7f c0       	rjmp	.+254    	; 0x130 <__bad_interrupt>
      32:	00 00       	nop
../../../../crt1/gcrt1.S:79
      34:	7d c0       	rjmp	.+250    	; 0x130 <__bad_interrupt>
      36:	00 00       	nop
../../../../crt1/gcrt1.S:80
      38:	7b c0       	rjmp	.+246    	; 0x130 <__bad_interrupt>
      3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
      3c:	79 c0       	rjmp	.+242    	; 0x130 <__bad_interrupt>
      3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
      40:	77 c0       	rjmp	.+238    	; 0x130 <__bad_interrupt>
      42:	00 00       	nop
../../../../crt1/gcrt1.S:83
      44:	75 c0       	rjmp	.+234    	; 0x130 <__bad_interrupt>
      46:	00 00       	nop
../../../../crt1/gcrt1.S:84
      48:	73 c0       	rjmp	.+230    	; 0x130 <__bad_interrupt>
      4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
      4c:	71 c0       	rjmp	.+226    	; 0x130 <__bad_interrupt>
      4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
      50:	6f c0       	rjmp	.+222    	; 0x130 <__bad_interrupt>
      52:	00 00       	nop
../../../../crt1/gcrt1.S:87
      54:	0c 94 b9 0c 	jmp	0x1972	; 0x1972 <__vector_21>
../../../../crt1/gcrt1.S:88
      58:	0c 94 b3 0c 	jmp	0x1966	; 0x1966 <__vector_22>
../../../../crt1/gcrt1.S:89
      5c:	0c 94 bf 0c 	jmp	0x197e	; 0x197e <__vector_23>
../../../../crt1/gcrt1.S:90
      60:	67 c0       	rjmp	.+206    	; 0x130 <__bad_interrupt>
      62:	00 00       	nop
../../../../crt1/gcrt1.S:91
      64:	65 c0       	rjmp	.+202    	; 0x130 <__bad_interrupt>
      66:	00 00       	nop
../../../../crt1/gcrt1.S:92
      68:	63 c0       	rjmp	.+198    	; 0x130 <__bad_interrupt>
      6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
      6c:	61 c0       	rjmp	.+194    	; 0x130 <__bad_interrupt>
      6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
      70:	5f c0       	rjmp	.+190    	; 0x130 <__bad_interrupt>
      72:	00 00       	nop
../../../../crt1/gcrt1.S:95
      74:	5d c0       	rjmp	.+186    	; 0x130 <__bad_interrupt>
      76:	00 00       	nop
../../../../crt1/gcrt1.S:96
      78:	5b c0       	rjmp	.+182    	; 0x130 <__bad_interrupt>
      7a:	00 00       	nop
../../../../crt1/gcrt1.S:97
      7c:	0c 94 3c 0d 	jmp	0x1a78	; 0x1a78 <__vector_31>
../../../../crt1/gcrt1.S:98
      80:	57 c0       	rjmp	.+174    	; 0x130 <__bad_interrupt>
      82:	00 00       	nop
../../../../crt1/gcrt1.S:99
      84:	55 c0       	rjmp	.+170    	; 0x130 <__bad_interrupt>
      86:	00 00       	nop
../../../../crt1/gcrt1.S:100
      88:	53 c0       	rjmp	.+166    	; 0x130 <__bad_interrupt>
      8a:	00 00       	nop
../../../../crt1/gcrt1.S:101
      8c:	51 c0       	rjmp	.+162    	; 0x130 <__bad_interrupt>
      8e:	00 00       	nop
../../../../crt1/gcrt1.S:102
      90:	4f c0       	rjmp	.+158    	; 0x130 <__bad_interrupt>
      92:	00 00       	nop
../../../../crt1/gcrt1.S:103
      94:	4d c0       	rjmp	.+154    	; 0x130 <__bad_interrupt>
      96:	00 00       	nop
../../../../crt1/gcrt1.S:104
      98:	4b c0       	rjmp	.+150    	; 0x130 <__bad_interrupt>
      9a:	00 00       	nop
../../../../crt1/gcrt1.S:105
      9c:	49 c0       	rjmp	.+146    	; 0x130 <__bad_interrupt>
      9e:	00 00       	nop
../../../../crt1/gcrt1.S:106
      a0:	47 c0       	rjmp	.+142    	; 0x130 <__bad_interrupt>
      a2:	00 00       	nop
../../../../crt1/gcrt1.S:107
      a4:	45 c0       	rjmp	.+138    	; 0x130 <__bad_interrupt>
	...

000000a8 <__trampolines_end>:
__trampolines_start():
      a8:	00 00       	nop
      aa:	02 01       	movw	r0, r4
      ac:	04 06       	cpc	r0, r20
      ae:	03 00       	.word	0x0003	; ????
      b0:	03 00       	.word	0x0003	; ????

000000b2 <__ctors_start>:
__ctors_start():
      b2:	ba 0d       	add	r27, r10

000000b4 <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
      b4:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
      b6:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
      b8:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
      ba:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
      bc:	df e7       	ldi	r29, 0x7F	; 127
../../../../crt1/gcrt1.S:237
      be:	de bf       	out	0x3e, r29	; 62

000000c0 <_initThreeStuff()>:
init_reset_flags():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:146

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
      c0:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x7e0040>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:147
    RSTCTRL.RSTFR = flags;
      c4:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x7e0040>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:148
    if (flags == 0) {
      c8:	81 11       	cpse	r24, r1
      ca:	05 c0       	rjmp	.+10     	; 0xd6 <_initThreeStuff()+0x16>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:149
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
      cc:	98 ed       	ldi	r25, 0xD8	; 216
      ce:	21 e0       	ldi	r18, 0x01	; 1
      d0:	94 bf       	out	0x34, r25	; 52
      d2:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <__TEXT_REGION_LENGTH__+0x7e0041>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:151
    }
    GPIOR0 = flags;
      d6:	8c bb       	out	0x1c, r24	; 28
doFLMAP():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:74
      #pragma message("PROGMEM_MAPPED points to section 0 of the flash")
    #else
      #warning "no FLMAP section defined, yet LOCK_FLMAP IS!"
      temp = 0x30; // should always end up as the highest up to 3.
    #endif
    NVMCTRL.CTRLB = temp;
      d8:	80 e3       	ldi	r24, 0x30	; 48
      da:	80 93 01 10 	sts	0x1001, r24	; 0x801001 <__TEXT_REGION_LENGTH__+0x7e1001>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:76
    temp |= 0x80;
    _PROTECTED_WRITE(NVMCTRL_CTRLB, temp);
      de:	88 ed       	ldi	r24, 0xD8	; 216
      e0:	90 eb       	ldi	r25, 0xB0	; 176
      e2:	84 bf       	out	0x34, r24	; 52
      e4:	90 93 01 10 	sts	0x1001, r25	; 0x801001 <__TEXT_REGION_LENGTH__+0x7e1001>

000000e8 <__do_copy_data>:
__do_copy_data():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2373
      e8:	12 e4       	ldi	r17, 0x42	; 66
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2374
      ea:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2375
      ec:	b0 e4       	ldi	r27, 0x40	; 64
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2376
      ee:	ea e3       	ldi	r30, 0x3A	; 58
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2377
      f0:	fc e1       	ldi	r31, 0x1C	; 28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2378
      f2:	00 e0       	ldi	r16, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2379
      f4:	0b bf       	out	0x3b, r16	; 59
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2380
      f6:	02 c0       	rjmp	.+4      	; 0xfc <__do_copy_data+0x14>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2382
      f8:	07 90       	elpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2383
      fa:	0d 92       	st	X+, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2385
      fc:	ac 34       	cpi	r26, 0x4C	; 76
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2386
      fe:	b1 07       	cpc	r27, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2387
     100:	d9 f7       	brne	.-10     	; 0xf8 <__do_copy_data+0x10>

00000102 <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     102:	23 e4       	ldi	r18, 0x43	; 67
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     104:	ac e4       	ldi	r26, 0x4C	; 76
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     106:	b2 e4       	ldi	r27, 0x42	; 66
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     108:	01 c0       	rjmp	.+2      	; 0x10c <.do_clear_bss_start>

0000010a <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     10a:	1d 92       	st	X+, r1

0000010c <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     10c:	ab 35       	cpi	r26, 0x5B	; 91
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     10e:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     110:	e1 f7       	brne	.-8      	; 0x10a <.do_clear_bss_loop>

00000112 <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     112:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     114:	ca e5       	ldi	r28, 0x5A	; 90
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     116:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     118:	04 c0       	rjmp	.+8      	; 0x122 <__do_global_ctors+0x10>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     11a:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     11c:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     11e:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     122:	c9 35       	cpi	r28, 0x59	; 89
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     124:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     126:	c9 f7       	brne	.-14     	; 0x11a <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
     128:	0e 94 58 0d 	call	0x1ab0	; 0x1ab0 <main>
../../../../crt1/gcrt1.S:315
     12c:	0c 94 1b 0e 	jmp	0x1c36	; 0x1c36 <_exit>

00000130 <__bad_interrupt>:
__vector_38():
../../../../crt1/gcrt1.S:209
     130:	67 cf       	rjmp	.-306    	; 0x0 <__vectors>

00000132 <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
     132:	af 92       	push	r10
     134:	bf 92       	push	r11
     136:	cf 92       	push	r12
     138:	df 92       	push	r13
     13a:	ef 92       	push	r14
     13c:	ff 92       	push	r15
     13e:	0f 93       	push	r16
     140:	1f 93       	push	r17
     142:	cf 93       	push	r28
     144:	df 93       	push	r29
     146:	6c 01       	movw	r12, r24
     148:	7b 01       	movw	r14, r22
     14a:	8b 01       	movw	r16, r22
     14c:	04 0f       	add	r16, r20
     14e:	15 1f       	adc	r17, r21
     150:	eb 01       	movw	r28, r22
     152:	5e 01       	movw	r10, r28
     154:	ae 18       	sub	r10, r14
     156:	bf 08       	sbc	r11, r15
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     158:	c0 17       	cp	r28, r16
     15a:	d1 07       	cpc	r29, r17
     15c:	59 f0       	breq	.+22     	; 0x174 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:32
    if (write(*buffer++)) {
     15e:	69 91       	ld	r22, Y+
     160:	d6 01       	movw	r26, r12
     162:	ed 91       	ld	r30, X+
     164:	fc 91       	ld	r31, X
     166:	01 90       	ld	r0, Z+
     168:	f0 81       	ld	r31, Z
     16a:	e0 2d       	mov	r30, r0
     16c:	c6 01       	movw	r24, r12
     16e:	09 95       	icall
     170:	89 2b       	or	r24, r25
     172:	79 f7       	brne	.-34     	; 0x152 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     174:	c5 01       	movw	r24, r10
     176:	df 91       	pop	r29
     178:	cf 91       	pop	r28
     17a:	1f 91       	pop	r17
     17c:	0f 91       	pop	r16
     17e:	ff 90       	pop	r15
     180:	ef 90       	pop	r14
     182:	df 90       	pop	r13
     184:	cf 90       	pop	r12
     186:	bf 90       	pop	r11
     188:	af 90       	pop	r10
     18a:	08 95       	ret

0000018c <HardwareSerial::availableForWrite()>:
availableForWrite():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:727
      int HardwareSerial::availableForWrite(void) {
        tx_buffer_index_t head;
        tx_buffer_index_t tail;

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
     18c:	fc 01       	movw	r30, r24
     18e:	51 89       	ldd	r21, Z+17	; 0x11
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:728
          tail = _tx_buffer_tail;
     190:	42 89       	ldd	r20, Z+18	; 0x12
     192:	25 2f       	mov	r18, r21
     194:	30 e0       	ldi	r19, 0x00	; 0
     196:	84 2f       	mov	r24, r20
     198:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:731
        }
        if (head >= tail) {
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     19a:	82 1b       	sub	r24, r18
     19c:	93 0b       	sbc	r25, r19
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:730

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
          tail = _tx_buffer_tail;
        }
        if (head >= tail) {
     19e:	54 17       	cp	r21, r20
     1a0:	10 f0       	brcs	.+4      	; 0x1a6 <HardwareSerial::availableForWrite()+0x1a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:731
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     1a2:	cf 96       	adiw	r24, 0x3f	; 63
     1a4:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:733
        }
        return tail - head - 1;
     1a6:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:734
      }
     1a8:	08 95       	ret

000001aa <HardwareSerial::read()>:
read():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:711
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }

    int HardwareSerial::read(void) {
     1aa:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:713
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
     1ac:	97 85       	ldd	r25, Z+15	; 0x0f
     1ae:	80 89       	ldd	r24, Z+16	; 0x10
     1b0:	98 17       	cp	r25, r24
     1b2:	61 f0       	breq	.+24     	; 0x1cc <HardwareSerial::read()+0x22>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:716
        return -1;
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
     1b4:	a0 89       	ldd	r26, Z+16	; 0x10
     1b6:	ae 0f       	add	r26, r30
     1b8:	bf 2f       	mov	r27, r31
     1ba:	b1 1d       	adc	r27, r1
     1bc:	53 96       	adiw	r26, 0x13	; 19
     1be:	8c 91       	ld	r24, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:717
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
     1c0:	90 89       	ldd	r25, Z+16	; 0x10
     1c2:	9f 5f       	subi	r25, 0xFF	; 255
     1c4:	9f 73       	andi	r25, 0x3F	; 63
     1c6:	90 8b       	std	Z+16, r25	; 0x10
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:718
        return c;
     1c8:	90 e0       	ldi	r25, 0x00	; 0
     1ca:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:714
    }

    int HardwareSerial::read(void) {
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
     1cc:	8f ef       	ldi	r24, 0xFF	; 255
     1ce:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:720
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
        return c;
      }
    }
     1d0:	08 95       	ret

000001d2 <HardwareSerial::peek()>:
peek():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:703

    int HardwareSerial::available(void) {
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
     1d2:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:704
      if (_rx_buffer_head == _rx_buffer_tail) {
     1d4:	97 85       	ldd	r25, Z+15	; 0x0f
     1d6:	80 89       	ldd	r24, Z+16	; 0x10
     1d8:	98 17       	cp	r25, r24
     1da:	31 f0       	breq	.+12     	; 0x1e8 <HardwareSerial::peek()+0x16>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:707
        return -1;
      } else {
        return _rx_buffer[_rx_buffer_tail];
     1dc:	80 89       	ldd	r24, Z+16	; 0x10
     1de:	e8 0f       	add	r30, r24
     1e0:	f1 1d       	adc	r31, r1
     1e2:	83 89       	ldd	r24, Z+19	; 0x13
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:705
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
     1e8:	8f ef       	ldi	r24, 0xFF	; 255
     1ea:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:709
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }
     1ec:	08 95       	ret

000001ee <HardwareSerial::available()>:
available():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:699
      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
    }

    int HardwareSerial::available(void) {
     1ee:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:700
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
     1f0:	97 85       	ldd	r25, Z+15	; 0x0f
     1f2:	20 89       	ldd	r18, Z+16	; 0x10
     1f4:	89 2f       	mov	r24, r25
     1f6:	90 e0       	ldi	r25, 0x00	; 0
     1f8:	80 5c       	subi	r24, 0xC0	; 192
     1fa:	9f 4f       	sbci	r25, 0xFF	; 255
     1fc:	82 1b       	sub	r24, r18
     1fe:	91 09       	sbc	r25, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:701
    }
     200:	8f 73       	andi	r24, 0x3F	; 63
     202:	99 27       	eor	r25, r25
     204:	08 95       	ret

00000206 <HardwareSerial::_poll_tx_data_empty()>:
_poll_tx_data_empty():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:426
        HardwareSerial._tx_buffer_tail = txTail;
      }
    #endif

    // To invoke data empty "interrupt" via a call, use this method
    void HardwareSerial::_poll_tx_data_empty(void) {
     206:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:427
      if ((!(SREG & CPU_I_bm)) ||  CPUINT.STATUS) {
     208:	0f b6       	in	r0, 0x3f	; 63
     20a:	07 fe       	sbrs	r0, 7
     20c:	04 c0       	rjmp	.+8      	; 0x216 <HardwareSerial::_poll_tx_data_empty()+0x10>
     20e:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <__TEXT_REGION_LENGTH__+0x7e0111>
     212:	88 23       	and	r24, r24
     214:	a9 f0       	breq	.+42     	; 0x240 <_poll_dre_done>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:444
        // so we'll have to poll the "data register empty" flag ourselves.
        // If it is set, pretend an interrupt has happened and call the handler
        // to free up space for us.
        // -Spence 10/23/20
        // Invoke interrupt handler only if conditions data register is empty
        if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     216:	a0 85       	ldd	r26, Z+8	; 0x08
     218:	b1 85       	ldd	r27, Z+9	; 0x09
     21a:	14 96       	adiw	r26, 0x04	; 4
     21c:	8c 91       	ld	r24, X
     21e:	14 97       	sbiw	r26, 0x04	; 4
     220:	85 ff       	sbrs	r24, 5
     222:	0e c0       	rjmp	.+28     	; 0x240 <_poll_dre_done>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:445
          if (_tx_buffer_head == _tx_buffer_tail) {
     224:	91 89       	ldd	r25, Z+17	; 0x11
     226:	82 89       	ldd	r24, Z+18	; 0x12
     228:	98 13       	cpse	r25, r24
     22a:	07 c0       	rjmp	.+14     	; 0x23a <HardwareSerial::_poll_tx_data_empty()+0x34>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:447
            // Buffer empty, so disable "data register empty" interrupt
            (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     22c:	15 96       	adiw	r26, 0x05	; 5
     22e:	8c 91       	ld	r24, X
     230:	15 97       	sbiw	r26, 0x05	; 5
     232:	8f 7d       	andi	r24, 0xDF	; 223
     234:	15 96       	adiw	r26, 0x05	; 5
     236:	8c 93       	st	X, r24
     238:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:465
      #else
                    "rjmp _poll_dre"    "\n\t"
      #endif
                    "_poll_dre_done:"    "\n"
                    ::"z"((uint16_t)thisSerial)
                    : "r18","r19","r24","r25","r26","r27"); // these got saved and restored in the ISR context, but here we don't need top and in many cases no action is needed.
     23a:	e8 94       	clt
     23c:	0c 94 cc 0c 	jmp	0x1998	; 0x1998 <_poll_dre>

00000240 <_poll_dre_done>:
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:474
        }
      }
      // In case interrupts are enabled, the interrupt routine will be invoked by itself
      // Note that this currently does not handle cases where the DRE interruopt becomes
      // disabled, yet you are actually attempting to send. I don't think it can happen.
    }
     240:	08 95       	ret

00000242 <HardwareSerial::write(unsigned char)>:
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:767
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }


      size_t HardwareSerial::write(uint8_t c) {
     242:	0f 93       	push	r16
     244:	1f 93       	push	r17
     246:	cf 93       	push	r28
     248:	df 93       	push	r29
     24a:	ec 01       	movw	r28, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:768
        _state |= 1; // Record that we have written to serial since it was begun.
     24c:	8e 85       	ldd	r24, Y+14	; 0x0e
     24e:	81 60       	ori	r24, 0x01	; 1
     250:	8e 87       	std	Y+14, r24	; 0x0e
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:773
        // If the buffer and the data register is empty, just write the byte
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
     252:	99 89       	ldd	r25, Y+17	; 0x11
     254:	8a 89       	ldd	r24, Y+18	; 0x12
     256:	98 13       	cpse	r25, r24
     258:	0b c0       	rjmp	.+22     	; 0x270 <HardwareSerial::write(unsigned char)+0x2e>
     25a:	e8 85       	ldd	r30, Y+8	; 0x08
     25c:	f9 85       	ldd	r31, Y+9	; 0x09
     25e:	84 81       	ldd	r24, Z+4	; 0x04
     260:	85 ff       	sbrs	r24, 5
     262:	06 c0       	rjmp	.+12     	; 0x270 <HardwareSerial::write(unsigned char)+0x2e>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:774
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     264:	8e 85       	ldd	r24, Y+14	; 0x0e
     266:	81 fd       	sbrc	r24, 1
     268:	0d c0       	rjmp	.+26     	; 0x284 <HardwareSerial::write(unsigned char)+0x42>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:781
            ctrla &= ~USART_RXCIE_bm;
            ctrla |=  USART_TXCIE_bm;
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
            (*_hwserial_module).CTRLA = ctrla;
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
     26a:	80 e4       	ldi	r24, 0x40	; 64
     26c:	84 83       	std	Z+4, r24	; 0x04
     26e:	12 c0       	rjmp	.+36     	; 0x294 <HardwareSerial::write(unsigned char)+0x52>
     270:	06 2f       	mov	r16, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:802
           * // that the interrupt handler is called in this situation
           * (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
           */
          return 1;
        }
        tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  // % SERIAL_TX_BUFFER_SIZE;
     272:	19 89       	ldd	r17, Y+17	; 0x11
     274:	1f 5f       	subi	r17, 0xFF	; 255
     276:	1f 73       	andi	r17, 0x3F	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:806

        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
     278:	8a 89       	ldd	r24, Y+18	; 0x12
     27a:	81 13       	cpse	r24, r17
     27c:	15 c0       	rjmp	.+42     	; 0x2a8 <HardwareSerial::write(unsigned char)+0x66>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:807
          _poll_tx_data_empty();
     27e:	ce 01       	movw	r24, r28
     280:	c2 df       	rcall	.-124    	; 0x206 <HardwareSerial::_poll_tx_data_empty()>
     282:	fa cf       	rjmp	.-12     	; 0x278 <HardwareSerial::write(unsigned char)+0x36>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:775
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
            uint8_t ctrla = (*_hwserial_module).CTRLA;
     284:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:776
            ctrla &= ~USART_RXCIE_bm;
     286:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:777
            ctrla |=  USART_TXCIE_bm;
     288:	80 64       	ori	r24, 0x40	; 64
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:778
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
     28a:	90 e4       	ldi	r25, 0x40	; 64
     28c:	94 83       	std	Z+4, r25	; 0x04
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:779
            (*_hwserial_module).CTRLA = ctrla;
     28e:	e8 85       	ldd	r30, Y+8	; 0x08
     290:	f9 85       	ldd	r31, Y+9	; 0x09
     292:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:784
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
          }
          // MUST clear TXCIF **before** writing new char, otherwise ill-timed interrupt can cause it to erase the flag after the new charchter has been sent!
          (*_hwserial_module).TXDATAL = c;
     294:	e8 85       	ldd	r30, Y+8	; 0x08
     296:	f9 85       	ldd	r31, Y+9	; 0x09
     298:	62 83       	std	Z+2, r22	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:822
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
        }
        return 1;
      }
     29a:	81 e0       	ldi	r24, 0x01	; 1
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	df 91       	pop	r29
     2a0:	cf 91       	pop	r28
     2a2:	1f 91       	pop	r17
     2a4:	0f 91       	pop	r16
     2a6:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:809
        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
          _poll_tx_data_empty();
        }
        _tx_buffer[_tx_buffer_head] = c;
     2a8:	e9 89       	ldd	r30, Y+17	; 0x11
     2aa:	ec 0f       	add	r30, r28
     2ac:	fd 2f       	mov	r31, r29
     2ae:	f1 1d       	adc	r31, r1
     2b0:	ed 5a       	subi	r30, 0xAD	; 173
     2b2:	ff 4f       	sbci	r31, 0xFF	; 255
     2b4:	00 83       	st	Z, r16
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:810
        _tx_buffer_head = i;
     2b6:	19 8b       	std	Y+17, r17	; 0x11
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:811
        if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     2b8:	8e 85       	ldd	r24, Y+14	; 0x0e
     2ba:	e8 85       	ldd	r30, Y+8	; 0x08
     2bc:	f9 85       	ldd	r31, Y+9	; 0x09
     2be:	81 ff       	sbrs	r24, 1
     2c0:	09 c0       	rjmp	.+18     	; 0x2d4 <HardwareSerial::write(unsigned char)+0x92>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:812
          uint8_t ctrla = (*_hwserial_module).CTRLA;
     2c2:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:813
          ctrla &= ~USART_RXCIE_bm;
     2c4:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:814
          ctrla |= USART_TXCIE_bm | USART_DREIE_bm;
     2c6:	80 66       	ori	r24, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:815
          (*_hwserial_module).STATUS = USART_TXCIF_bm;
     2c8:	90 e4       	ldi	r25, 0x40	; 64
     2ca:	94 83       	std	Z+4, r25	; 0x04
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:816
          (*_hwserial_module).CTRLA = ctrla;
     2cc:	e8 85       	ldd	r30, Y+8	; 0x08
     2ce:	f9 85       	ldd	r31, Y+9	; 0x09
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:819
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     2d0:	85 83       	std	Z+5, r24	; 0x05
     2d2:	e3 cf       	rjmp	.-58     	; 0x29a <HardwareSerial::write(unsigned char)+0x58>
     2d4:	85 81       	ldd	r24, Z+5	; 0x05
     2d6:	80 62       	ori	r24, 0x20	; 32
     2d8:	fb cf       	rjmp	.-10     	; 0x2d0 <HardwareSerial::write(unsigned char)+0x8e>

000002da <HardwareSerial::printHex(unsigned char) [clone .constprop.19]>:
printHex():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:824
        }
        return 1;
      }

      void HardwareSerial::printHex(const uint8_t b) {
     2da:	cf 93       	push	r28
     2dc:	c8 2f       	mov	r28, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:825
        char x = (b >> 4) | '0';
     2de:	68 2f       	mov	r22, r24
     2e0:	62 95       	swap	r22
     2e2:	6f 70       	andi	r22, 0x0F	; 15
     2e4:	60 63       	ori	r22, 0x30	; 48
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:826
        if (x > '9')
     2e6:	6a 33       	cpi	r22, 0x3A	; 58
     2e8:	0c f0       	brlt	.+2      	; 0x2ec <HardwareSerial::printHex(unsigned char) [clone .constprop.19]+0x12>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:827
          x += 7;
     2ea:	69 5f       	subi	r22, 0xF9	; 249
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/HardwareSerial.h:298
    virtual    void flush(void);
    virtual  size_t write(uint8_t ch);
    inline   size_t write(unsigned long n)  {return write((uint8_t)n);}
    inline   size_t write(long n)           {return write((uint8_t)n);}
    inline   size_t write(unsigned int n)   {return write((uint8_t)n);}
    inline   size_t write(int n)            {return write((uint8_t)n);}
     2ec:	88 ec       	ldi	r24, 0xC8	; 200
     2ee:	92 e4       	ldi	r25, 0x42	; 66
     2f0:	a8 df       	rcall	.-176    	; 0x242 <HardwareSerial::write(unsigned char)>
printHex():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:829
        write(x);
        x = (b & 0x0F) | '0';
     2f2:	6c 2f       	mov	r22, r28
     2f4:	6f 70       	andi	r22, 0x0F	; 15
     2f6:	60 63       	ori	r22, 0x30	; 48
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:830
        if (x > '9')
     2f8:	6a 33       	cpi	r22, 0x3A	; 58
     2fa:	08 f0       	brcs	.+2      	; 0x2fe <HardwareSerial::printHex(unsigned char) [clone .constprop.19]+0x24>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:831
          x += 7;
     2fc:	69 5f       	subi	r22, 0xF9	; 249
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/HardwareSerial.h:298
     2fe:	88 ec       	ldi	r24, 0xC8	; 200
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:833
        write(x);
      }
     300:	92 e4       	ldi	r25, 0x42	; 66
printHex():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/HardwareSerial.h:298
     302:	cf 91       	pop	r28
write():
     304:	9e cf       	rjmp	.-196    	; 0x242 <HardwareSerial::write(unsigned char)>

00000306 <HardwareSerial::flush()>:
flush():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:736
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
        }
        return tail - head - 1;
      }

      void HardwareSerial::flush() {
     306:	cf 93       	push	r28
     308:	df 93       	push	r29
     30a:	ec 01       	movw	r28, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:740
        // If we have never written a byte, no need to flush. This special
        // case is needed since there is no way to force the TXCIF (transmit
        // complete) bit to 1 during initialization
        if (!_state & 1) {
     30c:	8e 85       	ldd	r24, Y+14	; 0x0e
     30e:	88 23       	and	r24, r24
     310:	59 f0       	breq	.+22     	; 0x328 <HardwareSerial::flush()+0x22>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:755
        // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
        // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
        // and in that case flush(), and write() with full buffer would just straight up hang...

        // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
        while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
     312:	e8 85       	ldd	r30, Y+8	; 0x08
     314:	f9 85       	ldd	r31, Y+9	; 0x09
     316:	85 81       	ldd	r24, Z+5	; 0x05
     318:	85 fd       	sbrc	r24, 5
     31a:	03 c0       	rjmp	.+6      	; 0x322 <HardwareSerial::flush()+0x1c>
     31c:	84 81       	ldd	r24, Z+4	; 0x04
     31e:	86 fd       	sbrc	r24, 6
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:760

          // If interrupts are globally disabled or the and DR empty interrupt is disabled,
          // poll the "data register empty" interrupt flag to prevent deadlock

          _poll_tx_data_empty();
     320:	03 c0       	rjmp	.+6      	; 0x328 <HardwareSerial::flush()+0x22>
     322:	ce 01       	movw	r24, r28
     324:	70 df       	rcall	.-288    	; 0x206 <HardwareSerial::_poll_tx_data_empty()>
     326:	f5 cf       	rjmp	.-22     	; 0x312 <HardwareSerial::flush()+0xc>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:764
        }
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }
     328:	df 91       	pop	r29
     32a:	cf 91       	pop	r28
     32c:	08 95       	ret

0000032e <micros>:
micros():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:450
      #else /* TCA */
        uint8_t ticks;
      #endif
      uint8_t flags;
      /* Save current state and disable interrupts */
      uint8_t oldSREG = SREG;
     32e:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:451
      cli(); /* INTERRUPTS OFF */
     330:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:467
        while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
        flags = TCD0.INTFLAGS;
        ticks = TCD0.CAPTUREA;
        */
      #else /* = defined(MILLIS_USE_TCB) */
        ticks = _timer->CNT;
     332:	e0 91 2a 0b 	lds	r30, 0x0B2A	; 0x800b2a <__TEXT_REGION_LENGTH__+0x7e0b2a>
     336:	f0 91 2b 0b 	lds	r31, 0x0B2B	; 0x800b2b <__TEXT_REGION_LENGTH__+0x7e0b2b>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:468
        flags = _timer->INTFLAGS;
     33a:	80 91 26 0b 	lds	r24, 0x0B26	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:476
       * ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
       * so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it
       * doesn't matter.
       * Get current number of overflows and timer count */
      #if defined(MILLIS_USE_TCB)
        overflows = timingStruct.timer_millis;
     33e:	20 91 c4 42 	lds	r18, 0x42C4	; 0x8042c4 <timingStruct>
     342:	30 91 c5 42 	lds	r19, 0x42C5	; 0x8042c5 <timingStruct+0x1>
     346:	40 91 c6 42 	lds	r20, 0x42C6	; 0x8042c6 <timingStruct+0x2>
     34a:	50 91 c7 42 	lds	r21, 0x42C7	; 0x8042c7 <timingStruct+0x3>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:481
      #else
        overflows = timingStruct.timer_overflow_count;
      #endif
      /* Turn interrupts back on, assuming they were on when micros was called. */
      SREG = oldSREG; /* INTERRUPTS ON */
     34e:	9f bf       	out	0x3f, r25	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:491
      */
      #if defined(MILLIS_USE_TCA)
        ticks = (TIME_TRACKING_TIMER_PERIOD) - ticks;
        if ((flags & TCA_SPLIT_HUNF_bm) && (ticks < 0x03)) {
      #else /* = defined(MILLIS_USE_TCB) */
        if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
     350:	80 ff       	sbrs	r24, 0
     352:	08 c0       	rjmp	.+16     	; 0x364 <micros+0x36>
     354:	cf 01       	movw	r24, r30
     356:	88 27       	eor	r24, r24
     358:	89 2b       	or	r24, r25
     35a:	21 f4       	brne	.+8      	; 0x364 <micros+0x36>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:496
      #endif
      #if (defined(MILLIS_USE_TCB) && (F_CPU <= 2000000UL))
        overflows += 2;
      #else
        overflows++;
     35c:	2f 5f       	subi	r18, 0xFF	; 255
     35e:	3f 4f       	sbci	r19, 0xFF	; 255
     360:	4f 4f       	sbci	r20, 0xFF	; 255
     362:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:788
            : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
          microseconds = overflows * 1000 + ticks; // nice and clean.

        #elif (F_CPU == 48000000UL || F_CPU == 24000000UL || F_CPU == 12000000UL || F_CPU == 6000000UL || F_CPU == 3000000UL)
          // The terrible twelves!
            __asm__ __volatile__(
     364:	0f 01       	movw	r0, r30
     366:	16 94       	lsr	r1
     368:	07 94       	ror	r0
     36a:	16 94       	lsr	r1
     36c:	07 94       	ror	r0
     36e:	16 94       	lsr	r1
     370:	07 94       	ror	r0
     372:	16 94       	lsr	r1
     374:	07 94       	ror	r0
     376:	f0 01       	movw	r30, r0
     378:	16 94       	lsr	r1
     37a:	07 94       	ror	r0
     37c:	e0 0d       	add	r30, r0
     37e:	f1 1d       	adc	r31, r1
     380:	16 94       	lsr	r1
     382:	07 94       	ror	r0
     384:	10 2c       	mov	r1, r0
     386:	16 94       	lsr	r1
     388:	01 18       	sub	r0, r1
     38a:	16 94       	lsr	r1
     38c:	01 0c       	add	r0, r1
     38e:	16 94       	lsr	r1
     390:	01 18       	sub	r0, r1
     392:	16 94       	lsr	r1
     394:	01 0c       	add	r0, r1
     396:	16 94       	lsr	r1
     398:	01 18       	sub	r0, r1
     39a:	16 94       	lsr	r1
     39c:	16 94       	lsr	r1
     39e:	01 0c       	add	r0, r1
     3a0:	11 24       	eor	r1, r1
     3a2:	e0 19       	sub	r30, r0
     3a4:	f1 09       	sbc	r31, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:833
          "add r0,r1"     "\n\t"  // + ticks >> 9
          "eor r1,r1"     "\n\t"  // clear out r1
          "sub %A0,r0"    "\n\t"  // Add the sum of terms that fit in a byte to what was ticks in old code.
          "sbc %B0,r1"    "\n"    // carry - see,this is why AVR needs a known zero.
          : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
        microseconds = overflows * 1000 + ticks;
     3a6:	a8 ee       	ldi	r26, 0xE8	; 232
     3a8:	b3 e0       	ldi	r27, 0x03	; 3
     3aa:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <__muluhisi3>
     3ae:	6e 0f       	add	r22, r30
     3b0:	7f 1f       	adc	r23, r31
     3b2:	81 1d       	adc	r24, r1
     3b4:	91 1d       	adc	r25, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1042
          microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                        + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
        #endif
      #endif // end of timer-specific part of micros calculations
      return microseconds;
    }
     3b6:	08 95       	ret

000003b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>:
_ZN5Print5writeEPKc.part.2():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:56
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
      }
      return write((const uint8_t *)str, strlen(str));
     3b8:	fb 01       	movw	r30, r22
     3ba:	01 90       	ld	r0, Z+
     3bc:	00 20       	and	r0, r0
     3be:	e9 f7       	brne	.-6      	; 0x3ba <Print::write(char const*) [clone .part.2] [clone .constprop.21]+0x2>
     3c0:	31 97       	sbiw	r30, 0x01	; 1
     3c2:	af 01       	movw	r20, r30
     3c4:	46 1b       	sub	r20, r22
     3c6:	57 0b       	sbc	r21, r23
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:66

size_t Print::print(const String &s) {
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[]) {
     3c8:	b4 ce       	rjmp	.-664    	; 0x132 <Print::write(unsigned char const*, unsigned int)>

000003ca <Print::print(char const*) [clone .constprop.9]>:
write():
     3ca:	bc 01       	movw	r22, r24
     3cc:	88 ec       	ldi	r24, 0xC8	; 200
     3ce:	92 e4       	ldi	r25, 0x42	; 66
     3d0:	f3 cf       	rjmp	.-26     	; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>

000003d2 <Print::println(unsigned int, int) [clone .constprop.10]>:
println():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:157
  size_t n = print(num, base);
  n += println();
  return n;
}

size_t Print::println(unsigned int num, int base) {
     3d2:	cf 92       	push	r12
     3d4:	df 92       	push	r13
     3d6:	ef 92       	push	r14
     3d8:	ff 92       	push	r15
     3da:	0f 93       	push	r16
     3dc:	1f 93       	push	r17
     3de:	cf 93       	push	r28
     3e0:	df 93       	push	r29
     3e2:	cd b7       	in	r28, 0x3d	; 61
     3e4:	de b7       	in	r29, 0x3e	; 62
     3e6:	a1 97       	sbiw	r28, 0x21	; 33
     3e8:	cd bf       	out	0x3d, r28	; 61
     3ea:	de bf       	out	0x3e, r29	; 62
print():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:83
size_t Print::print(int n, int base) {
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base) {
  return print((unsigned long) n, base);
     3ec:	9c 01       	movw	r18, r24
     3ee:	50 e0       	ldi	r21, 0x00	; 0
     3f0:	40 e0       	ldi	r20, 0x00	; 0
printNumber():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:219

size_t Print::printNumber(unsigned long n, uint8_t base) {
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     3f2:	19 a2       	std	Y+33, r1	; 0x21
     3f4:	8e 01       	movw	r16, r28
     3f6:	0f 5d       	subi	r16, 0xDF	; 223
     3f8:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:227
  if (base < 2) {
    base = 10;
  }

  do {
    char c = n % base;
     3fa:	8a e0       	ldi	r24, 0x0A	; 10
     3fc:	c8 2e       	mov	r12, r24
     3fe:	d1 2c       	mov	r13, r1
     400:	e1 2c       	mov	r14, r1
     402:	f1 2c       	mov	r15, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:228
    n /= base;
     404:	ca 01       	movw	r24, r20
     406:	b9 01       	movw	r22, r18
     408:	a7 01       	movw	r20, r14
     40a:	96 01       	movw	r18, r12
     40c:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <__udivmodsi4>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:230

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     410:	60 5d       	subi	r22, 0xD0	; 208
     412:	f8 01       	movw	r30, r16
     414:	62 93       	st	-Z, r22
     416:	8f 01       	movw	r16, r30
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:231
  } while (n);
     418:	21 15       	cp	r18, r1
     41a:	31 05       	cpc	r19, r1
     41c:	41 05       	cpc	r20, r1
     41e:	51 05       	cpc	r21, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:53
      setWriteError(0);
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
     420:	89 f7       	brne	.-30     	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
write():
     422:	30 97       	sbiw	r30, 0x00	; 0
     424:	c1 f0       	breq	.+48     	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
     426:	bf 01       	movw	r22, r30
     428:	88 ec       	ldi	r24, 0xC8	; 200
     42a:	92 e4       	ldi	r25, 0x42	; 66
     42c:	c5 df       	rcall	.-118    	; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
     42e:	8c 01       	movw	r16, r24
     430:	67 e5       	ldi	r22, 0x57	; 87
     432:	70 e4       	ldi	r23, 0x40	; 64
     434:	88 ec       	ldi	r24, 0xC8	; 200
     436:	92 e4       	ldi	r25, 0x42	; 66
     438:	bf df       	rcall	.-130    	; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
println():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:161

size_t Print::println(unsigned int num, int base) {
  size_t n = print(num, base);
  n += println();
  return n;
}
     43a:	80 0f       	add	r24, r16
     43c:	91 1f       	adc	r25, r17
     43e:	a1 96       	adiw	r28, 0x21	; 33
     440:	cd bf       	out	0x3d, r28	; 61
     442:	de bf       	out	0x3e, r29	; 62
     444:	df 91       	pop	r29
     446:	cf 91       	pop	r28
     448:	1f 91       	pop	r17
     44a:	0f 91       	pop	r16
     44c:	ff 90       	pop	r15
     44e:	ef 90       	pop	r14
     450:	df 90       	pop	r13
     452:	cf 90       	pop	r12
     454:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:54
        return 0;
     456:	10 e0       	ldi	r17, 0x00	; 0
     458:	00 e0       	ldi	r16, 0x00	; 0
     45a:	ea cf       	rjmp	.-44     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>

0000045c <setup>:
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:6

#include <rngBetter.h>
#define SERIALPORT Serial
#define SERIALSWAPLEVEL (0)

void setup() {
     45c:	cf 92       	push	r12
     45e:	df 92       	push	r13
     460:	ef 92       	push	r14
     462:	ff 92       	push	r15
     464:	cf 93       	push	r28
     466:	df 93       	push	r29
swap():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:526
    }


    bool HardwareSerial::swap(uint8_t newmux) {
      if (newmux < _mux_count) {
        _pin_set = newmux;
     468:	10 92 d5 42 	sts	0x42D5, r1	; 0x8042d5 <Serial0+0xd>
begin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:540
    }

    void HardwareSerial::begin(unsigned long baud, uint16_t options) {
      // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
      // without first calling end()
      if (_state & 1) {
     46c:	80 91 d6 42 	lds	r24, 0x42D6	; 0x8042d6 <Serial0+0xe>
     470:	80 ff       	sbrs	r24, 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:684
        return NOT_A_MUX; // At this point, we have checked all group codes for this peripheral. It ain't there. Return NOT_A_MUX.
      }
    }
    void HardwareSerial::end() {
      // wait for transmission of outgoing data
      flush();
     472:	13 c0       	rjmp	.+38     	; 0x49a <setup+0x3e>
end():
     474:	88 ec       	ldi	r24, 0xC8	; 200
     476:	92 e4       	ldi	r25, 0x42	; 66
     478:	46 df       	rcall	.-372    	; 0x306 <HardwareSerial::flush()>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:687
      // Disable receiver and transmitter as well as the RX complete and the data register empty interrupts.
      // TXCIE only used in half duplex - we can just turn the damned thing off yo!
      volatile USART_t * temp = _hwserial_module; /* compiler does a slightly better job with this. */
     47a:	e0 91 d0 42 	lds	r30, 0x42D0	; 0x8042d0 <Serial0+0x8>
     47e:	f0 91 d1 42 	lds	r31, 0x42D1	; 0x8042d1 <Serial0+0x9>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:688
      temp -> CTRLB &= 0; //~(USART_RXEN_bm | USART_TXEN_bm);
     482:	86 81       	ldd	r24, Z+6	; 0x06
     484:	16 82       	std	Z+6, r1	; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:689
      temp -> CTRLA &= 0; //~(USART_RXCIE_bm | USART_DREIE_bm | USART_TXCIE_bm);
     486:	85 81       	ldd	r24, Z+5	; 0x05
     488:	15 82       	std	Z+5, r1	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:690
      temp -> STATUS =  USART_TXCIF_bm; // want to make sure no chanceofthat firing in error. TXCIE only used in half duplex
     48a:	80 e4       	ldi	r24, 0x40	; 64
     48c:	84 83       	std	Z+4, r24	; 0x04
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:692
      // clear any received data
      _rx_buffer_head = _rx_buffer_tail;
     48e:	80 91 d8 42 	lds	r24, 0x42D8	; 0x8042d8 <Serial0+0x10>
     492:	80 93 d7 42 	sts	0x42D7, r24	; 0x8042d7 <Serial0+0xf>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:696

      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
     496:	10 92 d6 42 	sts	0x42D6, r1	; 0x8042d6 <Serial0+0xe>
begin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:579
        setpinmask             |= 0x10;         // this tells _set_pins not to disturb the configuration on the RX pin.
      }
      if (ctrla & USART_RS485_bm) {             // RS485 mode recorded here too... because we need to set
        setpinmask             |= 0x01;         // set pin output if we need to do that. Datasheet isn't clear
      }
      uint8_t oldSREG = SREG;
     49a:	6f b7       	in	r22, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:580
      cli();
     49c:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:581
      volatile USART_t* MyUSART = _hwserial_module;
     49e:	e0 91 d0 42 	lds	r30, 0x42D0	; 0x8042d0 <Serial0+0x8>
     4a2:	f0 91 d1 42 	lds	r31, 0x42D1	; 0x8042d1 <Serial0+0x9>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:582
      (*MyUSART).CTRLB          = 0;            // gotta disable first - some things are enable-locked.
     4a6:	16 82       	std	Z+6, r1	; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:583
      (*MyUSART).CTRLC          = ctrlc;        // No reason not to set first.
     4a8:	33 e0       	ldi	r19, 0x03	; 3
     4aa:	37 83       	std	Z+7, r19	; 0x07
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:584
      (*MyUSART).BAUD           = baud_setting; // Wish I could have set it long ago
     4ac:	81 e4       	ldi	r24, 0x41	; 65
     4ae:	93 e0       	ldi	r25, 0x03	; 3
     4b0:	80 87       	std	Z+8, r24	; 0x08
     4b2:	91 87       	std	Z+9, r25	; 0x09
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:590
      if (ctrla & 0x20) {                       // Now we have to do a bit of work
        setpinmask             &= 0x7F;         // Remove the RX pin in this case because we get the input from elsewhere.
        (*MyUSART).EVCTRL       = 1;            // enable event input - not clear from datasheet what's needed to
        (*MyUSART).TXPLCTRL     = 0xFF;         // Disable pulse length encoding.
      } else {
        (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
     4b4:	14 86       	std	Z+12, r1	; 0x0c
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:592
      }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
      (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
     4b6:	80 e8       	ldi	r24, 0x80	; 128
     4b8:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:593
      (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
     4ba:	80 ec       	ldi	r24, 0xC0	; 192
     4bc:	86 83       	std	Z+6, r24	; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:594
        _set_pins(_usart_pins, _mux_count, _pin_set, setpinmask); // set up the pin(s)
     4be:	20 91 d5 42 	lds	r18, 0x42D5	; 0x8042d5 <Serial0+0xd>
     4c2:	70 91 d4 42 	lds	r23, 0x42D4	; 0x8042d4 <Serial0+0xc>
     4c6:	80 91 d2 42 	lds	r24, 0x42D2	; 0x8042d2 <Serial0+0xa>
     4ca:	90 91 d3 42 	lds	r25, 0x42D3	; 0x8042d3 <Serial0+0xb>
_set_pins():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:641
    //  1  1  1  0      TX set output, RX not changed. Loopback mode: you can only see what you send since TX is OUTPUT and that's what's connected to RX.
    //  1  1  1  1      TX set input pullup. Half-duplex mode.
    // * indicates that RS485 mode if requested will be enabled, even though it is inappropriate. These configurations are documented unsupported.
    // Static
    void HardwareSerial::_set_pins(uint8_t* mux_table_ptr, uint8_t mux_count, uint8_t mux_setting, uint8_t enmask) {
      uint8_t* mux_row_ptr   = mux_table_ptr + (mux_setting * USART_PINS_WIDTH);
     4ce:	fc 01       	movw	r30, r24
     4d0:	23 9f       	mul	r18, r19
     4d2:	e0 0d       	add	r30, r0
     4d4:	f1 1d       	adc	r31, r1
     4d6:	11 24       	eor	r1, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:642
      uint16_t mux_row_gc_tx = pgm_read_word_near(mux_row_ptr); // Clever trick for faster PGM reads of consecutive bytes!
     4d8:	45 91       	lpm	r20, Z+
     4da:	54 91       	lpm	r21, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:644
      uint8_t mux_group_code = (uint8_t) (mux_row_gc_tx);       // this is the mux
      if (mux_setting < mux_count) {              // if false, pinmux none was selected, and we skip the pin configuration.
     4dc:	27 17       	cp	r18, r23
     4de:	08 f0       	brcs	.+2      	; 0x4e2 <setup+0x86>
     4e0:	3e c0       	rjmp	.+124    	; 0x55e <setup+0x102>
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     4e2:	57 31       	cpi	r21, 0x17	; 23
     4e4:	90 f4       	brcc	.+36     	; 0x50a <setup+0xae>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/Arduino.h:792
  #if !defined(NUM_TOTAL_PINS)
    #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
  #endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
     4e6:	25 2f       	mov	r18, r21
     4e8:	30 e0       	ldi	r19, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:79
     4ea:	f9 01       	movw	r30, r18
     4ec:	e2 5d       	subi	r30, 0xD2	; 210
     4ee:	ff 4b       	sbci	r31, 0xBF	; 191
     4f0:	a0 81       	ld	r26, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     4f2:	af 3f       	cpi	r26, 0xFF	; 255
     4f4:	51 f0       	breq	.+20     	; 0x50a <setup+0xae>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
     4f6:	29 5e       	subi	r18, 0xE9	; 233
     4f8:	3f 4b       	sbci	r19, 0xBF	; 191
     4fa:	e9 01       	movw	r28, r18
     4fc:	e8 81       	ld	r30, Y
     4fe:	d0 e2       	ldi	r29, 0x20	; 32
     500:	ed 9f       	mul	r30, r29
     502:	f0 01       	movw	r30, r0
     504:	11 24       	eor	r1, r1
     506:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
     508:	a1 83       	std	Z+1, r26	; 0x01
_set_pins():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:653
          pinMode(mux_pin_tx, OUTPUT);            // If and only if TX is enabled and open drain isn't should the TX pin be output.
        } else if (enmask & 0x50) {               // if it is enabled but is in open drain mode, or is disabled, but loopback is enabled
          pinMode(mux_pin_tx, INPUT_PULLUP);      // TX should be INPUT_PULLUP.
        }
        if (enmask & 0x80 && !(enmask & 0x10)) {  // Likewise if RX is enabled, unless loopback mode is too
          pinMode(mux_pin_tx + 1, INPUT_PULLUP);  // (in which case we caught it above), it should be pulled up
     50a:	21 e0       	ldi	r18, 0x01	; 1
     50c:	25 0f       	add	r18, r21
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     50e:	27 31       	cpi	r18, 0x17	; 23
     510:	30 f5       	brcc	.+76     	; 0x55e <setup+0x102>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/Arduino.h:792
     512:	30 e0       	ldi	r19, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:79
     514:	f9 01       	movw	r30, r18
     516:	e2 5d       	subi	r30, 0xD2	; 210
     518:	ff 4b       	sbci	r31, 0xBF	; 191
     51a:	c0 81       	ld	r28, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     51c:	cf 3f       	cpi	r28, 0xFF	; 255
     51e:	f9 f0       	breq	.+62     	; 0x55e <setup+0x102>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
     520:	f9 01       	movw	r30, r18
     522:	e9 5e       	subi	r30, 0xE9	; 233
     524:	ff 4b       	sbci	r31, 0xBF	; 191
     526:	a0 81       	ld	r26, Z
     528:	e0 e2       	ldi	r30, 0x20	; 32
     52a:	ae 9f       	mul	r26, r30
     52c:	d0 01       	movw	r26, r0
     52e:	11 24       	eor	r1, r1
     530:	bc 5f       	subi	r27, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:89
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
     532:	20 50       	subi	r18, 0x00	; 0
     534:	30 4c       	sbci	r19, 0xC0	; 192
     536:	f9 01       	movw	r30, r18
     538:	d0 81       	ld	r29, Z
setup():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:90
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
     53a:	f0 e0       	ldi	r31, 0x00	; 0
     53c:	e0 e0       	ldi	r30, 0x00	; 0
_pinMode():
     53e:	d8 30       	cpi	r29, 0x08	; 8
     540:	30 f4       	brcc	.+12     	; 0x54e <setup+0xf2>
     542:	9d 01       	movw	r18, r26
     544:	20 5f       	subi	r18, 0xF0	; 240
     546:	3f 4f       	sbci	r19, 0xFF	; 255
     548:	f9 01       	movw	r30, r18
     54a:	ed 0f       	add	r30, r29
     54c:	f1 1d       	adc	r31, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:91
    uint8_t status = SREG;              /* Save state */
     54e:	3f b7       	in	r19, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:92
    cli();                              /* Interrupts off for PINnCTRL stuff */
     550:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:93
    port->DIRCLR = bit_mask;            /* Configure direction as input */
     552:	12 96       	adiw	r26, 0x02	; 2
     554:	cc 93       	st	X, r28
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:95
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
     556:	20 81       	ld	r18, Z
     558:	28 60       	ori	r18, 0x08	; 8
     55a:	20 83       	st	Z, r18
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:99
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    }
    SREG = status;                      /* Restore state */
     55c:	3f bf       	out	0x3f, r19	; 63
_mux_set():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:611
      uint8_t temp   = *portmux;
      temp          &= ~((uint8_t) (mux_options_off_gm >> 8)); // Group Mask
      temp          |= mux_code;
      *portmux       = temp;
    #else
      uint8_t* mux_info_ptr = mux_table_ptr + (mux_count * USART_PINS_WIDTH) + 2;
     55e:	fc 01       	movw	r30, r24
     560:	23 e0       	ldi	r18, 0x03	; 3
     562:	72 9f       	mul	r23, r18
     564:	e0 0d       	add	r30, r0
     566:	f1 1d       	adc	r31, r1
     568:	11 24       	eor	r1, r1
     56a:	32 96       	adiw	r30, 0x02	; 2
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:615
      /* Only one register, so no offset, so only read a byte */
      uint8_t mux_mask = pgm_read_byte_near(mux_info_ptr);     // only read the group mask
      volatile uint8_t* portmux = (uint8_t*)(HWSERIAL_MUX_REGISTER_BASE);
      uint8_t temp   = *portmux;
     56c:	e4 91       	lpm	r30, Z
     56e:	80 91 e2 05 	lds	r24, 0x05E2	; 0x8005e2 <__TEXT_REGION_LENGTH__+0x7e05e2>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:616
      temp          &= ~(mux_mask);
     572:	e0 95       	com	r30
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:617
      temp          |= mux_code;
     574:	e8 23       	and	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:618
      *portmux       = temp;
     576:	e4 2b       	or	r30, r20
     578:	e0 93 e2 05 	sts	0x05E2, r30	; 0x8005e2 <__TEXT_REGION_LENGTH__+0x7e05e2>
begin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1105
#if (!(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC) || (F_CPU == 7000000L || F_CPU == 14000000)))
  // delay implementation when we do have micros() - we know it won't work at 7 or 14, and those can be generated
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
    uint16_t start = (uint16_t)micros();
     57c:	6f bf       	out	0x3f, r22	; 63
delay():
     57e:	d7 de       	rcall	.-594    	; 0x32e <micros>
     580:	eb 01       	movw	r28, r22
     582:	88 ee       	ldi	r24, 0xE8	; 232
     584:	c8 2e       	mov	r12, r24
     586:	83 e0       	ldi	r24, 0x03	; 3
     588:	d8 2e       	mov	r13, r24
     58a:	e1 2c       	mov	r14, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1109
    while (true) {
      if (ms == 0) break;
      yield();
      uint16_t us_passed = (uint16_t)micros() - start;
     58c:	f1 2c       	mov	r15, r1
     58e:	cf de       	rcall	.-610    	; 0x32e <micros>
     590:	6c 1b       	sub	r22, r28
     592:	7d 0b       	sbc	r23, r29
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1110
      if (us_passed >= 1000) {
     594:	68 3e       	cpi	r22, 0xE8	; 232
     596:	73 40       	sbci	r23, 0x03	; 3
     598:	d0 f3       	brcs	.-12     	; 0x58e <setup+0x132>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1111
        ms--;
     59a:	e1 e0       	ldi	r30, 0x01	; 1
     59c:	ce 1a       	sub	r12, r30
     59e:	d1 08       	sbc	r13, r1
     5a0:	e1 08       	sbc	r14, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1112
        start += 1000;
     5a2:	f1 08       	sbc	r15, r1
     5a4:	c8 51       	subi	r28, 0x18	; 24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1107
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
    uint16_t start = (uint16_t)micros();
    while (true) {
      if (ms == 0) break;
     5a6:	dc 4f       	sbci	r29, 0xFC	; 252
     5a8:	c1 14       	cp	r12, r1
     5aa:	d1 04       	cpc	r13, r1
     5ac:	e1 04       	cpc	r14, r1
     5ae:	f1 04       	cpc	r15, r1
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:12
  // put your setup code here, to run once:
  // Validating all API calls. 
  SERIALPORT.swap(SERIALSWAPLEVEL);
  SERIALPORT.begin(115200);
  delay(1000);
  SERIALPORT.print("Generate seed (from just adc): ");
     5b0:	71 f7       	brne	.-36     	; 0x58e <setup+0x132>
setup():
     5b2:	8a e5       	ldi	r24, 0x5A	; 90
     5b4:	90 e4       	ldi	r25, 0x40	; 64
     5b6:	09 df       	rcall	.-494    	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
_analogReadEnh():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:661
   */

  /*******************************
   *  Phase 1: Input Processing  |
   ******************************/
  if (!(ADC0.CTRLA & 0x01)) return ADC_ENH_ERROR_DISABLED;
     5b8:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <__TEXT_REGION_LENGTH__+0x7e0600>
     5bc:	80 fd       	sbrc	r24, 0
     5be:	02 c0       	rjmp	.+4      	; 0x5c4 <setup+0x168>
     5c0:	0c 94 8d 0c 	jmp	0x191a	; 0x191a <setup+0x14be>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:687
        This does not check for internal sources that don't exist (all valid internal sources are checked for in the case of compile-time-known pins)
          Not worth wasting on the scale of 20-some-odd bytes of flash just to give an error to people who dynamically generate invalid analog pins
          and try to use them with analogReadEnh(), instead of just returning whatever we get from reading the bogus channel */
    return ADC_ENH_ERROR_BAD_PIN_OR_CHANNEL;
  }
  if (ADC0.COMMAND & ADC_STCONV_bm) {
     5c4:	80 91 0a 06 	lds	r24, 0x060A	; 0x80060a <__TEXT_REGION_LENGTH__+0x7e060a>
     5c8:	80 ff       	sbrs	r24, 0
     5ca:	02 c0       	rjmp	.+4      	; 0x5d0 <setup+0x174>
     5cc:	0c 94 b1 0c 	jmp	0x1962	; 0x1962 <setup+0x1506>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:718
        busy before entering this block. */
  } // end neg != SINGLE_ENDED
  /********************************************
   *  Phase 2: Configure ADC and take reading  |
   ********************************************/
  ADC0.MUXPOS = pin;
     5d0:	94 e0       	ldi	r25, 0x04	; 4
     5d2:	90 93 08 06 	sts	0x0608, r25	; 0x800608 <__TEXT_REGION_LENGTH__+0x7e0608>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:719
  uint8_t _ctrlb = ADC0.CTRLB;
     5d6:	50 91 01 06 	lds	r21, 0x0601	; 0x800601 <__TEXT_REGION_LENGTH__+0x7e0601>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:720
  uint8_t _ctrla = ADC0.CTRLA;
     5da:	40 91 00 06 	lds	r20, 0x0600	; 0x800600 <__TEXT_REGION_LENGTH__+0x7e0600>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:721
  ADC0.CTRLA = ADC_ENABLE_bm | (res == ADC_NATIVE_RESOLUTION_LOW ? ADC_RESSEL_10BIT_gc : 0) | (neg == SINGLE_ENDED ? 0 : ADC_CONVMODE_bm);
     5de:	81 e0       	ldi	r24, 0x01	; 1
     5e0:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x7e0600>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:722
  ADC0.CTRLB = sampnum;
     5e4:	90 93 01 06 	sts	0x0601, r25	; 0x800601 <__TEXT_REGION_LENGTH__+0x7e0601>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:724

  ADC0.COMMAND = ADC_STCONV_bm;
     5e8:	80 93 0a 06 	sts	0x060A, r24	; 0x80060a <__TEXT_REGION_LENGTH__+0x7e060a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:725
  while (!(ADC0.INTFLAGS & ADC_RESRDY_bm));
     5ec:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <__TEXT_REGION_LENGTH__+0x7e060d>
     5f0:	80 ff       	sbrs	r24, 0
     5f2:	fc cf       	rjmp	.-8      	; 0x5ec <setup+0x190>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:726
  int32_t result = ADC0.RES; // This should clear the flag
     5f4:	20 91 10 06 	lds	r18, 0x0610	; 0x800610 <__TEXT_REGION_LENGTH__+0x7e0610>
     5f8:	30 91 11 06 	lds	r19, 0x0611	; 0x800611 <__TEXT_REGION_LENGTH__+0x7e0611>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:762
   ******************************/
  #if (defined(ERRATA_ADC_PIN_DISABLE) && ERRATA_ADC_PIN_DISABLE != 0)
    // That may become defined when DA-series silicon is available with the fix
    ADC0.MUXPOS = 0x40;
  #endif
  ADC0.CTRLB = _ctrlb;      // the user having something set in CTRLB is not implausuble
     5fc:	50 93 01 06 	sts	0x0601, r21	; 0x800601 <__TEXT_REGION_LENGTH__+0x7e0601>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:763
  ADC0.CTRLA = _ctrla;      // undo the mess we just made in ADC0.CTRLA
     600:	40 93 00 06 	sts	0x0600, r20	; 0x800600 <__TEXT_REGION_LENGTH__+0x7e0600>
ADCtoSeed():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/rngBetter.cpp:78
          "swap %B1"         "\n\t"
          "eor %A0, %B1"     "\n\t"
          "eor %B0, %A1"     "\n\t"
        :"+d"((uint16_t)tempseed)
        :"r"((uint16_t)reading)
        :);
     604:	81 e0       	ldi	r24, 0x01	; 1
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	c9 01       	movw	r24, r18
     60a:	82 95       	swap	r24
     60c:	32 95       	swap	r19
     60e:	83 27       	eor	r24, r19
     610:	92 27       	eor	r25, r18
seed_xor16_11e():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11e.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     612:	00 97       	sbiw	r24, 0x00	; 0
     614:	21 f0       	breq	.+8      	; 0x61e <setup+0x1c2>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11e.cpp:13
    __xor16_11e_state = seed;
     616:	80 93 4c 42 	sts	0x424C, r24	; 0x80424c <__data_end>
     61a:	90 93 4d 42 	sts	0x424D, r25	; 0x80424d <__data_end+0x1>
xor16_11e():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11e.cpp:37
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 6"        "\n\t"
      "bst    %A0, 1"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_11e_state)::"r18","r19");
     61e:	c0 91 4c 42 	lds	r28, 0x424C	; 0x80424c <__data_end>
     622:	d0 91 4d 42 	lds	r29, 0x424D	; 0x80424d <__data_end+0x1>
     626:	9e 01       	movw	r18, r28
     628:	22 0f       	add	r18, r18
     62a:	33 1f       	adc	r19, r19
     62c:	c2 27       	eor	r28, r18
     62e:	d3 27       	eor	r29, r19
     630:	9e 01       	movw	r18, r28
     632:	36 95       	lsr	r19
     634:	27 95       	ror	r18
     636:	c2 27       	eor	r28, r18
     638:	d3 27       	eor	r29, r19
     63a:	33 27       	eor	r19, r19
     63c:	c0 fb       	bst	r28, 0
     63e:	36 f9       	bld	r19, 6
     640:	c1 fb       	bst	r28, 1
     642:	37 f9       	bld	r19, 7
     644:	d3 27       	eor	r29, r19
     646:	c0 93 4c 42 	sts	0x424C, r28	; 0x80424c <__data_end>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:30
      while (1);
    }
    uint16_t seed = rng16::ADCtoSeed((uint16_t) adcread, 16);
    seed_xor16_11e(seed);
    seed = xor16_11e();
    SERIALPORT.print("11e: ");
     64a:	d0 93 4d 42 	sts	0x424D, r29	; 0x80424d <__data_end+0x1>
setup():
     64e:	8f ed       	ldi	r24, 0xDF	; 223
     650:	90 e4       	ldi	r25, 0x40	; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:31
    SERIALPORT.println(seed);
     652:	bb de       	rcall	.-650    	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     654:	ce 01       	movw	r24, r28
     656:	bd de       	rcall	.-646    	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_11f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11f.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     658:	20 97       	sbiw	r28, 0x00	; 0
     65a:	21 f0       	breq	.+8      	; 0x664 <setup+0x208>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11f.cpp:13
    __xor16_11f_state = seed;
     65c:	c0 93 4e 42 	sts	0x424E, r28	; 0x80424e <__xor16_11f_state>
     660:	d0 93 4f 42 	sts	0x424F, r29	; 0x80424f <__xor16_11f_state+0x1>
xor16_11f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11f.cpp:35
      "eor    %B0, r19"      "\n\t"
      "eor    r19, r19"      "\n\t"
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_11f_state)::"r18","r19");
     664:	c0 91 4e 42 	lds	r28, 0x424E	; 0x80424e <__xor16_11f_state>
     668:	d0 91 4f 42 	lds	r29, 0x424F	; 0x80424f <__xor16_11f_state+0x1>
     66c:	9e 01       	movw	r18, r28
     66e:	22 0f       	add	r18, r18
     670:	33 1f       	adc	r19, r19
     672:	c2 27       	eor	r28, r18
     674:	d3 27       	eor	r29, r19
     676:	9e 01       	movw	r18, r28
     678:	36 95       	lsr	r19
     67a:	27 95       	ror	r18
     67c:	c2 27       	eor	r28, r18
     67e:	d3 27       	eor	r29, r19
     680:	33 27       	eor	r19, r19
     682:	c0 fb       	bst	r28, 0
     684:	37 f9       	bld	r19, 7
     686:	d3 27       	eor	r29, r19
     688:	c0 93 4e 42 	sts	0x424E, r28	; 0x80424e <__xor16_11f_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:34
    seed_xor16_11f(seed);
    seed = xor16_11f();
    SERIALPORT.print("11f: ");
     68c:	d0 93 4f 42 	sts	0x424F, r29	; 0x80424f <__xor16_11f_state+0x1>
setup():
     690:	85 ee       	ldi	r24, 0xE5	; 229
     692:	90 e4       	ldi	r25, 0x40	; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:35
    SERIALPORT.println(seed);
     694:	9a de       	rcall	.-716    	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     696:	ce 01       	movw	r24, r28
     698:	9c de       	rcall	.-712    	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_152():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_152.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     69a:	20 97       	sbiw	r28, 0x00	; 0
     69c:	21 f0       	breq	.+8      	; 0x6a6 <setup+0x24a>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_152.cpp:13
    __xor16_152_state = seed;
     69e:	c0 93 50 42 	sts	0x4250, r28	; 0x804250 <__xor16_152_state>
     6a2:	d0 93 51 42 	sts	0x4251, r29	; 0x804251 <__xor16_152_state+0x1>
xor16_152():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_152.cpp:46
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_152_state)::"r18","r19");
     6a6:	c0 91 50 42 	lds	r28, 0x4250	; 0x804250 <__xor16_152_state>
     6aa:	d0 91 51 42 	lds	r29, 0x4251	; 0x804251 <__xor16_152_state+0x1>
     6ae:	9e 01       	movw	r18, r28
     6b0:	22 0f       	add	r18, r18
     6b2:	33 1f       	adc	r19, r19
     6b4:	c2 27       	eor	r28, r18
     6b6:	d3 27       	eor	r29, r19
     6b8:	9e 01       	movw	r18, r28
     6ba:	36 95       	lsr	r19
     6bc:	27 95       	ror	r18
     6be:	36 95       	lsr	r19
     6c0:	27 95       	ror	r18
     6c2:	36 95       	lsr	r19
     6c4:	27 95       	ror	r18
     6c6:	36 95       	lsr	r19
     6c8:	27 95       	ror	r18
     6ca:	36 95       	lsr	r19
     6cc:	27 95       	ror	r18
     6ce:	c2 27       	eor	r28, r18
     6d0:	d3 27       	eor	r29, r19
     6d2:	9e 01       	movw	r18, r28
     6d4:	22 0f       	add	r18, r18
     6d6:	33 1f       	adc	r19, r19
     6d8:	22 0f       	add	r18, r18
     6da:	33 1f       	adc	r19, r19
     6dc:	c2 27       	eor	r28, r18
     6de:	d3 27       	eor	r29, r19
     6e0:	c0 93 50 42 	sts	0x4250, r28	; 0x804250 <__xor16_152_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:38
    seed_xor16_152(seed);
    seed = xor16_152();
    SERIALPORT.print("152: ");
     6e4:	d0 93 51 42 	sts	0x4251, r29	; 0x804251 <__xor16_152_state+0x1>
setup():
     6e8:	8b ee       	ldi	r24, 0xEB	; 235
     6ea:	90 e4       	ldi	r25, 0x40	; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:39
    SERIALPORT.println(seed);
     6ec:	6e de       	rcall	.-804    	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     6ee:	ce 01       	movw	r24, r28
     6f0:	70 de       	rcall	.-800    	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_174():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_174.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     6f2:	20 97       	sbiw	r28, 0x00	; 0
     6f4:	21 f0       	breq	.+8      	; 0x6fe <setup+0x2a2>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_174.cpp:13
    __xor16_174_state = seed;
     6f6:	c0 93 52 42 	sts	0x4252, r28	; 0x804252 <__xor16_174_state>
     6fa:	d0 93 53 42 	sts	0x4253, r29	; 0x804253 <__xor16_174_state+0x1>
xor16_174():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_174.cpp:45
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_174_state)::"r18","r19");
     6fe:	c0 91 52 42 	lds	r28, 0x4252	; 0x804252 <__xor16_174_state>
     702:	d0 91 53 42 	lds	r29, 0x4253	; 0x804253 <__xor16_174_state+0x1>
     706:	9e 01       	movw	r18, r28
     708:	22 0f       	add	r18, r18
     70a:	33 1f       	adc	r19, r19
     70c:	c2 27       	eor	r28, r18
     70e:	d3 27       	eor	r29, r19
     710:	9e 01       	movw	r18, r28
     712:	22 0f       	add	r18, r18
     714:	23 2f       	mov	r18, r19
     716:	22 1f       	adc	r18, r18
     718:	33 0b       	sbc	r19, r19
     71a:	31 95       	neg	r19
     71c:	c2 27       	eor	r28, r18
     71e:	d3 27       	eor	r29, r19
     720:	9e 01       	movw	r18, r28
     722:	22 0f       	add	r18, r18
     724:	33 1f       	adc	r19, r19
     726:	22 0f       	add	r18, r18
     728:	33 1f       	adc	r19, r19
     72a:	22 0f       	add	r18, r18
     72c:	33 1f       	adc	r19, r19
     72e:	22 0f       	add	r18, r18
     730:	33 1f       	adc	r19, r19
     732:	c2 27       	eor	r28, r18
     734:	d3 27       	eor	r29, r19
     736:	c0 93 52 42 	sts	0x4252, r28	; 0x804252 <__xor16_174_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:42
    seed_xor16_174(seed);
    seed = xor16_174();
    SERIALPORT.print("174: ");
     73a:	d0 93 53 42 	sts	0x4253, r29	; 0x804253 <__xor16_174_state+0x1>
setup():
     73e:	81 ef       	ldi	r24, 0xF1	; 241
     740:	90 e4       	ldi	r25, 0x40	; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:43
    SERIALPORT.println(seed);
     742:	43 de       	rcall	.-890    	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     744:	ce 01       	movw	r24, r28
     746:	45 de       	rcall	.-886    	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_17b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_17b.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     748:	20 97       	sbiw	r28, 0x00	; 0
     74a:	21 f0       	breq	.+8      	; 0x754 <setup+0x2f8>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_17b.cpp:13
    __xor16_17b_state = seed;
     74c:	c0 93 54 42 	sts	0x4254, r28	; 0x804254 <__xor16_17b_state>
     750:	d0 93 55 42 	sts	0x4255, r29	; 0x804255 <__xor16_17b_state+0x1>
xor16_17b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_17b.cpp:39
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_17b_state)::"r18","r19");
     754:	c0 91 54 42 	lds	r28, 0x4254	; 0x804254 <__xor16_17b_state>
     758:	d0 91 55 42 	lds	r29, 0x4255	; 0x804255 <__xor16_17b_state+0x1>
     75c:	9e 01       	movw	r18, r28
     75e:	22 0f       	add	r18, r18
     760:	33 1f       	adc	r19, r19
     762:	c2 27       	eor	r28, r18
     764:	d3 27       	eor	r29, r19
     766:	9e 01       	movw	r18, r28
     768:	22 0f       	add	r18, r18
     76a:	23 2f       	mov	r18, r19
     76c:	22 1f       	adc	r18, r18
     76e:	33 0b       	sbc	r19, r19
     770:	31 95       	neg	r19
     772:	c2 27       	eor	r28, r18
     774:	d3 27       	eor	r29, r19
     776:	3c 2f       	mov	r19, r28
     778:	33 0f       	add	r19, r19
     77a:	33 0f       	add	r19, r19
     77c:	33 0f       	add	r19, r19
     77e:	d3 27       	eor	r29, r19
     780:	c0 93 54 42 	sts	0x4254, r28	; 0x804254 <__xor16_17b_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:46
    seed_xor16_17b(seed);
    seed = xor16_17b();
    SERIALPORT.print("17b: ");
     784:	d0 93 55 42 	sts	0x4255, r29	; 0x804255 <__xor16_17b_state+0x1>
setup():
     788:	87 ef       	ldi	r24, 0xF7	; 247
     78a:	90 e4       	ldi	r25, 0x40	; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:47
    SERIALPORT.println(seed);
     78c:	1e de       	rcall	.-964    	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     78e:	ce 01       	movw	r24, r28
     790:	20 de       	rcall	.-960    	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_1b3():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1b3.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     792:	20 97       	sbiw	r28, 0x00	; 0
     794:	21 f0       	breq	.+8      	; 0x79e <setup+0x342>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1b3.cpp:13
    __xor16_1b3_state = seed;
     796:	c0 93 56 42 	sts	0x4256, r28	; 0x804256 <__xor16_1b3_state>
     79a:	d0 93 57 42 	sts	0x4257, r29	; 0x804257 <__xor16_1b3_state+0x1>
xor16_1b3():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1b3.cpp:40
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_1b3_state)::"r18","r19");
     79e:	c0 91 56 42 	lds	r28, 0x4256	; 0x804256 <__xor16_1b3_state>
     7a2:	d0 91 57 42 	lds	r29, 0x4257	; 0x804257 <__xor16_1b3_state+0x1>
     7a6:	9e 01       	movw	r18, r28
     7a8:	22 0f       	add	r18, r18
     7aa:	33 1f       	adc	r19, r19
     7ac:	c2 27       	eor	r28, r18
     7ae:	d3 27       	eor	r29, r19
     7b0:	2d 2f       	mov	r18, r29
     7b2:	26 95       	lsr	r18
     7b4:	26 95       	lsr	r18
     7b6:	26 95       	lsr	r18
     7b8:	c2 27       	eor	r28, r18
     7ba:	9e 01       	movw	r18, r28
     7bc:	22 0f       	add	r18, r18
     7be:	33 1f       	adc	r19, r19
     7c0:	22 0f       	add	r18, r18
     7c2:	33 1f       	adc	r19, r19
     7c4:	22 0f       	add	r18, r18
     7c6:	33 1f       	adc	r19, r19
     7c8:	c2 27       	eor	r28, r18
     7ca:	d3 27       	eor	r29, r19
     7cc:	c0 93 56 42 	sts	0x4256, r28	; 0x804256 <__xor16_1b3_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:50
    seed_xor16_1b3(seed);
    seed = xor16_1b3();
    SERIALPORT.print("1b3: ");
     7d0:	d0 93 57 42 	sts	0x4257, r29	; 0x804257 <__xor16_1b3_state+0x1>
setup():
     7d4:	8d ef       	ldi	r24, 0xFD	; 253
     7d6:	90 e4       	ldi	r25, 0x40	; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:51
    SERIALPORT.println(seed);
     7d8:	f8 dd       	rcall	.-1040   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     7da:	ce 01       	movw	r24, r28
     7dc:	fa dd       	rcall	.-1036   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_1f6():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f6.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     7de:	20 97       	sbiw	r28, 0x00	; 0
     7e0:	21 f0       	breq	.+8      	; 0x7ea <setup+0x38e>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f6.cpp:13
    __xor16_1f6_state = seed;
     7e2:	c0 93 58 42 	sts	0x4258, r28	; 0x804258 <__xor16_1f6_state>
     7e6:	d0 93 59 42 	sts	0x4259, r29	; 0x804259 <__xor16_1f6_state+0x1>
xor16_1f6():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f6.cpp:45
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_1f6_state)::"r18","r19");
     7ea:	c0 91 58 42 	lds	r28, 0x4258	; 0x804258 <__xor16_1f6_state>
     7ee:	d0 91 59 42 	lds	r29, 0x4259	; 0x804259 <__xor16_1f6_state+0x1>
     7f2:	9e 01       	movw	r18, r28
     7f4:	22 0f       	add	r18, r18
     7f6:	33 1f       	adc	r19, r19
     7f8:	c2 27       	eor	r28, r18
     7fa:	d3 27       	eor	r29, r19
     7fc:	d7 fb       	bst	r29, 7
     7fe:	22 27       	eor	r18, r18
     800:	20 f9       	bld	r18, 0
     802:	c2 27       	eor	r28, r18
     804:	9e 01       	movw	r18, r28
     806:	22 0f       	add	r18, r18
     808:	33 1f       	adc	r19, r19
     80a:	22 0f       	add	r18, r18
     80c:	33 1f       	adc	r19, r19
     80e:	22 0f       	add	r18, r18
     810:	33 1f       	adc	r19, r19
     812:	22 0f       	add	r18, r18
     814:	33 1f       	adc	r19, r19
     816:	22 0f       	add	r18, r18
     818:	33 1f       	adc	r19, r19
     81a:	22 0f       	add	r18, r18
     81c:	33 1f       	adc	r19, r19
     81e:	c2 27       	eor	r28, r18
     820:	d3 27       	eor	r29, r19
     822:	c0 93 58 42 	sts	0x4258, r28	; 0x804258 <__xor16_1f6_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:54
    seed_xor16_1f6(seed);
    seed = xor16_1f6();
    SERIALPORT.print("1f6: ");
     826:	d0 93 59 42 	sts	0x4259, r29	; 0x804259 <__xor16_1f6_state+0x1>
setup():
     82a:	83 e0       	ldi	r24, 0x03	; 3
     82c:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:55
    SERIALPORT.println(seed);
     82e:	cd dd       	rcall	.-1126   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     830:	ce 01       	movw	r24, r28
     832:	cf dd       	rcall	.-1122   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_1f7():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f7.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     834:	20 97       	sbiw	r28, 0x00	; 0
     836:	21 f0       	breq	.+8      	; 0x840 <setup+0x3e4>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f7.cpp:13
    __xor16_1f7_state = seed;
     838:	c0 93 5a 42 	sts	0x425A, r28	; 0x80425a <__xor16_1f7_state>
     83c:	d0 93 5b 42 	sts	0x425B, r29	; 0x80425b <__xor16_1f7_state+0x1>
xor16_1f7():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f7.cpp:38
      "eor    r18, r18"      "\n\t"
      "ror    r19"           "\n\t"
      "ror    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_1f7_state)::"r18","r19");
     840:	c0 91 5a 42 	lds	r28, 0x425A	; 0x80425a <__xor16_1f7_state>
     844:	d0 91 5b 42 	lds	r29, 0x425B	; 0x80425b <__xor16_1f7_state+0x1>
     848:	9e 01       	movw	r18, r28
     84a:	22 0f       	add	r18, r18
     84c:	33 1f       	adc	r19, r19
     84e:	c2 27       	eor	r28, r18
     850:	d3 27       	eor	r29, r19
     852:	d7 fb       	bst	r29, 7
     854:	22 27       	eor	r18, r18
     856:	20 f9       	bld	r18, 0
     858:	c2 27       	eor	r28, r18
     85a:	9e 01       	movw	r18, r28
     85c:	36 95       	lsr	r19
     85e:	32 2f       	mov	r19, r18
     860:	22 27       	eor	r18, r18
     862:	37 95       	ror	r19
     864:	27 95       	ror	r18
     866:	c2 27       	eor	r28, r18
     868:	d3 27       	eor	r29, r19
     86a:	c0 93 5a 42 	sts	0x425A, r28	; 0x80425a <__xor16_1f7_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:58
    seed_xor16_1f7(seed);
    seed = xor16_1f7();
    SERIALPORT.print("1f7: ");
     86e:	d0 93 5b 42 	sts	0x425B, r29	; 0x80425b <__xor16_1f7_state+0x1>
setup():
     872:	89 e0       	ldi	r24, 0x09	; 9
     874:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:59
    SERIALPORT.println(seed);
     876:	a9 dd       	rcall	.-1198   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     878:	ce 01       	movw	r24, r28
     87a:	ab dd       	rcall	.-1194   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_251():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_251.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     87c:	20 97       	sbiw	r28, 0x00	; 0
     87e:	21 f0       	breq	.+8      	; 0x888 <setup+0x42c>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_251.cpp:13
    __xor16_251_state = seed;
     880:	c0 93 5c 42 	sts	0x425C, r28	; 0x80425c <__xor16_251_state>
     884:	d0 93 5d 42 	sts	0x425D, r29	; 0x80425d <__xor16_251_state+0x1>
xor16_251():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_251.cpp:46
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_251_state)::"r18","r19");
     888:	c0 91 5c 42 	lds	r28, 0x425C	; 0x80425c <__xor16_251_state>
     88c:	d0 91 5d 42 	lds	r29, 0x425D	; 0x80425d <__xor16_251_state+0x1>
     890:	9e 01       	movw	r18, r28
     892:	22 0f       	add	r18, r18
     894:	33 1f       	adc	r19, r19
     896:	22 0f       	add	r18, r18
     898:	33 1f       	adc	r19, r19
     89a:	c2 27       	eor	r28, r18
     89c:	d3 27       	eor	r29, r19
     89e:	9e 01       	movw	r18, r28
     8a0:	36 95       	lsr	r19
     8a2:	27 95       	ror	r18
     8a4:	36 95       	lsr	r19
     8a6:	27 95       	ror	r18
     8a8:	36 95       	lsr	r19
     8aa:	27 95       	ror	r18
     8ac:	36 95       	lsr	r19
     8ae:	27 95       	ror	r18
     8b0:	36 95       	lsr	r19
     8b2:	27 95       	ror	r18
     8b4:	c2 27       	eor	r28, r18
     8b6:	d3 27       	eor	r29, r19
     8b8:	9e 01       	movw	r18, r28
     8ba:	22 0f       	add	r18, r18
     8bc:	33 1f       	adc	r19, r19
     8be:	c2 27       	eor	r28, r18
     8c0:	d3 27       	eor	r29, r19
     8c2:	c0 93 5c 42 	sts	0x425C, r28	; 0x80425c <__xor16_251_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:62
    seed_xor16_251(seed);
    seed = xor16_251();
    SERIALPORT.print("251: ");
     8c6:	d0 93 5d 42 	sts	0x425D, r29	; 0x80425d <__xor16_251_state+0x1>
setup():
     8ca:	8f e0       	ldi	r24, 0x0F	; 15
     8cc:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:63
    SERIALPORT.println(seed);
     8ce:	7d dd       	rcall	.-1286   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     8d0:	ce 01       	movw	r24, r28
     8d2:	7f dd       	rcall	.-1282   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_25d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     8d4:	20 97       	sbiw	r28, 0x00	; 0
     8d6:	21 f0       	breq	.+8      	; 0x8e0 <setup+0x484>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25d.cpp:13
    __xor16_25d_state = seed;
     8d8:	c0 93 5e 42 	sts	0x425E, r28	; 0x80425e <__xor16_25d_state>
     8dc:	d0 93 5f 42 	sts	0x425F, r29	; 0x80425f <__xor16_25d_state+0x1>
xor16_25d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25d.cpp:46
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_25d_state)::"r18","r19");
     8e0:	c0 91 5e 42 	lds	r28, 0x425E	; 0x80425e <__xor16_25d_state>
     8e4:	d0 91 5f 42 	lds	r29, 0x425F	; 0x80425f <__xor16_25d_state+0x1>
     8e8:	9e 01       	movw	r18, r28
     8ea:	22 0f       	add	r18, r18
     8ec:	33 1f       	adc	r19, r19
     8ee:	22 0f       	add	r18, r18
     8f0:	33 1f       	adc	r19, r19
     8f2:	c2 27       	eor	r28, r18
     8f4:	d3 27       	eor	r29, r19
     8f6:	9e 01       	movw	r18, r28
     8f8:	36 95       	lsr	r19
     8fa:	27 95       	ror	r18
     8fc:	36 95       	lsr	r19
     8fe:	27 95       	ror	r18
     900:	36 95       	lsr	r19
     902:	27 95       	ror	r18
     904:	36 95       	lsr	r19
     906:	27 95       	ror	r18
     908:	36 95       	lsr	r19
     90a:	27 95       	ror	r18
     90c:	c2 27       	eor	r28, r18
     90e:	d3 27       	eor	r29, r19
     910:	3c 2f       	mov	r19, r28
     912:	32 95       	swap	r19
     914:	33 0f       	add	r19, r19
     916:	30 7e       	andi	r19, 0xE0	; 224
     918:	d3 27       	eor	r29, r19
     91a:	c0 93 5e 42 	sts	0x425E, r28	; 0x80425e <__xor16_25d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:66
    seed_xor16_25d(seed);
    seed = xor16_25d();
    SERIALPORT.print("25d: ");
     91e:	d0 93 5f 42 	sts	0x425F, r29	; 0x80425f <__xor16_25d_state+0x1>
setup():
     922:	85 e1       	ldi	r24, 0x15	; 21
     924:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:67
    SERIALPORT.println(seed);
     926:	51 dd       	rcall	.-1374   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     928:	ce 01       	movw	r24, r28
     92a:	53 dd       	rcall	.-1370   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_25f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25f.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     92c:	20 97       	sbiw	r28, 0x00	; 0
     92e:	21 f0       	breq	.+8      	; 0x938 <setup+0x4dc>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25f.cpp:13
    __xor16_25f_state = seed;
     930:	c0 93 60 42 	sts	0x4260, r28	; 0x804260 <__xor16_25f_state>
     934:	d0 93 61 42 	sts	0x4261, r29	; 0x804261 <__xor16_25f_state+0x1>
xor16_25f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25f.cpp:45
      "eor    %B0, r19"      "\n\t"
      "eor    r19, r19"      "\n\t"
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_25f_state)::"r18","r19");
     938:	c0 91 60 42 	lds	r28, 0x4260	; 0x804260 <__xor16_25f_state>
     93c:	d0 91 61 42 	lds	r29, 0x4261	; 0x804261 <__xor16_25f_state+0x1>
     940:	9e 01       	movw	r18, r28
     942:	22 0f       	add	r18, r18
     944:	33 1f       	adc	r19, r19
     946:	22 0f       	add	r18, r18
     948:	33 1f       	adc	r19, r19
     94a:	c2 27       	eor	r28, r18
     94c:	d3 27       	eor	r29, r19
     94e:	9e 01       	movw	r18, r28
     950:	36 95       	lsr	r19
     952:	27 95       	ror	r18
     954:	36 95       	lsr	r19
     956:	27 95       	ror	r18
     958:	36 95       	lsr	r19
     95a:	27 95       	ror	r18
     95c:	36 95       	lsr	r19
     95e:	27 95       	ror	r18
     960:	36 95       	lsr	r19
     962:	27 95       	ror	r18
     964:	c2 27       	eor	r28, r18
     966:	d3 27       	eor	r29, r19
     968:	33 27       	eor	r19, r19
     96a:	c0 fb       	bst	r28, 0
     96c:	37 f9       	bld	r19, 7
     96e:	d3 27       	eor	r29, r19
     970:	c0 93 60 42 	sts	0x4260, r28	; 0x804260 <__xor16_25f_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:70
    seed_xor16_25f(seed);
    seed = xor16_25f();
    SERIALPORT.print("25f: ");
     974:	d0 93 61 42 	sts	0x4261, r29	; 0x804261 <__xor16_25f_state+0x1>
setup():
     978:	8b e1       	ldi	r24, 0x1B	; 27
     97a:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:71
    SERIALPORT.println(seed);
     97c:	26 dd       	rcall	.-1460   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     97e:	ce 01       	movw	r24, r28
     980:	28 dd       	rcall	.-1456   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_27d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     982:	20 97       	sbiw	r28, 0x00	; 0
     984:	21 f0       	breq	.+8      	; 0x98e <setup+0x532>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27d.cpp:13
    __xor16_27d_state = seed;
     986:	c0 93 62 42 	sts	0x4262, r28	; 0x804262 <__xor16_27d_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27d.cpp:41
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_27d_state)::"r18","r19");
     98a:	d0 93 63 42 	sts	0x4263, r29	; 0x804263 <__xor16_27d_state+0x1>
xor16_27d():
     98e:	c0 91 62 42 	lds	r28, 0x4262	; 0x804262 <__xor16_27d_state>
     992:	d0 91 63 42 	lds	r29, 0x4263	; 0x804263 <__xor16_27d_state+0x1>
     996:	9e 01       	movw	r18, r28
     998:	22 0f       	add	r18, r18
     99a:	33 1f       	adc	r19, r19
     99c:	22 0f       	add	r18, r18
     99e:	33 1f       	adc	r19, r19
     9a0:	c2 27       	eor	r28, r18
     9a2:	d3 27       	eor	r29, r19
     9a4:	9e 01       	movw	r18, r28
     9a6:	22 0f       	add	r18, r18
     9a8:	23 2f       	mov	r18, r19
     9aa:	22 1f       	adc	r18, r18
     9ac:	33 0b       	sbc	r19, r19
     9ae:	31 95       	neg	r19
     9b0:	c2 27       	eor	r28, r18
     9b2:	d3 27       	eor	r29, r19
     9b4:	3c 2f       	mov	r19, r28
     9b6:	32 95       	swap	r19
     9b8:	33 0f       	add	r19, r19
     9ba:	30 7e       	andi	r19, 0xE0	; 224
     9bc:	d3 27       	eor	r29, r19
     9be:	c0 93 62 42 	sts	0x4262, r28	; 0x804262 <__xor16_27d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:74
    seed_xor16_27d(seed);
    seed = xor16_27d();
    SERIALPORT.print("27d: ");
     9c2:	d0 93 63 42 	sts	0x4263, r29	; 0x804263 <__xor16_27d_state+0x1>
setup():
     9c6:	81 e2       	ldi	r24, 0x21	; 33
     9c8:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:75
    SERIALPORT.println(seed);
     9ca:	ff dc       	rcall	.-1538   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     9cc:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27f.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     9ce:	01 dd       	rcall	.-1534   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_27f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27f.cpp:13
    __xor16_27f_state = seed;
     9d0:	20 97       	sbiw	r28, 0x00	; 0
     9d2:	21 f0       	breq	.+8      	; 0x9dc <setup+0x580>
     9d4:	c0 93 64 42 	sts	0x4264, r28	; 0x804264 <__xor16_27f_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27f.cpp:40
      "eor    %B0, r19"      "\n\t"
      "eor    r19, r19"      "\n\t"
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_27f_state)::"r18","r19");
     9d8:	d0 93 65 42 	sts	0x4265, r29	; 0x804265 <__xor16_27f_state+0x1>
xor16_27f():
     9dc:	c0 91 64 42 	lds	r28, 0x4264	; 0x804264 <__xor16_27f_state>
     9e0:	d0 91 65 42 	lds	r29, 0x4265	; 0x804265 <__xor16_27f_state+0x1>
     9e4:	9e 01       	movw	r18, r28
     9e6:	22 0f       	add	r18, r18
     9e8:	33 1f       	adc	r19, r19
     9ea:	22 0f       	add	r18, r18
     9ec:	33 1f       	adc	r19, r19
     9ee:	c2 27       	eor	r28, r18
     9f0:	d3 27       	eor	r29, r19
     9f2:	9e 01       	movw	r18, r28
     9f4:	22 0f       	add	r18, r18
     9f6:	23 2f       	mov	r18, r19
     9f8:	22 1f       	adc	r18, r18
     9fa:	33 0b       	sbc	r19, r19
     9fc:	31 95       	neg	r19
     9fe:	c2 27       	eor	r28, r18
     a00:	d3 27       	eor	r29, r19
     a02:	33 27       	eor	r19, r19
     a04:	c0 fb       	bst	r28, 0
     a06:	37 f9       	bld	r19, 7
     a08:	d3 27       	eor	r29, r19
     a0a:	c0 93 64 42 	sts	0x4264, r28	; 0x804264 <__xor16_27f_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:78
    seed_xor16_27f(seed);
    seed = xor16_27f();
    SERIALPORT.print("27f: ");
     a0e:	d0 93 65 42 	sts	0x4265, r29	; 0x804265 <__xor16_27f_state+0x1>
setup():
     a12:	87 e2       	ldi	r24, 0x27	; 39
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:79
    SERIALPORT.println(seed);
     a14:	91 e4       	ldi	r25, 0x41	; 65
     a16:	d9 dc       	rcall	.-1614   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31c.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     a18:	ce 01       	movw	r24, r28
     a1a:	db dc       	rcall	.-1610   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_31c():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31c.cpp:13
    __xor16_31c_state = seed;
     a1c:	20 97       	sbiw	r28, 0x00	; 0
     a1e:	21 f0       	breq	.+8      	; 0xa28 <setup+0x5cc>
     a20:	c0 93 66 42 	sts	0x4266, r28	; 0x804266 <__xor16_31c_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31c.cpp:39
      "eor    %B0, r19"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "andi   r19, 0xF0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_31c_state)::"r18","r19");
     a24:	d0 93 67 42 	sts	0x4267, r29	; 0x804267 <__xor16_31c_state+0x1>
xor16_31c():
     a28:	c0 91 66 42 	lds	r28, 0x4266	; 0x804266 <__xor16_31c_state>
     a2c:	d0 91 67 42 	lds	r29, 0x4267	; 0x804267 <__xor16_31c_state+0x1>
     a30:	9e 01       	movw	r18, r28
     a32:	22 0f       	add	r18, r18
     a34:	33 1f       	adc	r19, r19
     a36:	22 0f       	add	r18, r18
     a38:	33 1f       	adc	r19, r19
     a3a:	22 0f       	add	r18, r18
     a3c:	33 1f       	adc	r19, r19
     a3e:	c2 27       	eor	r28, r18
     a40:	d3 27       	eor	r29, r19
     a42:	9e 01       	movw	r18, r28
     a44:	36 95       	lsr	r19
     a46:	27 95       	ror	r18
     a48:	c2 27       	eor	r28, r18
     a4a:	d3 27       	eor	r29, r19
     a4c:	3c 2f       	mov	r19, r28
     a4e:	32 95       	swap	r19
     a50:	30 7f       	andi	r19, 0xF0	; 240
     a52:	d3 27       	eor	r29, r19
     a54:	c0 93 66 42 	sts	0x4266, r28	; 0x804266 <__xor16_31c_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:82
    seed_xor16_31c(seed);
    seed = xor16_31c();
    SERIALPORT.print("31c: ");
     a58:	d0 93 67 42 	sts	0x4267, r29	; 0x804267 <__xor16_31c_state+0x1>
setup():
     a5c:	8d e2       	ldi	r24, 0x2D	; 45
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:83
    SERIALPORT.println(seed);
     a5e:	91 e4       	ldi	r25, 0x41	; 65
     a60:	b4 dc       	rcall	.-1688   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     a62:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31f.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     a64:	b6 dc       	rcall	.-1684   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_31f():
     a66:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31f.cpp:13
    __xor16_31f_state = seed;
     a68:	21 f0       	breq	.+8      	; 0xa72 <setup+0x616>
     a6a:	c0 93 68 42 	sts	0x4268, r28	; 0x804268 <__xor16_31f_state>
     a6e:	d0 93 69 42 	sts	0x4269, r29	; 0x804269 <__xor16_31f_state+0x1>
xor16_31f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31f.cpp:39
      "eor    %B0, r19"      "\n\t"
      "eor    r19, r19"      "\n\t"
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_31f_state)::"r18","r19");
     a72:	c0 91 68 42 	lds	r28, 0x4268	; 0x804268 <__xor16_31f_state>
     a76:	d0 91 69 42 	lds	r29, 0x4269	; 0x804269 <__xor16_31f_state+0x1>
     a7a:	9e 01       	movw	r18, r28
     a7c:	22 0f       	add	r18, r18
     a7e:	33 1f       	adc	r19, r19
     a80:	22 0f       	add	r18, r18
     a82:	33 1f       	adc	r19, r19
     a84:	22 0f       	add	r18, r18
     a86:	33 1f       	adc	r19, r19
     a88:	c2 27       	eor	r28, r18
     a8a:	d3 27       	eor	r29, r19
     a8c:	9e 01       	movw	r18, r28
     a8e:	36 95       	lsr	r19
     a90:	27 95       	ror	r18
     a92:	c2 27       	eor	r28, r18
     a94:	d3 27       	eor	r29, r19
     a96:	33 27       	eor	r19, r19
     a98:	c0 fb       	bst	r28, 0
     a9a:	37 f9       	bld	r19, 7
     a9c:	d3 27       	eor	r29, r19
     a9e:	c0 93 68 42 	sts	0x4268, r28	; 0x804268 <__xor16_31f_state>
     aa2:	d0 93 69 42 	sts	0x4269, r29	; 0x804269 <__xor16_31f_state+0x1>
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:86
    seed_xor16_31f(seed);
    seed = xor16_31f();
    SERIALPORT.print("31f: ");
     aa6:	83 e3       	ldi	r24, 0x33	; 51
     aa8:	91 e4       	ldi	r25, 0x41	; 65
     aaa:	8f dc       	rcall	.-1762   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:87
    SERIALPORT.println(seed);
     aac:	ce 01       	movw	r24, r28
     aae:	91 dc       	rcall	.-1758   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_35b():
     ab0:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_35b.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     ab2:	21 f0       	breq	.+8      	; 0xabc <setup+0x660>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_35b.cpp:13
    __xor16_35b_state = seed;
     ab4:	c0 93 6a 42 	sts	0x426A, r28	; 0x80426a <__xor16_35b_state>
     ab8:	d0 93 6b 42 	sts	0x426B, r29	; 0x80426b <__xor16_35b_state+0x1>
xor16_35b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_35b.cpp:48
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_35b_state)::"r18","r19");
     abc:	c0 91 6a 42 	lds	r28, 0x426A	; 0x80426a <__xor16_35b_state>
     ac0:	d0 91 6b 42 	lds	r29, 0x426B	; 0x80426b <__xor16_35b_state+0x1>
     ac4:	9e 01       	movw	r18, r28
     ac6:	22 0f       	add	r18, r18
     ac8:	33 1f       	adc	r19, r19
     aca:	22 0f       	add	r18, r18
     acc:	33 1f       	adc	r19, r19
     ace:	22 0f       	add	r18, r18
     ad0:	33 1f       	adc	r19, r19
     ad2:	c2 27       	eor	r28, r18
     ad4:	d3 27       	eor	r29, r19
     ad6:	9e 01       	movw	r18, r28
     ad8:	36 95       	lsr	r19
     ada:	27 95       	ror	r18
     adc:	36 95       	lsr	r19
     ade:	27 95       	ror	r18
     ae0:	36 95       	lsr	r19
     ae2:	27 95       	ror	r18
     ae4:	36 95       	lsr	r19
     ae6:	27 95       	ror	r18
     ae8:	36 95       	lsr	r19
     aea:	27 95       	ror	r18
     aec:	c2 27       	eor	r28, r18
     aee:	d3 27       	eor	r29, r19
     af0:	3c 2f       	mov	r19, r28
     af2:	33 0f       	add	r19, r19
     af4:	33 0f       	add	r19, r19
     af6:	33 0f       	add	r19, r19
     af8:	d3 27       	eor	r29, r19
     afa:	c0 93 6a 42 	sts	0x426A, r28	; 0x80426a <__xor16_35b_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:90
    seed_xor16_35b(seed);
    seed = xor16_35b();
    SERIALPORT.print("35b: ");
     afe:	d0 93 6b 42 	sts	0x426B, r29	; 0x80426b <__xor16_35b_state+0x1>
setup():
     b02:	89 e3       	ldi	r24, 0x39	; 57
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:91
    SERIALPORT.println(seed);
     b04:	91 e4       	ldi	r25, 0x41	; 65
     b06:	61 dc       	rcall	.-1854   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     b08:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3b1.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     b0a:	63 dc       	rcall	.-1850   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_3b1():
     b0c:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3b1.cpp:13
    __xor16_3b1_state = seed;
     b0e:	21 f0       	breq	.+8      	; 0xb18 <setup+0x6bc>
     b10:	c0 93 6c 42 	sts	0x426C, r28	; 0x80426c <__xor16_3b1_state>
     b14:	d0 93 6d 42 	sts	0x426D, r29	; 0x80426d <__xor16_3b1_state+0x1>
xor16_3b1():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3b1.cpp:40
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_3b1_state)::"r18","r19");
     b18:	c0 91 6c 42 	lds	r28, 0x426C	; 0x80426c <__xor16_3b1_state>
     b1c:	d0 91 6d 42 	lds	r29, 0x426D	; 0x80426d <__xor16_3b1_state+0x1>
     b20:	9e 01       	movw	r18, r28
     b22:	22 0f       	add	r18, r18
     b24:	33 1f       	adc	r19, r19
     b26:	22 0f       	add	r18, r18
     b28:	33 1f       	adc	r19, r19
     b2a:	22 0f       	add	r18, r18
     b2c:	33 1f       	adc	r19, r19
     b2e:	c2 27       	eor	r28, r18
     b30:	d3 27       	eor	r29, r19
     b32:	2d 2f       	mov	r18, r29
     b34:	26 95       	lsr	r18
     b36:	26 95       	lsr	r18
     b38:	26 95       	lsr	r18
     b3a:	c2 27       	eor	r28, r18
     b3c:	9e 01       	movw	r18, r28
     b3e:	22 0f       	add	r18, r18
     b40:	33 1f       	adc	r19, r19
     b42:	c2 27       	eor	r28, r18
     b44:	d3 27       	eor	r29, r19
     b46:	c0 93 6c 42 	sts	0x426C, r28	; 0x80426c <__xor16_3b1_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:94
    seed_xor16_3b1(seed);
    seed = xor16_3b1();
    SERIALPORT.print("3b1: ");
     b4a:	d0 93 6d 42 	sts	0x426D, r29	; 0x80426d <__xor16_3b1_state+0x1>
setup():
     b4e:	8f e3       	ldi	r24, 0x3F	; 63
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:95
    SERIALPORT.println(seed);
     b50:	91 e4       	ldi	r25, 0x41	; 65
     b52:	3b dc       	rcall	.-1930   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     b54:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3bb.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     b56:	3d dc       	rcall	.-1926   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_3bb():
     b58:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3bb.cpp:13
    __xor16_3bb_state = seed;
     b5a:	21 f0       	breq	.+8      	; 0xb64 <setup+0x708>
     b5c:	c0 93 6e 42 	sts	0x426E, r28	; 0x80426e <__xor16_3bb_state>
     b60:	d0 93 6f 42 	sts	0x426F, r29	; 0x80426f <__xor16_3bb_state+0x1>
xor16_3bb():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3bb.cpp:40
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_3bb_state)::"r18","r19");
     b64:	c0 91 6e 42 	lds	r28, 0x426E	; 0x80426e <__xor16_3bb_state>
     b68:	d0 91 6f 42 	lds	r29, 0x426F	; 0x80426f <__xor16_3bb_state+0x1>
     b6c:	9e 01       	movw	r18, r28
     b6e:	22 0f       	add	r18, r18
     b70:	33 1f       	adc	r19, r19
     b72:	22 0f       	add	r18, r18
     b74:	33 1f       	adc	r19, r19
     b76:	22 0f       	add	r18, r18
     b78:	33 1f       	adc	r19, r19
     b7a:	c2 27       	eor	r28, r18
     b7c:	d3 27       	eor	r29, r19
     b7e:	2d 2f       	mov	r18, r29
     b80:	26 95       	lsr	r18
     b82:	26 95       	lsr	r18
     b84:	26 95       	lsr	r18
     b86:	c2 27       	eor	r28, r18
     b88:	3c 2f       	mov	r19, r28
     b8a:	33 0f       	add	r19, r19
     b8c:	33 0f       	add	r19, r19
     b8e:	33 0f       	add	r19, r19
     b90:	d3 27       	eor	r29, r19
     b92:	c0 93 6e 42 	sts	0x426E, r28	; 0x80426e <__xor16_3bb_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:98
    seed_xor16_3bb(seed);
    seed = xor16_3bb();
    SERIALPORT.print("3bb: ");
     b96:	d0 93 6f 42 	sts	0x426F, r29	; 0x80426f <__xor16_3bb_state+0x1>
setup():
     b9a:	85 e4       	ldi	r24, 0x45	; 69
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:99
    SERIALPORT.println(seed);
     b9c:	91 e4       	ldi	r25, 0x41	; 65
     b9e:	15 dc       	rcall	.-2006   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     ba0:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3d9.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     ba2:	17 dc       	rcall	.-2002   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_3d9():
     ba4:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3d9.cpp:13
    __xor16_3d9_state = seed;
     ba6:	21 f0       	breq	.+8      	; 0xbb0 <setup+0x754>
     ba8:	c0 93 70 42 	sts	0x4270, r28	; 0x804270 <__xor16_3d9_state>
     bac:	d0 93 71 42 	sts	0x4271, r29	; 0x804271 <__xor16_3d9_state+0x1>
xor16_3d9():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3d9.cpp:38
      "andi   r18, 0x07"     "\n\t"
      "eor    %A0, r18"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_3d9_state)::"r18","r19");
     bb0:	c0 91 70 42 	lds	r28, 0x4270	; 0x804270 <__xor16_3d9_state>
     bb4:	d0 91 71 42 	lds	r29, 0x4271	; 0x804271 <__xor16_3d9_state+0x1>
     bb8:	9e 01       	movw	r18, r28
     bba:	22 0f       	add	r18, r18
     bbc:	33 1f       	adc	r19, r19
     bbe:	22 0f       	add	r18, r18
     bc0:	33 1f       	adc	r19, r19
     bc2:	22 0f       	add	r18, r18
     bc4:	33 1f       	adc	r19, r19
     bc6:	c2 27       	eor	r28, r18
     bc8:	d3 27       	eor	r29, r19
     bca:	2d 2f       	mov	r18, r29
     bcc:	22 95       	swap	r18
     bce:	26 95       	lsr	r18
     bd0:	27 70       	andi	r18, 0x07	; 7
     bd2:	c2 27       	eor	r28, r18
     bd4:	3c 2f       	mov	r19, r28
     bd6:	33 0f       	add	r19, r19
     bd8:	d3 27       	eor	r29, r19
     bda:	c0 93 70 42 	sts	0x4270, r28	; 0x804270 <__xor16_3d9_state>
     bde:	d0 93 71 42 	sts	0x4271, r29	; 0x804271 <__xor16_3d9_state+0x1>
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:102
    seed_xor16_3d9(seed);
    seed = xor16_3d9();
    SERIALPORT.print("3d9: ");
     be2:	8b e4       	ldi	r24, 0x4B	; 75
     be4:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:103
    SERIALPORT.println(seed);
     be6:	f1 db       	rcall	.-2078   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     be8:	ce 01       	movw	r24, r28
     bea:	f3 db       	rcall	.-2074   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_437():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_437.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     bec:	20 97       	sbiw	r28, 0x00	; 0
     bee:	21 f0       	breq	.+8      	; 0xbf8 <setup+0x79c>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_437.cpp:13
    __xor16_437_state = seed;
     bf0:	c0 93 72 42 	sts	0x4272, r28	; 0x804272 <__xor16_437_state>
     bf4:	d0 93 73 42 	sts	0x4273, r29	; 0x804273 <__xor16_437_state+0x1>
xor16_437():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_437.cpp:49
      "eor    r18, r18"      "\n\t"
      "ror    r19"           "\n\t"
      "ror    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_437_state)::"r18","r19");
     bf8:	c0 91 72 42 	lds	r28, 0x4272	; 0x804272 <__xor16_437_state>
     bfc:	d0 91 73 42 	lds	r29, 0x4273	; 0x804273 <__xor16_437_state+0x1>
     c00:	9e 01       	movw	r18, r28
     c02:	22 0f       	add	r18, r18
     c04:	33 1f       	adc	r19, r19
     c06:	22 0f       	add	r18, r18
     c08:	33 1f       	adc	r19, r19
     c0a:	22 0f       	add	r18, r18
     c0c:	33 1f       	adc	r19, r19
     c0e:	22 0f       	add	r18, r18
     c10:	33 1f       	adc	r19, r19
     c12:	c2 27       	eor	r28, r18
     c14:	d3 27       	eor	r29, r19
     c16:	9e 01       	movw	r18, r28
     c18:	36 95       	lsr	r19
     c1a:	27 95       	ror	r18
     c1c:	36 95       	lsr	r19
     c1e:	27 95       	ror	r18
     c20:	36 95       	lsr	r19
     c22:	27 95       	ror	r18
     c24:	c2 27       	eor	r28, r18
     c26:	d3 27       	eor	r29, r19
     c28:	9e 01       	movw	r18, r28
     c2a:	36 95       	lsr	r19
     c2c:	32 2f       	mov	r19, r18
     c2e:	22 27       	eor	r18, r18
     c30:	37 95       	ror	r19
     c32:	27 95       	ror	r18
     c34:	c2 27       	eor	r28, r18
     c36:	d3 27       	eor	r29, r19
     c38:	c0 93 72 42 	sts	0x4272, r28	; 0x804272 <__xor16_437_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:106
    seed_xor16_437(seed);
    seed = xor16_437();
    SERIALPORT.print("437: ");
     c3c:	d0 93 73 42 	sts	0x4273, r29	; 0x804273 <__xor16_437_state+0x1>
setup():
     c40:	81 e5       	ldi	r24, 0x51	; 81
     c42:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:107
    SERIALPORT.println(seed);
     c44:	c2 db       	rcall	.-2172   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     c46:	ce 01       	movw	r24, r28
     c48:	c4 db       	rcall	.-2168   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_471():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_471.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     c4a:	20 97       	sbiw	r28, 0x00	; 0
     c4c:	21 f0       	breq	.+8      	; 0xc56 <setup+0x7fa>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_471.cpp:13
    __xor16_471_state = seed;
     c4e:	c0 93 74 42 	sts	0x4274, r28	; 0x804274 <__xor16_471_state>
     c52:	d0 93 75 42 	sts	0x4275, r29	; 0x804275 <__xor16_471_state+0x1>
xor16_471():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_471.cpp:45
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_471_state)::"r18","r19");
     c56:	c0 91 74 42 	lds	r28, 0x4274	; 0x804274 <__xor16_471_state>
     c5a:	d0 91 75 42 	lds	r29, 0x4275	; 0x804275 <__xor16_471_state+0x1>
     c5e:	9e 01       	movw	r18, r28
     c60:	22 0f       	add	r18, r18
     c62:	33 1f       	adc	r19, r19
     c64:	22 0f       	add	r18, r18
     c66:	33 1f       	adc	r19, r19
     c68:	22 0f       	add	r18, r18
     c6a:	33 1f       	adc	r19, r19
     c6c:	22 0f       	add	r18, r18
     c6e:	33 1f       	adc	r19, r19
     c70:	c2 27       	eor	r28, r18
     c72:	d3 27       	eor	r29, r19
     c74:	9e 01       	movw	r18, r28
     c76:	22 0f       	add	r18, r18
     c78:	23 2f       	mov	r18, r19
     c7a:	22 1f       	adc	r18, r18
     c7c:	33 0b       	sbc	r19, r19
     c7e:	31 95       	neg	r19
     c80:	c2 27       	eor	r28, r18
     c82:	d3 27       	eor	r29, r19
     c84:	9e 01       	movw	r18, r28
     c86:	22 0f       	add	r18, r18
     c88:	33 1f       	adc	r19, r19
     c8a:	c2 27       	eor	r28, r18
     c8c:	d3 27       	eor	r29, r19
     c8e:	c0 93 74 42 	sts	0x4274, r28	; 0x804274 <__xor16_471_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:110
    seed_xor16_471(seed);
    seed = xor16_471();
    SERIALPORT.print("471: ");
     c92:	d0 93 75 42 	sts	0x4275, r29	; 0x804275 <__xor16_471_state+0x1>
setup():
     c96:	87 e5       	ldi	r24, 0x57	; 87
     c98:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:111
    SERIALPORT.println(seed);
     c9a:	97 db       	rcall	.-2258   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     c9c:	ce 01       	movw	r24, r28
     c9e:	99 db       	rcall	.-2254   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_4bb():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_4bb.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     ca0:	20 97       	sbiw	r28, 0x00	; 0
     ca2:	21 f0       	breq	.+8      	; 0xcac <setup+0x850>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_4bb.cpp:13
    __xor16_4bb_state = seed;
     ca4:	c0 93 76 42 	sts	0x4276, r28	; 0x804276 <__xor16_4bb_state>
     ca8:	d0 93 77 42 	sts	0x4277, r29	; 0x804277 <__xor16_4bb_state+0x1>
xor16_4bb():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_4bb.cpp:42
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_4bb_state)::"r18","r19");
     cac:	c0 91 76 42 	lds	r28, 0x4276	; 0x804276 <__xor16_4bb_state>
     cb0:	d0 91 77 42 	lds	r29, 0x4277	; 0x804277 <__xor16_4bb_state+0x1>
     cb4:	9e 01       	movw	r18, r28
     cb6:	22 0f       	add	r18, r18
     cb8:	33 1f       	adc	r19, r19
     cba:	22 0f       	add	r18, r18
     cbc:	33 1f       	adc	r19, r19
     cbe:	22 0f       	add	r18, r18
     cc0:	33 1f       	adc	r19, r19
     cc2:	22 0f       	add	r18, r18
     cc4:	33 1f       	adc	r19, r19
     cc6:	c2 27       	eor	r28, r18
     cc8:	d3 27       	eor	r29, r19
     cca:	2d 2f       	mov	r18, r29
     ccc:	26 95       	lsr	r18
     cce:	26 95       	lsr	r18
     cd0:	26 95       	lsr	r18
     cd2:	c2 27       	eor	r28, r18
     cd4:	3c 2f       	mov	r19, r28
     cd6:	33 0f       	add	r19, r19
     cd8:	33 0f       	add	r19, r19
     cda:	33 0f       	add	r19, r19
     cdc:	d3 27       	eor	r29, r19
     cde:	c0 93 76 42 	sts	0x4276, r28	; 0x804276 <__xor16_4bb_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:114
    seed_xor16_4bb(seed);
    seed = xor16_4bb();
    SERIALPORT.print("4bb: ");
     ce2:	d0 93 77 42 	sts	0x4277, r29	; 0x804277 <__xor16_4bb_state+0x1>
setup():
     ce6:	8d e5       	ldi	r24, 0x5D	; 93
     ce8:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:115
    SERIALPORT.println(seed);
     cea:	6f db       	rcall	.-2338   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     cec:	ce 01       	movw	r24, r28
     cee:	71 db       	rcall	.-2334   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_57e():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_57e.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     cf0:	20 97       	sbiw	r28, 0x00	; 0
     cf2:	21 f0       	breq	.+8      	; 0xcfc <setup+0x8a0>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_57e.cpp:13
    __xor16_57e_state = seed;
     cf4:	c0 93 78 42 	sts	0x4278, r28	; 0x804278 <__xor16_57e_state>
     cf8:	d0 93 79 42 	sts	0x4279, r29	; 0x804279 <__xor16_57e_state+0x1>
xor16_57e():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_57e.cpp:48
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 6"        "\n\t"
      "bst    %A0, 1"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_57e_state)::"r18","r19");
     cfc:	c0 91 78 42 	lds	r28, 0x4278	; 0x804278 <__xor16_57e_state>
     d00:	d0 91 79 42 	lds	r29, 0x4279	; 0x804279 <__xor16_57e_state+0x1>
     d04:	9e 01       	movw	r18, r28
     d06:	22 0f       	add	r18, r18
     d08:	33 1f       	adc	r19, r19
     d0a:	22 0f       	add	r18, r18
     d0c:	33 1f       	adc	r19, r19
     d0e:	22 0f       	add	r18, r18
     d10:	33 1f       	adc	r19, r19
     d12:	22 0f       	add	r18, r18
     d14:	33 1f       	adc	r19, r19
     d16:	22 0f       	add	r18, r18
     d18:	33 1f       	adc	r19, r19
     d1a:	c2 27       	eor	r28, r18
     d1c:	d3 27       	eor	r29, r19
     d1e:	9e 01       	movw	r18, r28
     d20:	22 0f       	add	r18, r18
     d22:	23 2f       	mov	r18, r19
     d24:	22 1f       	adc	r18, r18
     d26:	33 0b       	sbc	r19, r19
     d28:	31 95       	neg	r19
     d2a:	c2 27       	eor	r28, r18
     d2c:	d3 27       	eor	r29, r19
     d2e:	33 27       	eor	r19, r19
     d30:	c0 fb       	bst	r28, 0
     d32:	36 f9       	bld	r19, 6
     d34:	c1 fb       	bst	r28, 1
     d36:	37 f9       	bld	r19, 7
     d38:	d3 27       	eor	r29, r19
     d3a:	c0 93 78 42 	sts	0x4278, r28	; 0x804278 <__xor16_57e_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:118
    seed_xor16_57e(seed);
    seed = xor16_57e();
    SERIALPORT.print("57e: ");
     d3e:	d0 93 79 42 	sts	0x4279, r29	; 0x804279 <__xor16_57e_state+0x1>
setup():
     d42:	83 e6       	ldi	r24, 0x63	; 99
     d44:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:119
    SERIALPORT.println(seed);
     d46:	41 db       	rcall	.-2430   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     d48:	ce 01       	movw	r24, r28
     d4a:	43 db       	rcall	.-2426   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_598():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_598.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     d4c:	20 97       	sbiw	r28, 0x00	; 0
     d4e:	21 f0       	breq	.+8      	; 0xd58 <setup+0x8fc>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_598.cpp:13
    __xor16_598_state = seed;
     d50:	c0 93 7a 42 	sts	0x427A, r28	; 0x80427a <__xor16_598_state>
     d54:	d0 93 7b 42 	sts	0x427B, r29	; 0x80427b <__xor16_598_state+0x1>
xor16_598():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_598.cpp:39
      "mov    r18, %B0"      "\n\t"
      "lsr    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_598_state)::"r18","r19");
     d58:	c0 91 7a 42 	lds	r28, 0x427A	; 0x80427a <__xor16_598_state>
     d5c:	d0 91 7b 42 	lds	r29, 0x427B	; 0x80427b <__xor16_598_state+0x1>
     d60:	9e 01       	movw	r18, r28
     d62:	22 0f       	add	r18, r18
     d64:	33 1f       	adc	r19, r19
     d66:	22 0f       	add	r18, r18
     d68:	33 1f       	adc	r19, r19
     d6a:	22 0f       	add	r18, r18
     d6c:	33 1f       	adc	r19, r19
     d6e:	22 0f       	add	r18, r18
     d70:	33 1f       	adc	r19, r19
     d72:	22 0f       	add	r18, r18
     d74:	33 1f       	adc	r19, r19
     d76:	c2 27       	eor	r28, r18
     d78:	d3 27       	eor	r29, r19
     d7a:	2d 2f       	mov	r18, r29
     d7c:	26 95       	lsr	r18
     d7e:	c2 27       	eor	r28, r18
     d80:	3c 2f       	mov	r19, r28
     d82:	d3 27       	eor	r29, r19
     d84:	c0 93 7a 42 	sts	0x427A, r28	; 0x80427a <__xor16_598_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:122
    seed_xor16_598(seed);
    seed = xor16_598();
    SERIALPORT.print("598: ");
     d88:	d0 93 7b 42 	sts	0x427B, r29	; 0x80427b <__xor16_598_state+0x1>
setup():
     d8c:	89 e6       	ldi	r24, 0x69	; 105
     d8e:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:123
    SERIALPORT.println(seed);
     d90:	1c db       	rcall	.-2504   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     d92:	ce 01       	movw	r24, r28
     d94:	1e db       	rcall	.-2500   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_5b6():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5b6.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     d96:	20 97       	sbiw	r28, 0x00	; 0
     d98:	21 f0       	breq	.+8      	; 0xda2 <setup+0x946>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5b6.cpp:13
    __xor16_5b6_state = seed;
     d9a:	c0 93 7c 42 	sts	0x427C, r28	; 0x80427c <__xor16_5b6_state>
     d9e:	d0 93 7d 42 	sts	0x427D, r29	; 0x80427d <__xor16_5b6_state+0x1>
xor16_5b6():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5b6.cpp:54
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_5b6_state)::"r18","r19");
     da2:	c0 91 7c 42 	lds	r28, 0x427C	; 0x80427c <__xor16_5b6_state>
     da6:	d0 91 7d 42 	lds	r29, 0x427D	; 0x80427d <__xor16_5b6_state+0x1>
     daa:	9e 01       	movw	r18, r28
     dac:	22 0f       	add	r18, r18
     dae:	33 1f       	adc	r19, r19
     db0:	22 0f       	add	r18, r18
     db2:	33 1f       	adc	r19, r19
     db4:	22 0f       	add	r18, r18
     db6:	33 1f       	adc	r19, r19
     db8:	22 0f       	add	r18, r18
     dba:	33 1f       	adc	r19, r19
     dbc:	22 0f       	add	r18, r18
     dbe:	33 1f       	adc	r19, r19
     dc0:	c2 27       	eor	r28, r18
     dc2:	d3 27       	eor	r29, r19
     dc4:	2d 2f       	mov	r18, r29
     dc6:	26 95       	lsr	r18
     dc8:	26 95       	lsr	r18
     dca:	26 95       	lsr	r18
     dcc:	c2 27       	eor	r28, r18
     dce:	9e 01       	movw	r18, r28
     dd0:	22 0f       	add	r18, r18
     dd2:	33 1f       	adc	r19, r19
     dd4:	22 0f       	add	r18, r18
     dd6:	33 1f       	adc	r19, r19
     dd8:	22 0f       	add	r18, r18
     dda:	33 1f       	adc	r19, r19
     ddc:	22 0f       	add	r18, r18
     dde:	33 1f       	adc	r19, r19
     de0:	22 0f       	add	r18, r18
     de2:	33 1f       	adc	r19, r19
     de4:	22 0f       	add	r18, r18
     de6:	33 1f       	adc	r19, r19
     de8:	c2 27       	eor	r28, r18
     dea:	d3 27       	eor	r29, r19
     dec:	c0 93 7c 42 	sts	0x427C, r28	; 0x80427c <__xor16_5b6_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:126
    seed_xor16_5b6(seed);
    seed = xor16_5b6();
    SERIALPORT.print("5b6: ");
     df0:	d0 93 7d 42 	sts	0x427D, r29	; 0x80427d <__xor16_5b6_state+0x1>
setup():
     df4:	8f e6       	ldi	r24, 0x6F	; 111
     df6:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:127
    SERIALPORT.println(seed);
     df8:	e8 da       	rcall	.-2608   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     dfa:	ce 01       	movw	r24, r28
     dfc:	ea da       	rcall	.-2604   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_5bb():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5bb.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     dfe:	20 97       	sbiw	r28, 0x00	; 0
     e00:	21 f0       	breq	.+8      	; 0xe0a <setup+0x9ae>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5bb.cpp:13
    __xor16_5bb_state = seed;
     e02:	c0 93 7e 42 	sts	0x427E, r28	; 0x80427e <__xor16_5bb_state>
     e06:	d0 93 7f 42 	sts	0x427F, r29	; 0x80427f <__xor16_5bb_state+0x1>
xor16_5bb():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5bb.cpp:44
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_5bb_state)::"r18","r19");
     e0a:	c0 91 7e 42 	lds	r28, 0x427E	; 0x80427e <__xor16_5bb_state>
     e0e:	d0 91 7f 42 	lds	r29, 0x427F	; 0x80427f <__xor16_5bb_state+0x1>
     e12:	9e 01       	movw	r18, r28
     e14:	22 0f       	add	r18, r18
     e16:	33 1f       	adc	r19, r19
     e18:	22 0f       	add	r18, r18
     e1a:	33 1f       	adc	r19, r19
     e1c:	22 0f       	add	r18, r18
     e1e:	33 1f       	adc	r19, r19
     e20:	22 0f       	add	r18, r18
     e22:	33 1f       	adc	r19, r19
     e24:	22 0f       	add	r18, r18
     e26:	33 1f       	adc	r19, r19
     e28:	c2 27       	eor	r28, r18
     e2a:	d3 27       	eor	r29, r19
     e2c:	2d 2f       	mov	r18, r29
     e2e:	26 95       	lsr	r18
     e30:	26 95       	lsr	r18
     e32:	26 95       	lsr	r18
     e34:	c2 27       	eor	r28, r18
     e36:	3c 2f       	mov	r19, r28
     e38:	33 0f       	add	r19, r19
     e3a:	33 0f       	add	r19, r19
     e3c:	33 0f       	add	r19, r19
     e3e:	d3 27       	eor	r29, r19
     e40:	c0 93 7e 42 	sts	0x427E, r28	; 0x80427e <__xor16_5bb_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:130
    seed_xor16_5bb(seed);
    seed = xor16_5bb();
    SERIALPORT.print("5bb: ");
     e44:	d0 93 7f 42 	sts	0x427F, r29	; 0x80427f <__xor16_5bb_state+0x1>
setup():
     e48:	85 e7       	ldi	r24, 0x75	; 117
     e4a:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:131
    SERIALPORT.println(seed);
     e4c:	be da       	rcall	.-2692   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     e4e:	ce 01       	movw	r24, r28
     e50:	c0 da       	rcall	.-2688   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_67d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_67d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     e52:	20 97       	sbiw	r28, 0x00	; 0
     e54:	21 f0       	breq	.+8      	; 0xe5e <setup+0xa02>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_67d.cpp:13
    __xor16_67d_state = seed;
     e56:	c0 93 80 42 	sts	0x4280, r28	; 0x804280 <__xor16_67d_state>
     e5a:	d0 93 81 42 	sts	0x4281, r29	; 0x804281 <__xor16_67d_state+0x1>
xor16_67d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_67d.cpp:49
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_67d_state)::"r18","r19");
     e5e:	c0 91 80 42 	lds	r28, 0x4280	; 0x804280 <__xor16_67d_state>
     e62:	d0 91 81 42 	lds	r29, 0x4281	; 0x804281 <__xor16_67d_state+0x1>
     e66:	9e 01       	movw	r18, r28
     e68:	22 0f       	add	r18, r18
     e6a:	33 1f       	adc	r19, r19
     e6c:	22 0f       	add	r18, r18
     e6e:	33 1f       	adc	r19, r19
     e70:	22 0f       	add	r18, r18
     e72:	33 1f       	adc	r19, r19
     e74:	22 0f       	add	r18, r18
     e76:	33 1f       	adc	r19, r19
     e78:	22 0f       	add	r18, r18
     e7a:	33 1f       	adc	r19, r19
     e7c:	22 0f       	add	r18, r18
     e7e:	33 1f       	adc	r19, r19
     e80:	c2 27       	eor	r28, r18
     e82:	d3 27       	eor	r29, r19
     e84:	9e 01       	movw	r18, r28
     e86:	22 0f       	add	r18, r18
     e88:	23 2f       	mov	r18, r19
     e8a:	22 1f       	adc	r18, r18
     e8c:	33 0b       	sbc	r19, r19
     e8e:	31 95       	neg	r19
     e90:	c2 27       	eor	r28, r18
     e92:	d3 27       	eor	r29, r19
     e94:	3c 2f       	mov	r19, r28
     e96:	32 95       	swap	r19
     e98:	33 0f       	add	r19, r19
     e9a:	30 7e       	andi	r19, 0xE0	; 224
     e9c:	d3 27       	eor	r29, r19
     e9e:	c0 93 80 42 	sts	0x4280, r28	; 0x804280 <__xor16_67d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:134
    seed_xor16_67d(seed);
    seed = xor16_67d();
    SERIALPORT.print("67d: ");
     ea2:	d0 93 81 42 	sts	0x4281, r29	; 0x804281 <__xor16_67d_state+0x1>
setup():
     ea6:	8b e7       	ldi	r24, 0x7B	; 123
     ea8:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:135
    SERIALPORT.println(seed);
     eaa:	8f da       	rcall	.-2786   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     eac:	ce 01       	movw	r24, r28
     eae:	91 da       	rcall	.-2782   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_6b5():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6b5.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     eb0:	20 97       	sbiw	r28, 0x00	; 0
     eb2:	21 f0       	breq	.+8      	; 0xebc <setup+0xa60>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6b5.cpp:13
    __xor16_6b5_state = seed;
     eb4:	c0 93 82 42 	sts	0x4282, r28	; 0x804282 <__xor16_6b5_state>
     eb8:	d0 93 83 42 	sts	0x4283, r29	; 0x804283 <__xor16_6b5_state+0x1>
xor16_6b5():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6b5.cpp:54
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_6b5_state)::"r18","r19");
     ebc:	c0 91 82 42 	lds	r28, 0x4282	; 0x804282 <__xor16_6b5_state>
     ec0:	d0 91 83 42 	lds	r29, 0x4283	; 0x804283 <__xor16_6b5_state+0x1>
     ec4:	9e 01       	movw	r18, r28
     ec6:	22 0f       	add	r18, r18
     ec8:	33 1f       	adc	r19, r19
     eca:	22 0f       	add	r18, r18
     ecc:	33 1f       	adc	r19, r19
     ece:	22 0f       	add	r18, r18
     ed0:	33 1f       	adc	r19, r19
     ed2:	22 0f       	add	r18, r18
     ed4:	33 1f       	adc	r19, r19
     ed6:	22 0f       	add	r18, r18
     ed8:	33 1f       	adc	r19, r19
     eda:	22 0f       	add	r18, r18
     edc:	33 1f       	adc	r19, r19
     ede:	c2 27       	eor	r28, r18
     ee0:	d3 27       	eor	r29, r19
     ee2:	2d 2f       	mov	r18, r29
     ee4:	26 95       	lsr	r18
     ee6:	26 95       	lsr	r18
     ee8:	26 95       	lsr	r18
     eea:	c2 27       	eor	r28, r18
     eec:	9e 01       	movw	r18, r28
     eee:	22 0f       	add	r18, r18
     ef0:	33 1f       	adc	r19, r19
     ef2:	22 0f       	add	r18, r18
     ef4:	33 1f       	adc	r19, r19
     ef6:	22 0f       	add	r18, r18
     ef8:	33 1f       	adc	r19, r19
     efa:	22 0f       	add	r18, r18
     efc:	33 1f       	adc	r19, r19
     efe:	22 0f       	add	r18, r18
     f00:	33 1f       	adc	r19, r19
     f02:	c2 27       	eor	r28, r18
     f04:	d3 27       	eor	r29, r19
     f06:	c0 93 82 42 	sts	0x4282, r28	; 0x804282 <__xor16_6b5_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:138
    seed_xor16_6b5(seed);
    seed = xor16_6b5();
    SERIALPORT.print("6b5: ");
     f0a:	d0 93 83 42 	sts	0x4283, r29	; 0x804283 <__xor16_6b5_state+0x1>
setup():
     f0e:	81 e8       	ldi	r24, 0x81	; 129
     f10:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:139
    SERIALPORT.println(seed);
     f12:	5b da       	rcall	.-2890   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     f14:	ce 01       	movw	r24, r28
     f16:	5d da       	rcall	.-2886   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_6f1():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6f1.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     f18:	20 97       	sbiw	r28, 0x00	; 0
     f1a:	21 f0       	breq	.+8      	; 0xf24 <setup+0xac8>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6f1.cpp:13
    __xor16_6f1_state = seed;
     f1c:	c0 93 84 42 	sts	0x4284, r28	; 0x804284 <__xor16_6f1_state>
     f20:	d0 93 85 42 	sts	0x4285, r29	; 0x804285 <__xor16_6f1_state+0x1>
xor16_6f1():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6f1.cpp:45
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_6f1_state)::"r18","r19");
     f24:	c0 91 84 42 	lds	r28, 0x4284	; 0x804284 <__xor16_6f1_state>
     f28:	d0 91 85 42 	lds	r29, 0x4285	; 0x804285 <__xor16_6f1_state+0x1>
     f2c:	9e 01       	movw	r18, r28
     f2e:	22 0f       	add	r18, r18
     f30:	33 1f       	adc	r19, r19
     f32:	22 0f       	add	r18, r18
     f34:	33 1f       	adc	r19, r19
     f36:	22 0f       	add	r18, r18
     f38:	33 1f       	adc	r19, r19
     f3a:	22 0f       	add	r18, r18
     f3c:	33 1f       	adc	r19, r19
     f3e:	22 0f       	add	r18, r18
     f40:	33 1f       	adc	r19, r19
     f42:	22 0f       	add	r18, r18
     f44:	33 1f       	adc	r19, r19
     f46:	c2 27       	eor	r28, r18
     f48:	d3 27       	eor	r29, r19
     f4a:	d7 fb       	bst	r29, 7
     f4c:	22 27       	eor	r18, r18
     f4e:	20 f9       	bld	r18, 0
     f50:	c2 27       	eor	r28, r18
     f52:	9e 01       	movw	r18, r28
     f54:	22 0f       	add	r18, r18
     f56:	33 1f       	adc	r19, r19
     f58:	c2 27       	eor	r28, r18
     f5a:	d3 27       	eor	r29, r19
     f5c:	c0 93 84 42 	sts	0x4284, r28	; 0x804284 <__xor16_6f1_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:142
    seed_xor16_6f1(seed);
    seed = xor16_6f1();
    SERIALPORT.print("6f1: ");
     f60:	d0 93 85 42 	sts	0x4285, r29	; 0x804285 <__xor16_6f1_state+0x1>
setup():
     f64:	87 e8       	ldi	r24, 0x87	; 135
     f66:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:143
    SERIALPORT.println(seed);
     f68:	30 da       	rcall	.-2976   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     f6a:	ce 01       	movw	r24, r28
     f6c:	32 da       	rcall	.-2972   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_71b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_71b.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     f6e:	20 97       	sbiw	r28, 0x00	; 0
     f70:	21 f0       	breq	.+8      	; 0xf7a <setup+0xb1e>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_71b.cpp:13
    __xor16_71b_state = seed;
     f72:	c0 93 86 42 	sts	0x4286, r28	; 0x804286 <__xor16_71b_state>
     f76:	d0 93 87 42 	sts	0x4287, r29	; 0x804287 <__xor16_71b_state+0x1>
xor16_71b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_71b.cpp:39
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_71b_state)::"r18","r19");
     f7a:	c0 91 86 42 	lds	r28, 0x4286	; 0x804286 <__xor16_71b_state>
     f7e:	d0 91 87 42 	lds	r29, 0x4287	; 0x804287 <__xor16_71b_state+0x1>
     f82:	9e 01       	movw	r18, r28
     f84:	36 95       	lsr	r19
     f86:	32 2f       	mov	r19, r18
     f88:	22 27       	eor	r18, r18
     f8a:	37 95       	ror	r19
     f8c:	27 95       	ror	r18
     f8e:	c2 27       	eor	r28, r18
     f90:	d3 27       	eor	r29, r19
     f92:	9e 01       	movw	r18, r28
     f94:	36 95       	lsr	r19
     f96:	27 95       	ror	r18
     f98:	c2 27       	eor	r28, r18
     f9a:	d3 27       	eor	r29, r19
     f9c:	3c 2f       	mov	r19, r28
     f9e:	33 0f       	add	r19, r19
     fa0:	33 0f       	add	r19, r19
     fa2:	33 0f       	add	r19, r19
     fa4:	d3 27       	eor	r29, r19
     fa6:	c0 93 86 42 	sts	0x4286, r28	; 0x804286 <__xor16_71b_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:146
    seed_xor16_71b(seed);
    seed = xor16_71b();
    SERIALPORT.print("71b: ");
     faa:	d0 93 87 42 	sts	0x4287, r29	; 0x804287 <__xor16_71b_state+0x1>
setup():
     fae:	8d e8       	ldi	r24, 0x8D	; 141
     fb0:	91 e4       	ldi	r25, 0x41	; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:147
    SERIALPORT.println(seed);
     fb2:	0b da       	rcall	.-3050   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     fb4:	ce 01       	movw	r24, r28
     fb6:	0d da       	rcall	.-3046   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_734():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_734.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     fb8:	20 97       	sbiw	r28, 0x00	; 0
     fba:	21 f0       	breq	.+8      	; 0xfc4 <setup+0xb68>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_734.cpp:13
    __xor16_734_state = seed;
     fbc:	c0 93 88 42 	sts	0x4288, r28	; 0x804288 <__xor16_734_state>
     fc0:	d0 93 89 42 	sts	0x4289, r29	; 0x804289 <__xor16_734_state+0x1>
xor16_734():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_734.cpp:49
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_734_state)::"r18","r19");
     fc4:	c0 91 88 42 	lds	r28, 0x4288	; 0x804288 <__xor16_734_state>
     fc8:	d0 91 89 42 	lds	r29, 0x4289	; 0x804289 <__xor16_734_state+0x1>
     fcc:	9e 01       	movw	r18, r28
     fce:	36 95       	lsr	r19
     fd0:	32 2f       	mov	r19, r18
     fd2:	22 27       	eor	r18, r18
     fd4:	37 95       	ror	r19
     fd6:	27 95       	ror	r18
     fd8:	c2 27       	eor	r28, r18
     fda:	d3 27       	eor	r29, r19
     fdc:	9e 01       	movw	r18, r28
     fde:	36 95       	lsr	r19
     fe0:	27 95       	ror	r18
     fe2:	36 95       	lsr	r19
     fe4:	27 95       	ror	r18
     fe6:	36 95       	lsr	r19
     fe8:	27 95       	ror	r18
     fea:	c2 27       	eor	r28, r18
     fec:	d3 27       	eor	r29, r19
     fee:	9e 01       	movw	r18, r28
     ff0:	22 0f       	add	r18, r18
     ff2:	33 1f       	adc	r19, r19
     ff4:	22 0f       	add	r18, r18
     ff6:	33 1f       	adc	r19, r19
     ff8:	22 0f       	add	r18, r18
     ffa:	33 1f       	adc	r19, r19
     ffc:	22 0f       	add	r18, r18
     ffe:	33 1f       	adc	r19, r19
    1000:	c2 27       	eor	r28, r18
    1002:	d3 27       	eor	r29, r19
    1004:	c0 93 88 42 	sts	0x4288, r28	; 0x804288 <__xor16_734_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:150
    seed_xor16_734(seed);
    seed = xor16_734();
    SERIALPORT.print("734: ");
    1008:	d0 93 89 42 	sts	0x4289, r29	; 0x804289 <__xor16_734_state+0x1>
setup():
    100c:	83 e9       	ldi	r24, 0x93	; 147
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:151
    SERIALPORT.println(seed);
    100e:	91 e4       	ldi	r25, 0x41	; 65
    1010:	dc d9       	rcall	.-3144   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    1012:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_798.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1014:	de d9       	rcall	.-3140   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_798():
    1016:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_798.cpp:13
    __xor16_798_state = seed;
    1018:	21 f0       	breq	.+8      	; 0x1022 <setup+0xbc6>
    101a:	c0 93 8a 42 	sts	0x428A, r28	; 0x80428a <__xor16_798_state>
    101e:	d0 93 8b 42 	sts	0x428B, r29	; 0x80428b <__xor16_798_state+0x1>
xor16_798():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_798.cpp:34
      "mov    r18, %B0"      "\n\t"
      "lsr    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_798_state)::"r18","r19");
    1022:	c0 91 8a 42 	lds	r28, 0x428A	; 0x80428a <__xor16_798_state>
    1026:	d0 91 8b 42 	lds	r29, 0x428B	; 0x80428b <__xor16_798_state+0x1>
    102a:	9e 01       	movw	r18, r28
    102c:	36 95       	lsr	r19
    102e:	32 2f       	mov	r19, r18
    1030:	22 27       	eor	r18, r18
    1032:	37 95       	ror	r19
    1034:	27 95       	ror	r18
    1036:	c2 27       	eor	r28, r18
    1038:	d3 27       	eor	r29, r19
    103a:	2d 2f       	mov	r18, r29
    103c:	26 95       	lsr	r18
    103e:	c2 27       	eor	r28, r18
    1040:	3c 2f       	mov	r19, r28
    1042:	d3 27       	eor	r29, r19
    1044:	c0 93 8a 42 	sts	0x428A, r28	; 0x80428a <__xor16_798_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:154
    seed_xor16_798(seed);
    seed = xor16_798();
    SERIALPORT.print("798: ");
    1048:	d0 93 8b 42 	sts	0x428B, r29	; 0x80428b <__xor16_798_state+0x1>
setup():
    104c:	89 e9       	ldi	r24, 0x99	; 153
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:155
    SERIALPORT.println(seed);
    104e:	91 e4       	ldi	r25, 0x41	; 65
    1050:	bc d9       	rcall	.-3208   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    1052:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_79d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1054:	be d9       	rcall	.-3204   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_79d():
    1056:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_79d.cpp:13
    __xor16_79d_state = seed;
    1058:	21 f0       	breq	.+8      	; 0x1062 <setup+0xc06>
    105a:	c0 93 8c 42 	sts	0x428C, r28	; 0x80428c <__xor16_79d_state>
    105e:	d0 93 8d 42 	sts	0x428D, r29	; 0x80428d <__xor16_79d_state+0x1>
xor16_79d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_79d.cpp:37
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_79d_state)::"r18","r19");
    1062:	c0 91 8c 42 	lds	r28, 0x428C	; 0x80428c <__xor16_79d_state>
    1066:	d0 91 8d 42 	lds	r29, 0x428D	; 0x80428d <__xor16_79d_state+0x1>
    106a:	9e 01       	movw	r18, r28
    106c:	36 95       	lsr	r19
    106e:	32 2f       	mov	r19, r18
    1070:	22 27       	eor	r18, r18
    1072:	37 95       	ror	r19
    1074:	27 95       	ror	r18
    1076:	c2 27       	eor	r28, r18
    1078:	d3 27       	eor	r29, r19
    107a:	2d 2f       	mov	r18, r29
    107c:	26 95       	lsr	r18
    107e:	c2 27       	eor	r28, r18
    1080:	3c 2f       	mov	r19, r28
    1082:	32 95       	swap	r19
    1084:	33 0f       	add	r19, r19
    1086:	30 7e       	andi	r19, 0xE0	; 224
    1088:	d3 27       	eor	r29, r19
    108a:	c0 93 8c 42 	sts	0x428C, r28	; 0x80428c <__xor16_79d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:158
    seed_xor16_79d(seed);
    seed = xor16_79d();
    SERIALPORT.print("79d: ");
    108e:	d0 93 8d 42 	sts	0x428D, r29	; 0x80428d <__xor16_79d_state+0x1>
setup():
    1092:	8f e9       	ldi	r24, 0x9F	; 159
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:159
    SERIALPORT.println(seed);
    1094:	91 e4       	ldi	r25, 0x41	; 65
    1096:	99 d9       	rcall	.-3278   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    1098:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_7f1.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    109a:	9b d9       	rcall	.-3274   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_7f1():
    109c:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_7f1.cpp:13
    __xor16_7f1_state = seed;
    109e:	21 f0       	breq	.+8      	; 0x10a8 <setup+0xc4c>
    10a0:	c0 93 8e 42 	sts	0x428E, r28	; 0x80428e <__xor16_7f1_state>
    10a4:	d0 93 8f 42 	sts	0x428F, r29	; 0x80428f <__xor16_7f1_state+0x1>
xor16_7f1():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_7f1.cpp:38
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_7f1_state)::"r18","r19");
    10a8:	c0 91 8e 42 	lds	r28, 0x428E	; 0x80428e <__xor16_7f1_state>
    10ac:	d0 91 8f 42 	lds	r29, 0x428F	; 0x80428f <__xor16_7f1_state+0x1>
    10b0:	9e 01       	movw	r18, r28
    10b2:	36 95       	lsr	r19
    10b4:	32 2f       	mov	r19, r18
    10b6:	22 27       	eor	r18, r18
    10b8:	37 95       	ror	r19
    10ba:	27 95       	ror	r18
    10bc:	c2 27       	eor	r28, r18
    10be:	d3 27       	eor	r29, r19
    10c0:	d7 fb       	bst	r29, 7
    10c2:	22 27       	eor	r18, r18
    10c4:	20 f9       	bld	r18, 0
    10c6:	c2 27       	eor	r28, r18
    10c8:	9e 01       	movw	r18, r28
    10ca:	22 0f       	add	r18, r18
    10cc:	33 1f       	adc	r19, r19
    10ce:	c2 27       	eor	r28, r18
    10d0:	d3 27       	eor	r29, r19
    10d2:	c0 93 8e 42 	sts	0x428E, r28	; 0x80428e <__xor16_7f1_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:162
    seed_xor16_7f1(seed);
    seed = xor16_7f1();
    SERIALPORT.print("7f1: ");
    10d6:	d0 93 8f 42 	sts	0x428F, r29	; 0x80428f <__xor16_7f1_state+0x1>
setup():
    10da:	85 ea       	ldi	r24, 0xA5	; 165
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:163
    SERIALPORT.println(seed);
    10dc:	91 e4       	ldi	r25, 0x41	; 65
    10de:	75 d9       	rcall	.-3350   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    10e0:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_895.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    10e2:	77 d9       	rcall	.-3346   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_895():
    10e4:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_895.cpp:13
    __xor16_895_state = seed;
    10e6:	21 f0       	breq	.+8      	; 0x10f0 <setup+0xc94>
    10e8:	c0 93 90 42 	sts	0x4290, r28	; 0x804290 <__xor16_895_state>
    10ec:	d0 93 91 42 	sts	0x4291, r29	; 0x804291 <__xor16_895_state+0x1>
xor16_895():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_895.cpp:39
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_895_state)::"r18","r19");
    10f0:	c0 91 90 42 	lds	r28, 0x4290	; 0x804290 <__xor16_895_state>
    10f4:	d0 91 91 42 	lds	r29, 0x4291	; 0x804291 <__xor16_895_state+0x1>
    10f8:	3c 2f       	mov	r19, r28
    10fa:	d3 27       	eor	r29, r19
    10fc:	2d 2f       	mov	r18, r29
    10fe:	26 95       	lsr	r18
    1100:	c2 27       	eor	r28, r18
    1102:	9e 01       	movw	r18, r28
    1104:	22 0f       	add	r18, r18
    1106:	33 1f       	adc	r19, r19
    1108:	22 0f       	add	r18, r18
    110a:	33 1f       	adc	r19, r19
    110c:	22 0f       	add	r18, r18
    110e:	33 1f       	adc	r19, r19
    1110:	22 0f       	add	r18, r18
    1112:	33 1f       	adc	r19, r19
    1114:	22 0f       	add	r18, r18
    1116:	33 1f       	adc	r19, r19
    1118:	c2 27       	eor	r28, r18
    111a:	d3 27       	eor	r29, r19
    111c:	c0 93 90 42 	sts	0x4290, r28	; 0x804290 <__xor16_895_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:166
    seed_xor16_895(seed);
    seed = xor16_895();
    SERIALPORT.print("895: ");
    1120:	d0 93 91 42 	sts	0x4291, r29	; 0x804291 <__xor16_895_state+0x1>
setup():
    1124:	8b ea       	ldi	r24, 0xAB	; 171
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:167
    SERIALPORT.println(seed);
    1126:	91 e4       	ldi	r25, 0x41	; 65
    1128:	50 d9       	rcall	.-3424   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    112a:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_897.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    112c:	52 d9       	rcall	.-3420   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_897():
    112e:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_897.cpp:13
    __xor16_897_state = seed;
    1130:	21 f0       	breq	.+8      	; 0x113a <setup+0xcde>
    1132:	c0 93 92 42 	sts	0x4292, r28	; 0x804292 <__xor16_897_state>
    1136:	d0 93 93 42 	sts	0x4293, r29	; 0x804293 <__xor16_897_state+0x1>
xor16_897():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_897.cpp:34
      "eor    r18, r18"      "\n\t"
      "ror    r19"           "\n\t"
      "ror    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_897_state)::"r18","r19");
    113a:	c0 91 92 42 	lds	r28, 0x4292	; 0x804292 <__xor16_897_state>
    113e:	d0 91 93 42 	lds	r29, 0x4293	; 0x804293 <__xor16_897_state+0x1>
    1142:	3c 2f       	mov	r19, r28
    1144:	d3 27       	eor	r29, r19
    1146:	2d 2f       	mov	r18, r29
    1148:	26 95       	lsr	r18
    114a:	c2 27       	eor	r28, r18
    114c:	9e 01       	movw	r18, r28
    114e:	36 95       	lsr	r19
    1150:	32 2f       	mov	r19, r18
    1152:	22 27       	eor	r18, r18
    1154:	37 95       	ror	r19
    1156:	27 95       	ror	r18
    1158:	c2 27       	eor	r28, r18
    115a:	d3 27       	eor	r29, r19
    115c:	c0 93 92 42 	sts	0x4292, r28	; 0x804292 <__xor16_897_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:170
    seed_xor16_897(seed);
    seed = xor16_897();
    SERIALPORT.print("897: ");
    1160:	d0 93 93 42 	sts	0x4293, r29	; 0x804293 <__xor16_897_state+0x1>
setup():
    1164:	81 eb       	ldi	r24, 0xB1	; 177
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:171
    SERIALPORT.println(seed);
    1166:	91 e4       	ldi	r25, 0x41	; 65
    1168:	30 d9       	rcall	.-3488   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    116a:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_97d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    116c:	32 d9       	rcall	.-3484   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_97d():
    116e:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_97d.cpp:13
    __xor16_97d_state = seed;
    1170:	21 f0       	breq	.+8      	; 0x117a <setup+0xd1e>
    1172:	c0 93 94 42 	sts	0x4294, r28	; 0x804294 <__xor16_97d_state>
    1176:	d0 93 95 42 	sts	0x4295, r29	; 0x804295 <__xor16_97d_state+0x1>
xor16_97d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_97d.cpp:37
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_97d_state)::"r18","r19");
    117a:	c0 91 94 42 	lds	r28, 0x4294	; 0x804294 <__xor16_97d_state>
    117e:	d0 91 95 42 	lds	r29, 0x4295	; 0x804295 <__xor16_97d_state+0x1>
    1182:	3c 2f       	mov	r19, r28
    1184:	33 0f       	add	r19, r19
    1186:	d3 27       	eor	r29, r19
    1188:	9e 01       	movw	r18, r28
    118a:	22 0f       	add	r18, r18
    118c:	23 2f       	mov	r18, r19
    118e:	22 1f       	adc	r18, r18
    1190:	33 0b       	sbc	r19, r19
    1192:	31 95       	neg	r19
    1194:	c2 27       	eor	r28, r18
    1196:	d3 27       	eor	r29, r19
    1198:	3c 2f       	mov	r19, r28
    119a:	32 95       	swap	r19
    119c:	33 0f       	add	r19, r19
    119e:	30 7e       	andi	r19, 0xE0	; 224
    11a0:	d3 27       	eor	r29, r19
    11a2:	c0 93 94 42 	sts	0x4294, r28	; 0x804294 <__xor16_97d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:174
    seed_xor16_97d(seed);
    seed = xor16_97d();
    SERIALPORT.print("97d: ");
    11a6:	d0 93 95 42 	sts	0x4295, r29	; 0x804295 <__xor16_97d_state+0x1>
setup():
    11aa:	87 eb       	ldi	r24, 0xB7	; 183
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:175
    SERIALPORT.println(seed);
    11ac:	91 e4       	ldi	r25, 0x41	; 65
    11ae:	0d d9       	rcall	.-3558   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    11b0:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_9d3.cpp:13
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    11b2:	0f d9       	rcall	.-3554   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_9d3():
    11b4:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_9d3.cpp:14
    __xor16_9d3_state = seed;
    11b6:	21 f0       	breq	.+8      	; 0x11c0 <setup+0xd64>
    11b8:	c0 93 96 42 	sts	0x4296, r28	; 0x804296 <__xor16_9d3_state>
    11bc:	d0 93 97 42 	sts	0x4297, r29	; 0x804297 <__xor16_9d3_state+0x1>
xor16_9d3():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_9d3.cpp:39
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_9d3_state)::"r18","r19");
    11c0:	c0 91 96 42 	lds	r28, 0x4296	; 0x804296 <__xor16_9d3_state>
    11c4:	d0 91 97 42 	lds	r29, 0x4297	; 0x804297 <__xor16_9d3_state+0x1>
    11c8:	3c 2f       	mov	r19, r28
    11ca:	33 0f       	add	r19, r19
    11cc:	d3 27       	eor	r29, r19
    11ce:	2d 2f       	mov	r18, r29
    11d0:	22 95       	swap	r18
    11d2:	26 95       	lsr	r18
    11d4:	27 70       	andi	r18, 0x07	; 7
    11d6:	c2 27       	eor	r28, r18
    11d8:	9e 01       	movw	r18, r28
    11da:	22 0f       	add	r18, r18
    11dc:	33 1f       	adc	r19, r19
    11de:	22 0f       	add	r18, r18
    11e0:	33 1f       	adc	r19, r19
    11e2:	22 0f       	add	r18, r18
    11e4:	33 1f       	adc	r19, r19
    11e6:	c2 27       	eor	r28, r18
    11e8:	d3 27       	eor	r29, r19
    11ea:	c0 93 96 42 	sts	0x4296, r28	; 0x804296 <__xor16_9d3_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:178
    seed_xor16_9d3(seed);
    seed = xor16_9d3();
    SERIALPORT.print("9d3: ");
    11ee:	d0 93 97 42 	sts	0x4297, r29	; 0x804297 <__xor16_9d3_state+0x1>
setup():
    11f2:	8d eb       	ldi	r24, 0xBD	; 189
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:179
    SERIALPORT.println(seed);
    11f4:	91 e4       	ldi	r25, 0x41	; 65
    11f6:	e9 d8       	rcall	.-3630   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    11f8:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b17.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    11fa:	eb d8       	rcall	.-3626   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_b17():
    11fc:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b17.cpp:13
    __xor16_b17_state = seed;
    11fe:	21 f0       	breq	.+8      	; 0x1208 <setup+0xdac>
    1200:	c0 93 98 42 	sts	0x4298, r28	; 0x804298 <__xor16_b17_state>
    1204:	d0 93 99 42 	sts	0x4299, r29	; 0x804299 <__xor16_b17_state+0x1>
xor16_b17():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b17.cpp:39
      "eor    r18, r18"      "\n\t"
      "ror    r19"           "\n\t"
      "ror    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_b17_state)::"r18","r19");
    1208:	c0 91 98 42 	lds	r28, 0x4298	; 0x804298 <__xor16_b17_state>
    120c:	d0 91 99 42 	lds	r29, 0x4299	; 0x804299 <__xor16_b17_state+0x1>
    1210:	3c 2f       	mov	r19, r28
    1212:	33 0f       	add	r19, r19
    1214:	33 0f       	add	r19, r19
    1216:	33 0f       	add	r19, r19
    1218:	d3 27       	eor	r29, r19
    121a:	9e 01       	movw	r18, r28
    121c:	36 95       	lsr	r19
    121e:	27 95       	ror	r18
    1220:	c2 27       	eor	r28, r18
    1222:	d3 27       	eor	r29, r19
    1224:	9e 01       	movw	r18, r28
    1226:	36 95       	lsr	r19
    1228:	32 2f       	mov	r19, r18
    122a:	22 27       	eor	r18, r18
    122c:	37 95       	ror	r19
    122e:	27 95       	ror	r18
    1230:	c2 27       	eor	r28, r18
    1232:	d3 27       	eor	r29, r19
    1234:	c0 93 98 42 	sts	0x4298, r28	; 0x804298 <__xor16_b17_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:182
    seed_xor16_b17(seed);
    seed = xor16_b17();
    SERIALPORT.print("b17: ");
    1238:	d0 93 99 42 	sts	0x4299, r29	; 0x804299 <__xor16_b17_state+0x1>
setup():
    123c:	83 ec       	ldi	r24, 0xC3	; 195
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:183
    SERIALPORT.println(seed);
    123e:	91 e4       	ldi	r25, 0x41	; 65
    1240:	c4 d8       	rcall	.-3704   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    1242:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b3d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1244:	c6 d8       	rcall	.-3700   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_b3d():
    1246:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b3d.cpp:13
    __xor16_b3d_state = seed;
    1248:	21 f0       	breq	.+8      	; 0x1252 <setup+0xdf6>
    124a:	c0 93 9a 42 	sts	0x429A, r28	; 0x80429a <__xor16_b3d_state>
    124e:	d0 93 9b 42 	sts	0x429B, r29	; 0x80429b <__xor16_b3d_state+0x1>
xor16_b3d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b3d.cpp:40
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_b3d_state)::"r18","r19");
    1252:	c0 91 9a 42 	lds	r28, 0x429A	; 0x80429a <__xor16_b3d_state>
    1256:	d0 91 9b 42 	lds	r29, 0x429B	; 0x80429b <__xor16_b3d_state+0x1>
    125a:	3c 2f       	mov	r19, r28
    125c:	33 0f       	add	r19, r19
    125e:	33 0f       	add	r19, r19
    1260:	33 0f       	add	r19, r19
    1262:	d3 27       	eor	r29, r19
    1264:	9e 01       	movw	r18, r28
    1266:	36 95       	lsr	r19
    1268:	27 95       	ror	r18
    126a:	36 95       	lsr	r19
    126c:	27 95       	ror	r18
    126e:	36 95       	lsr	r19
    1270:	27 95       	ror	r18
    1272:	c2 27       	eor	r28, r18
    1274:	d3 27       	eor	r29, r19
    1276:	3c 2f       	mov	r19, r28
    1278:	32 95       	swap	r19
    127a:	33 0f       	add	r19, r19
    127c:	30 7e       	andi	r19, 0xE0	; 224
    127e:	d3 27       	eor	r29, r19
    1280:	c0 93 9a 42 	sts	0x429A, r28	; 0x80429a <__xor16_b3d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:186
    seed_xor16_b3d(seed);
    seed = xor16_b3d();
    SERIALPORT.print("b3d: ");
    1284:	d0 93 9b 42 	sts	0x429B, r29	; 0x80429b <__xor16_b3d_state+0x1>
setup():
    1288:	89 ec       	ldi	r24, 0xC9	; 201
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:187
    SERIALPORT.println(seed);
    128a:	91 e4       	ldi	r25, 0x41	; 65
    128c:	9e d8       	rcall	.-3780   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    128e:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b53.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1290:	a0 d8       	rcall	.-3776   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_b53():
    1292:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b53.cpp:13
    __xor16_b53_state = seed;
    1294:	21 f0       	breq	.+8      	; 0x129e <setup+0xe42>
    1296:	c0 93 9c 42 	sts	0x429C, r28	; 0x80429c <__xor16_b53_state>
    129a:	d0 93 9d 42 	sts	0x429D, r29	; 0x80429d <__xor16_b53_state+0x1>
xor16_b53():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b53.cpp:48
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_b53_state)::"r18","r19");
    129e:	c0 91 9c 42 	lds	r28, 0x429C	; 0x80429c <__xor16_b53_state>
    12a2:	d0 91 9d 42 	lds	r29, 0x429D	; 0x80429d <__xor16_b53_state+0x1>
    12a6:	3c 2f       	mov	r19, r28
    12a8:	33 0f       	add	r19, r19
    12aa:	33 0f       	add	r19, r19
    12ac:	33 0f       	add	r19, r19
    12ae:	d3 27       	eor	r29, r19
    12b0:	9e 01       	movw	r18, r28
    12b2:	36 95       	lsr	r19
    12b4:	27 95       	ror	r18
    12b6:	36 95       	lsr	r19
    12b8:	27 95       	ror	r18
    12ba:	36 95       	lsr	r19
    12bc:	27 95       	ror	r18
    12be:	36 95       	lsr	r19
    12c0:	27 95       	ror	r18
    12c2:	36 95       	lsr	r19
    12c4:	27 95       	ror	r18
    12c6:	c2 27       	eor	r28, r18
    12c8:	d3 27       	eor	r29, r19
    12ca:	9e 01       	movw	r18, r28
    12cc:	22 0f       	add	r18, r18
    12ce:	33 1f       	adc	r19, r19
    12d0:	22 0f       	add	r18, r18
    12d2:	33 1f       	adc	r19, r19
    12d4:	22 0f       	add	r18, r18
    12d6:	33 1f       	adc	r19, r19
    12d8:	c2 27       	eor	r28, r18
    12da:	d3 27       	eor	r29, r19
    12dc:	c0 93 9c 42 	sts	0x429C, r28	; 0x80429c <__xor16_b53_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:190
    seed_xor16_b53(seed);
    seed = xor16_b53();
    SERIALPORT.print("b53: ");
    12e0:	d0 93 9d 42 	sts	0x429D, r29	; 0x80429d <__xor16_b53_state+0x1>
setup():
    12e4:	8f ec       	ldi	r24, 0xCF	; 207
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:191
    SERIALPORT.println(seed);
    12e6:	91 e4       	ldi	r25, 0x41	; 65
    12e8:	70 d8       	rcall	.-3872   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    12ea:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b71.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    12ec:	72 d8       	rcall	.-3868   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_b71():
    12ee:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b71.cpp:13
    __xor16_b71_state = seed;
    12f0:	21 f0       	breq	.+8      	; 0x12fa <setup+0xe9e>
    12f2:	c0 93 9e 42 	sts	0x429E, r28	; 0x80429e <__xor16_b71_state>
    12f6:	d0 93 9f 42 	sts	0x429F, r29	; 0x80429f <__xor16_b71_state+0x1>
xor16_b71():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b71.cpp:39
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_b71_state)::"r18","r19");
    12fa:	c0 91 9e 42 	lds	r28, 0x429E	; 0x80429e <__xor16_b71_state>
    12fe:	d0 91 9f 42 	lds	r29, 0x429F	; 0x80429f <__xor16_b71_state+0x1>
    1302:	3c 2f       	mov	r19, r28
    1304:	33 0f       	add	r19, r19
    1306:	33 0f       	add	r19, r19
    1308:	33 0f       	add	r19, r19
    130a:	d3 27       	eor	r29, r19
    130c:	9e 01       	movw	r18, r28
    130e:	22 0f       	add	r18, r18
    1310:	23 2f       	mov	r18, r19
    1312:	22 1f       	adc	r18, r18
    1314:	33 0b       	sbc	r19, r19
    1316:	31 95       	neg	r19
    1318:	c2 27       	eor	r28, r18
    131a:	d3 27       	eor	r29, r19
    131c:	9e 01       	movw	r18, r28
    131e:	22 0f       	add	r18, r18
    1320:	33 1f       	adc	r19, r19
    1322:	c2 27       	eor	r28, r18
    1324:	d3 27       	eor	r29, r19
    1326:	c0 93 9e 42 	sts	0x429E, r28	; 0x80429e <__xor16_b71_state>
    132a:	d0 93 9f 42 	sts	0x429F, r29	; 0x80429f <__xor16_b71_state+0x1>
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:194
    seed_xor16_b71(seed);
    seed = xor16_b71();
    SERIALPORT.print("b71: ");
    132e:	85 ed       	ldi	r24, 0xD5	; 213
    1330:	91 e4       	ldi	r25, 0x41	; 65
    1332:	4b d8       	rcall	.-3946   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:195
    SERIALPORT.println(seed);
    1334:	ce 01       	movw	r24, r28
    1336:	4d d8       	rcall	.-3942   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_bb3():
    1338:	20 97       	sbiw	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb3.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    133a:	21 f0       	breq	.+8      	; 0x1344 <setup+0xee8>
    133c:	c0 93 a0 42 	sts	0x42A0, r28	; 0x8042a0 <__xor16_bb3_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb3.cpp:13
    __xor16_bb3_state = seed;
    1340:	d0 93 a1 42 	sts	0x42A1, r29	; 0x8042a1 <__xor16_bb3_state+0x1>
xor16_bb3():
    1344:	c0 91 a0 42 	lds	r28, 0x42A0	; 0x8042a0 <__xor16_bb3_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb3.cpp:40
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_bb3_state)::"r18","r19");
    1348:	d0 91 a1 42 	lds	r29, 0x42A1	; 0x8042a1 <__xor16_bb3_state+0x1>
    134c:	3c 2f       	mov	r19, r28
    134e:	33 0f       	add	r19, r19
    1350:	33 0f       	add	r19, r19
    1352:	33 0f       	add	r19, r19
    1354:	d3 27       	eor	r29, r19
    1356:	2d 2f       	mov	r18, r29
    1358:	26 95       	lsr	r18
    135a:	26 95       	lsr	r18
    135c:	26 95       	lsr	r18
    135e:	c2 27       	eor	r28, r18
    1360:	9e 01       	movw	r18, r28
    1362:	22 0f       	add	r18, r18
    1364:	33 1f       	adc	r19, r19
    1366:	22 0f       	add	r18, r18
    1368:	33 1f       	adc	r19, r19
    136a:	22 0f       	add	r18, r18
    136c:	33 1f       	adc	r19, r19
    136e:	c2 27       	eor	r28, r18
    1370:	d3 27       	eor	r29, r19
    1372:	c0 93 a0 42 	sts	0x42A0, r28	; 0x8042a0 <__xor16_bb3_state>
    1376:	d0 93 a1 42 	sts	0x42A1, r29	; 0x8042a1 <__xor16_bb3_state+0x1>
setup():
    137a:	8b ed       	ldi	r24, 0xDB	; 219
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:198
    seed_xor16_bb3(seed);
    seed = xor16_bb3();
    SERIALPORT.print("bb3: ");
    137c:	91 e4       	ldi	r25, 0x41	; 65
    137e:	25 d8       	rcall	.-4022   	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    1380:	ce 01       	movw	r24, r28
    1382:	27 d8       	rcall	.-4018   	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_bb4():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:199
    SERIALPORT.println(seed);
    1384:	20 97       	sbiw	r28, 0x00	; 0
    1386:	21 f0       	breq	.+8      	; 0x1390 <setup+0xf34>
    1388:	c0 93 a2 42 	sts	0x42A2, r28	; 0x8042a2 <__xor16_bb4_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb4.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    138c:	d0 93 a3 42 	sts	0x42A3, r29	; 0x8042a3 <__xor16_bb4_state+0x1>
xor16_bb4():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb4.cpp:13
    __xor16_bb4_state = seed;
    1390:	c0 91 a2 42 	lds	r28, 0x42A2	; 0x8042a2 <__xor16_bb4_state>
    1394:	d0 91 a3 42 	lds	r29, 0x42A3	; 0x8042a3 <__xor16_bb4_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb4.cpp:42
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_bb4_state)::"r18","r19");
    1398:	3c 2f       	mov	r19, r28
    139a:	33 0f       	add	r19, r19
    139c:	33 0f       	add	r19, r19
    139e:	33 0f       	add	r19, r19
    13a0:	d3 27       	eor	r29, r19
    13a2:	2d 2f       	mov	r18, r29
    13a4:	26 95       	lsr	r18
    13a6:	26 95       	lsr	r18
    13a8:	26 95       	lsr	r18
    13aa:	c2 27       	eor	r28, r18
    13ac:	9e 01       	movw	r18, r28
    13ae:	22 0f       	add	r18, r18
    13b0:	33 1f       	adc	r19, r19
    13b2:	22 0f       	add	r18, r18
    13b4:	33 1f       	adc	r19, r19
    13b6:	22 0f       	add	r18, r18
    13b8:	33 1f       	adc	r19, r19
    13ba:	22 0f       	add	r18, r18
    13bc:	33 1f       	adc	r19, r19
    13be:	c2 27       	eor	r28, r18
    13c0:	d3 27       	eor	r29, r19
    13c2:	c0 93 a2 42 	sts	0x42A2, r28	; 0x8042a2 <__xor16_bb4_state>
    13c6:	d0 93 a3 42 	sts	0x42A3, r29	; 0x8042a3 <__xor16_bb4_state+0x1>
setup():
    13ca:	81 ee       	ldi	r24, 0xE1	; 225
    13cc:	91 e4       	ldi	r25, 0x41	; 65
    13ce:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:202
    seed_xor16_bb4(seed);
    seed = xor16_bb4();
    SERIALPORT.print("bb4: ");
    13d2:	ce 01       	movw	r24, r28
    13d4:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_bb5():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:203
    SERIALPORT.println(seed);
    13d8:	20 97       	sbiw	r28, 0x00	; 0
    13da:	21 f0       	breq	.+8      	; 0x13e4 <setup+0xf88>
    13dc:	c0 93 a4 42 	sts	0x42A4, r28	; 0x8042a4 <__xor16_bb5_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb5.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    13e0:	d0 93 a5 42 	sts	0x42A5, r29	; 0x8042a5 <__xor16_bb5_state+0x1>
xor16_bb5():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb5.cpp:13
    __xor16_bb5_state = seed;
    13e4:	c0 91 a4 42 	lds	r28, 0x42A4	; 0x8042a4 <__xor16_bb5_state>
    13e8:	d0 91 a5 42 	lds	r29, 0x42A5	; 0x8042a5 <__xor16_bb5_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb5.cpp:44
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_bb5_state)::"r18","r19");
    13ec:	3c 2f       	mov	r19, r28
    13ee:	33 0f       	add	r19, r19
    13f0:	33 0f       	add	r19, r19
    13f2:	33 0f       	add	r19, r19
    13f4:	d3 27       	eor	r29, r19
    13f6:	2d 2f       	mov	r18, r29
    13f8:	26 95       	lsr	r18
    13fa:	26 95       	lsr	r18
    13fc:	26 95       	lsr	r18
    13fe:	c2 27       	eor	r28, r18
    1400:	9e 01       	movw	r18, r28
    1402:	22 0f       	add	r18, r18
    1404:	33 1f       	adc	r19, r19
    1406:	22 0f       	add	r18, r18
    1408:	33 1f       	adc	r19, r19
    140a:	22 0f       	add	r18, r18
    140c:	33 1f       	adc	r19, r19
    140e:	22 0f       	add	r18, r18
    1410:	33 1f       	adc	r19, r19
    1412:	22 0f       	add	r18, r18
    1414:	33 1f       	adc	r19, r19
    1416:	c2 27       	eor	r28, r18
    1418:	d3 27       	eor	r29, r19
    141a:	c0 93 a4 42 	sts	0x42A4, r28	; 0x8042a4 <__xor16_bb5_state>
    141e:	d0 93 a5 42 	sts	0x42A5, r29	; 0x8042a5 <__xor16_bb5_state+0x1>
setup():
    1422:	87 ee       	ldi	r24, 0xE7	; 231
    1424:	91 e4       	ldi	r25, 0x41	; 65
    1426:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:206
    seed_xor16_bb5(seed);
    seed = xor16_bb5();
    SERIALPORT.print("bb5: ");
    142a:	ce 01       	movw	r24, r28
    142c:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_c13():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:207
    SERIALPORT.println(seed);
    1430:	20 97       	sbiw	r28, 0x00	; 0
    1432:	21 f0       	breq	.+8      	; 0x143c <setup+0xfe0>
    1434:	c0 93 a6 42 	sts	0x42A6, r28	; 0x8042a6 <__xor16_c13_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c13.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1438:	d0 93 a7 42 	sts	0x42A7, r29	; 0x8042a7 <__xor16_c13_state+0x1>
xor16_c13():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c13.cpp:13
    __xor16_c13_state = seed;
    143c:	c0 91 a6 42 	lds	r28, 0x42A6	; 0x8042a6 <__xor16_c13_state>
    1440:	d0 91 a7 42 	lds	r29, 0x42A7	; 0x8042a7 <__xor16_c13_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c13.cpp:39
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_c13_state)::"r18","r19");
    1444:	3c 2f       	mov	r19, r28
    1446:	32 95       	swap	r19
    1448:	30 7f       	andi	r19, 0xF0	; 240
    144a:	d3 27       	eor	r29, r19
    144c:	9e 01       	movw	r18, r28
    144e:	36 95       	lsr	r19
    1450:	27 95       	ror	r18
    1452:	c2 27       	eor	r28, r18
    1454:	d3 27       	eor	r29, r19
    1456:	9e 01       	movw	r18, r28
    1458:	22 0f       	add	r18, r18
    145a:	33 1f       	adc	r19, r19
    145c:	22 0f       	add	r18, r18
    145e:	33 1f       	adc	r19, r19
    1460:	22 0f       	add	r18, r18
    1462:	33 1f       	adc	r19, r19
    1464:	c2 27       	eor	r28, r18
    1466:	d3 27       	eor	r29, r19
    1468:	c0 93 a6 42 	sts	0x42A6, r28	; 0x8042a6 <__xor16_c13_state>
    146c:	d0 93 a7 42 	sts	0x42A7, r29	; 0x8042a7 <__xor16_c13_state+0x1>
setup():
    1470:	8d ee       	ldi	r24, 0xED	; 237
    1472:	91 e4       	ldi	r25, 0x41	; 65
    1474:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:210
    seed_xor16_c13(seed);
    seed = xor16_c13();
    SERIALPORT.print("c13: ");
    1478:	ce 01       	movw	r24, r28
    147a:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d3b():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:211
    SERIALPORT.println(seed);
    147e:	20 97       	sbiw	r28, 0x00	; 0
    1480:	21 f0       	breq	.+8      	; 0x148a <setup+0x102e>
    1482:	c0 93 a8 42 	sts	0x42A8, r28	; 0x8042a8 <__xor16_d3b_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3b.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1486:	d0 93 a9 42 	sts	0x42A9, r29	; 0x8042a9 <__xor16_d3b_state+0x1>
xor16_d3b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3b.cpp:13
    __xor16_d3b_state = seed;
    148a:	c0 91 a8 42 	lds	r28, 0x42A8	; 0x8042a8 <__xor16_d3b_state>
    148e:	d0 91 a9 42 	lds	r29, 0x42A9	; 0x8042a9 <__xor16_d3b_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3b.cpp:40
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d3b_state)::"r18","r19");
    1492:	3c 2f       	mov	r19, r28
    1494:	32 95       	swap	r19
    1496:	33 0f       	add	r19, r19
    1498:	30 7e       	andi	r19, 0xE0	; 224
    149a:	d3 27       	eor	r29, r19
    149c:	9e 01       	movw	r18, r28
    149e:	36 95       	lsr	r19
    14a0:	27 95       	ror	r18
    14a2:	36 95       	lsr	r19
    14a4:	27 95       	ror	r18
    14a6:	36 95       	lsr	r19
    14a8:	27 95       	ror	r18
    14aa:	c2 27       	eor	r28, r18
    14ac:	d3 27       	eor	r29, r19
    14ae:	3c 2f       	mov	r19, r28
    14b0:	33 0f       	add	r19, r19
    14b2:	33 0f       	add	r19, r19
    14b4:	33 0f       	add	r19, r19
    14b6:	d3 27       	eor	r29, r19
    14b8:	c0 93 a8 42 	sts	0x42A8, r28	; 0x8042a8 <__xor16_d3b_state>
    14bc:	d0 93 a9 42 	sts	0x42A9, r29	; 0x8042a9 <__xor16_d3b_state+0x1>
setup():
    14c0:	83 ef       	ldi	r24, 0xF3	; 243
    14c2:	91 e4       	ldi	r25, 0x41	; 65
    14c4:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:214
    seed_xor16_d3b(seed);
    seed = xor16_d3b();
    SERIALPORT.print("d3b: ");
    14c8:	ce 01       	movw	r24, r28
    14ca:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_c3d():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:215
    SERIALPORT.println(seed);
    14ce:	20 97       	sbiw	r28, 0x00	; 0
    14d0:	21 f0       	breq	.+8      	; 0x14da <setup+0x107e>
    14d2:	c0 93 aa 42 	sts	0x42AA, r28	; 0x8042aa <__xor16_c3d_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c3d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    14d6:	d0 93 ab 42 	sts	0x42AB, r29	; 0x8042ab <__xor16_c3d_state+0x1>
xor16_c3d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c3d.cpp:13
    __xor16_c3d_state = seed;
    14da:	c0 91 aa 42 	lds	r28, 0x42AA	; 0x8042aa <__xor16_c3d_state>
    14de:	d0 91 ab 42 	lds	r29, 0x42AB	; 0x8042ab <__xor16_c3d_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c3d.cpp:39
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_c3d_state)::"r18","r19");
    14e2:	3c 2f       	mov	r19, r28
    14e4:	32 95       	swap	r19
    14e6:	30 7f       	andi	r19, 0xF0	; 240
    14e8:	d3 27       	eor	r29, r19
    14ea:	9e 01       	movw	r18, r28
    14ec:	36 95       	lsr	r19
    14ee:	27 95       	ror	r18
    14f0:	36 95       	lsr	r19
    14f2:	27 95       	ror	r18
    14f4:	36 95       	lsr	r19
    14f6:	27 95       	ror	r18
    14f8:	c2 27       	eor	r28, r18
    14fa:	d3 27       	eor	r29, r19
    14fc:	3c 2f       	mov	r19, r28
    14fe:	32 95       	swap	r19
    1500:	33 0f       	add	r19, r19
    1502:	30 7e       	andi	r19, 0xE0	; 224
    1504:	d3 27       	eor	r29, r19
    1506:	c0 93 aa 42 	sts	0x42AA, r28	; 0x8042aa <__xor16_c3d_state>
    150a:	d0 93 ab 42 	sts	0x42AB, r29	; 0x8042ab <__xor16_c3d_state+0x1>
setup():
    150e:	89 ef       	ldi	r24, 0xF9	; 249
    1510:	91 e4       	ldi	r25, 0x41	; 65
    1512:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:218
    seed_xor16_c3d(seed);
    seed = xor16_c3d();
    SERIALPORT.print("c3d: ");
    1516:	ce 01       	movw	r24, r28
    1518:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d3c():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:219
    SERIALPORT.println(seed);
    151c:	20 97       	sbiw	r28, 0x00	; 0
    151e:	21 f0       	breq	.+8      	; 0x1528 <setup+0x10cc>
    1520:	c0 93 ac 42 	sts	0x42AC, r28	; 0x8042ac <__xor16_d3c_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3c.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1524:	d0 93 ad 42 	sts	0x42AD, r29	; 0x8042ad <__xor16_d3c_state+0x1>
xor16_d3c():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3c.cpp:13
    __xor16_d3c_state = seed;
    1528:	c0 91 ac 42 	lds	r28, 0x42AC	; 0x8042ac <__xor16_d3c_state>
    152c:	d0 91 ad 42 	lds	r29, 0x42AD	; 0x8042ad <__xor16_d3c_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3c.cpp:39
      "eor    %B0, r19"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "andi   r19, 0xF0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d3c_state)::"r18","r19");
    1530:	3c 2f       	mov	r19, r28
    1532:	32 95       	swap	r19
    1534:	33 0f       	add	r19, r19
    1536:	30 7e       	andi	r19, 0xE0	; 224
    1538:	d3 27       	eor	r29, r19
    153a:	9e 01       	movw	r18, r28
    153c:	36 95       	lsr	r19
    153e:	27 95       	ror	r18
    1540:	36 95       	lsr	r19
    1542:	27 95       	ror	r18
    1544:	36 95       	lsr	r19
    1546:	27 95       	ror	r18
    1548:	c2 27       	eor	r28, r18
    154a:	d3 27       	eor	r29, r19
    154c:	3c 2f       	mov	r19, r28
    154e:	32 95       	swap	r19
    1550:	30 7f       	andi	r19, 0xF0	; 240
    1552:	d3 27       	eor	r29, r19
    1554:	c0 93 ac 42 	sts	0x42AC, r28	; 0x8042ac <__xor16_d3c_state>
    1558:	d0 93 ad 42 	sts	0x42AD, r29	; 0x8042ad <__xor16_d3c_state+0x1>
setup():
    155c:	8f ef       	ldi	r24, 0xFF	; 255
    155e:	91 e4       	ldi	r25, 0x41	; 65
    1560:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:222
    seed_xor16_d3c(seed);
    seed = xor16_d3c();
    SERIALPORT.print("d3c: ");
    1564:	ce 01       	movw	r24, r28
    1566:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d52():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:223
    SERIALPORT.println(seed);
    156a:	20 97       	sbiw	r28, 0x00	; 0
    156c:	21 f0       	breq	.+8      	; 0x1576 <setup+0x111a>
    156e:	c0 93 ae 42 	sts	0x42AE, r28	; 0x8042ae <__xor16_d52_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d52.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1572:	d0 93 af 42 	sts	0x42AF, r29	; 0x8042af <__xor16_d52_state+0x1>
xor16_d52():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d52.cpp:13
    __xor16_d52_state = seed;
    1576:	c0 91 ae 42 	lds	r28, 0x42AE	; 0x8042ae <__xor16_d52_state>
    157a:	d0 91 af 42 	lds	r29, 0x42AF	; 0x8042af <__xor16_d52_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d52.cpp:46
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d52_state)::"r18","r19");
    157e:	3c 2f       	mov	r19, r28
    1580:	32 95       	swap	r19
    1582:	33 0f       	add	r19, r19
    1584:	30 7e       	andi	r19, 0xE0	; 224
    1586:	d3 27       	eor	r29, r19
    1588:	9e 01       	movw	r18, r28
    158a:	36 95       	lsr	r19
    158c:	27 95       	ror	r18
    158e:	36 95       	lsr	r19
    1590:	27 95       	ror	r18
    1592:	36 95       	lsr	r19
    1594:	27 95       	ror	r18
    1596:	36 95       	lsr	r19
    1598:	27 95       	ror	r18
    159a:	36 95       	lsr	r19
    159c:	27 95       	ror	r18
    159e:	c2 27       	eor	r28, r18
    15a0:	d3 27       	eor	r29, r19
    15a2:	9e 01       	movw	r18, r28
    15a4:	22 0f       	add	r18, r18
    15a6:	33 1f       	adc	r19, r19
    15a8:	22 0f       	add	r18, r18
    15aa:	33 1f       	adc	r19, r19
    15ac:	c2 27       	eor	r28, r18
    15ae:	d3 27       	eor	r29, r19
    15b0:	c0 93 ae 42 	sts	0x42AE, r28	; 0x8042ae <__xor16_d52_state>
    15b4:	d0 93 af 42 	sts	0x42AF, r29	; 0x8042af <__xor16_d52_state+0x1>
setup():
    15b8:	85 e0       	ldi	r24, 0x05	; 5
    15ba:	92 e4       	ldi	r25, 0x42	; 66
    15bc:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:226
    seed_xor16_d52(seed);
    seed = xor16_d52();
    SERIALPORT.print("d52: ");
    15c0:	ce 01       	movw	r24, r28
    15c2:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d72():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:227
    SERIALPORT.println(seed);
    15c6:	20 97       	sbiw	r28, 0x00	; 0
    15c8:	21 f0       	breq	.+8      	; 0x15d2 <setup+0x1176>
    15ca:	c0 93 b0 42 	sts	0x42B0, r28	; 0x8042b0 <__xor16_d72_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d72.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    15ce:	d0 93 b1 42 	sts	0x42B1, r29	; 0x8042b1 <__xor16_d72_state+0x1>
xor16_d72():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d72.cpp:13
    __xor16_d72_state = seed;
    15d2:	c0 91 b0 42 	lds	r28, 0x42B0	; 0x8042b0 <__xor16_d72_state>
    15d6:	d0 91 b1 42 	lds	r29, 0x42B1	; 0x8042b1 <__xor16_d72_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d72.cpp:41
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d72_state)::"r18","r19");
    15da:	3c 2f       	mov	r19, r28
    15dc:	32 95       	swap	r19
    15de:	33 0f       	add	r19, r19
    15e0:	30 7e       	andi	r19, 0xE0	; 224
    15e2:	d3 27       	eor	r29, r19
    15e4:	9e 01       	movw	r18, r28
    15e6:	22 0f       	add	r18, r18
    15e8:	23 2f       	mov	r18, r19
    15ea:	22 1f       	adc	r18, r18
    15ec:	33 0b       	sbc	r19, r19
    15ee:	31 95       	neg	r19
    15f0:	c2 27       	eor	r28, r18
    15f2:	d3 27       	eor	r29, r19
    15f4:	9e 01       	movw	r18, r28
    15f6:	22 0f       	add	r18, r18
    15f8:	33 1f       	adc	r19, r19
    15fa:	22 0f       	add	r18, r18
    15fc:	33 1f       	adc	r19, r19
    15fe:	c2 27       	eor	r28, r18
    1600:	d3 27       	eor	r29, r19
    1602:	c0 93 b0 42 	sts	0x42B0, r28	; 0x8042b0 <__xor16_d72_state>
    1606:	d0 93 b1 42 	sts	0x42B1, r29	; 0x8042b1 <__xor16_d72_state+0x1>
setup():
    160a:	8b e0       	ldi	r24, 0x0B	; 11
    160c:	92 e4       	ldi	r25, 0x42	; 66
    160e:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:230
    seed_xor16_d72(seed);
    seed = xor16_d72();
    SERIALPORT.print("d72: ");
    1612:	ce 01       	movw	r24, r28
    1614:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d76():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:231
    SERIALPORT.println(seed);
    1618:	20 97       	sbiw	r28, 0x00	; 0
    161a:	21 f0       	breq	.+8      	; 0x1624 <setup+0x11c8>
    161c:	c0 93 b2 42 	sts	0x42B2, r28	; 0x8042b2 <__xor16_d76_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d76.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1620:	d0 93 b3 42 	sts	0x42B3, r29	; 0x8042b3 <__xor16_d76_state+0x1>
xor16_d76():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d76.cpp:13
    __xor16_d76_state = seed;
    1624:	c0 91 b2 42 	lds	r28, 0x42B2	; 0x8042b2 <__xor16_d76_state>
    1628:	d0 91 b3 42 	lds	r29, 0x42B3	; 0x8042b3 <__xor16_d76_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d76.cpp:49
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d76_state)::"r18","r19");
    162c:	3c 2f       	mov	r19, r28
    162e:	32 95       	swap	r19
    1630:	33 0f       	add	r19, r19
    1632:	30 7e       	andi	r19, 0xE0	; 224
    1634:	d3 27       	eor	r29, r19
    1636:	9e 01       	movw	r18, r28
    1638:	22 0f       	add	r18, r18
    163a:	23 2f       	mov	r18, r19
    163c:	22 1f       	adc	r18, r18
    163e:	33 0b       	sbc	r19, r19
    1640:	31 95       	neg	r19
    1642:	c2 27       	eor	r28, r18
    1644:	d3 27       	eor	r29, r19
    1646:	9e 01       	movw	r18, r28
    1648:	22 0f       	add	r18, r18
    164a:	33 1f       	adc	r19, r19
    164c:	22 0f       	add	r18, r18
    164e:	33 1f       	adc	r19, r19
    1650:	22 0f       	add	r18, r18
    1652:	33 1f       	adc	r19, r19
    1654:	22 0f       	add	r18, r18
    1656:	33 1f       	adc	r19, r19
    1658:	22 0f       	add	r18, r18
    165a:	33 1f       	adc	r19, r19
    165c:	22 0f       	add	r18, r18
    165e:	33 1f       	adc	r19, r19
    1660:	c2 27       	eor	r28, r18
    1662:	d3 27       	eor	r29, r19
    1664:	c0 93 b2 42 	sts	0x42B2, r28	; 0x8042b2 <__xor16_d76_state>
    1668:	d0 93 b3 42 	sts	0x42B3, r29	; 0x8042b3 <__xor16_d76_state+0x1>
setup():
    166c:	81 e1       	ldi	r24, 0x11	; 17
    166e:	92 e4       	ldi	r25, 0x42	; 66
    1670:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:234
    seed_xor16_d76(seed);
    seed = xor16_d76();
    SERIALPORT.print("d76: ");
    1674:	ce 01       	movw	r24, r28
    1676:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d79():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:235
    SERIALPORT.println(seed);
    167a:	20 97       	sbiw	r28, 0x00	; 0
    167c:	21 f0       	breq	.+8      	; 0x1686 <setup+0x122a>
    167e:	c0 93 b4 42 	sts	0x42B4, r28	; 0x8042b4 <__xor16_d79_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d79.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1682:	d0 93 b5 42 	sts	0x42B5, r29	; 0x8042b5 <__xor16_d79_state+0x1>
xor16_d79():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d79.cpp:13
    __xor16_d79_state = seed;
    1686:	c0 91 b4 42 	lds	r28, 0x42B4	; 0x8042b4 <__xor16_d79_state>
    168a:	d0 91 b5 42 	lds	r29, 0x42B5	; 0x8042b5 <__xor16_d79_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d79.cpp:37
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d79_state)::"r18","r19");
    168e:	3c 2f       	mov	r19, r28
    1690:	32 95       	swap	r19
    1692:	33 0f       	add	r19, r19
    1694:	30 7e       	andi	r19, 0xE0	; 224
    1696:	d3 27       	eor	r29, r19
    1698:	9e 01       	movw	r18, r28
    169a:	22 0f       	add	r18, r18
    169c:	23 2f       	mov	r18, r19
    169e:	22 1f       	adc	r18, r18
    16a0:	33 0b       	sbc	r19, r19
    16a2:	31 95       	neg	r19
    16a4:	c2 27       	eor	r28, r18
    16a6:	d3 27       	eor	r29, r19
    16a8:	3c 2f       	mov	r19, r28
    16aa:	33 0f       	add	r19, r19
    16ac:	d3 27       	eor	r29, r19
    16ae:	c0 93 b4 42 	sts	0x42B4, r28	; 0x8042b4 <__xor16_d79_state>
    16b2:	d0 93 b5 42 	sts	0x42B5, r29	; 0x8042b5 <__xor16_d79_state+0x1>
setup():
    16b6:	87 e1       	ldi	r24, 0x17	; 23
    16b8:	92 e4       	ldi	r25, 0x42	; 66
    16ba:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:238
    seed_xor16_d79(seed);
    seed = xor16_d79();
    SERIALPORT.print("d79: ");
    16be:	ce 01       	movw	r24, r28
    16c0:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d97():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:239
    SERIALPORT.println(seed);
    16c4:	20 97       	sbiw	r28, 0x00	; 0
    16c6:	21 f0       	breq	.+8      	; 0x16d0 <setup+0x1274>
    16c8:	c0 93 b6 42 	sts	0x42B6, r28	; 0x8042b6 <__xor16_d97_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d97.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    16cc:	d0 93 b7 42 	sts	0x42B7, r29	; 0x8042b7 <__xor16_d97_state+0x1>
xor16_d97():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d97.cpp:13
    __xor16_d97_state = seed;
    16d0:	c0 91 b6 42 	lds	r28, 0x42B6	; 0x8042b6 <__xor16_d97_state>
    16d4:	d0 91 b7 42 	lds	r29, 0x42B7	; 0x8042b7 <__xor16_d97_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d97.cpp:37
      "eor    r18, r18"      "\n\t"
      "ror    r19"           "\n\t"
      "ror    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d97_state)::"r18","r19");
    16d8:	3c 2f       	mov	r19, r28
    16da:	32 95       	swap	r19
    16dc:	33 0f       	add	r19, r19
    16de:	30 7e       	andi	r19, 0xE0	; 224
    16e0:	d3 27       	eor	r29, r19
    16e2:	2d 2f       	mov	r18, r29
    16e4:	26 95       	lsr	r18
    16e6:	c2 27       	eor	r28, r18
    16e8:	9e 01       	movw	r18, r28
    16ea:	36 95       	lsr	r19
    16ec:	32 2f       	mov	r19, r18
    16ee:	22 27       	eor	r18, r18
    16f0:	37 95       	ror	r19
    16f2:	27 95       	ror	r18
    16f4:	c2 27       	eor	r28, r18
    16f6:	d3 27       	eor	r29, r19
    16f8:	c0 93 b6 42 	sts	0x42B6, r28	; 0x8042b6 <__xor16_d97_state>
    16fc:	d0 93 b7 42 	sts	0x42B7, r29	; 0x8042b7 <__xor16_d97_state+0x1>
setup():
    1700:	8d e1       	ldi	r24, 0x1D	; 29
    1702:	92 e4       	ldi	r25, 0x42	; 66
    1704:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:242
    seed_xor16_d97(seed);
    seed = xor16_d97();
    SERIALPORT.print("d97: ");
    1708:	ce 01       	movw	r24, r28
    170a:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_e11():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:243
    SERIALPORT.println(seed);
    170e:	20 97       	sbiw	r28, 0x00	; 0
    1710:	21 f0       	breq	.+8      	; 0x171a <setup+0x12be>
    1712:	c0 93 b8 42 	sts	0x42B8, r28	; 0x8042b8 <__xor16_e11_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e11.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1716:	d0 93 b9 42 	sts	0x42B9, r29	; 0x8042b9 <__xor16_e11_state+0x1>
xor16_e11():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e11.cpp:13
    __xor16_e11_state = seed;
    171a:	c0 91 b8 42 	lds	r28, 0x42B8	; 0x8042b8 <__xor16_e11_state>
    171e:	d0 91 b9 42 	lds	r29, 0x42B9	; 0x8042b9 <__xor16_e11_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e11.cpp:37
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_e11_state)::"r18","r19");
    1722:	33 27       	eor	r19, r19
    1724:	c0 fb       	bst	r28, 0
    1726:	36 f9       	bld	r19, 6
    1728:	c1 fb       	bst	r28, 1
    172a:	37 f9       	bld	r19, 7
    172c:	d3 27       	eor	r29, r19
    172e:	9e 01       	movw	r18, r28
    1730:	36 95       	lsr	r19
    1732:	27 95       	ror	r18
    1734:	c2 27       	eor	r28, r18
    1736:	d3 27       	eor	r29, r19
    1738:	9e 01       	movw	r18, r28
    173a:	22 0f       	add	r18, r18
    173c:	33 1f       	adc	r19, r19
    173e:	c2 27       	eor	r28, r18
    1740:	d3 27       	eor	r29, r19
    1742:	c0 93 b8 42 	sts	0x42B8, r28	; 0x8042b8 <__xor16_e11_state>
    1746:	d0 93 b9 42 	sts	0x42B9, r29	; 0x8042b9 <__xor16_e11_state+0x1>
setup():
    174a:	83 e2       	ldi	r24, 0x23	; 35
    174c:	92 e4       	ldi	r25, 0x42	; 66
    174e:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:246
    seed_xor16_e11(seed);
    seed = xor16_e11();
    SERIALPORT.print("e11: ");
    1752:	ce 01       	movw	r24, r28
    1754:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_e75():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:247
    SERIALPORT.println(seed);
    1758:	20 97       	sbiw	r28, 0x00	; 0
    175a:	21 f0       	breq	.+8      	; 0x1764 <setup+0x1308>
    175c:	c0 93 ba 42 	sts	0x42BA, r28	; 0x8042ba <__xor16_e75_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e75.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1760:	d0 93 bb 42 	sts	0x42BB, r29	; 0x8042bb <__xor16_e75_state+0x1>
xor16_e75():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e75.cpp:13
    __xor16_e75_state = seed;
    1764:	c0 91 ba 42 	lds	r28, 0x42BA	; 0x8042ba <__xor16_e75_state>
    1768:	d0 91 bb 42 	lds	r29, 0x42BB	; 0x8042bb <__xor16_e75_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e75.cpp:48
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_e75_state)::"r18","r19");
    176c:	33 27       	eor	r19, r19
    176e:	c0 fb       	bst	r28, 0
    1770:	36 f9       	bld	r19, 6
    1772:	c1 fb       	bst	r28, 1
    1774:	37 f9       	bld	r19, 7
    1776:	d3 27       	eor	r29, r19
    1778:	9e 01       	movw	r18, r28
    177a:	22 0f       	add	r18, r18
    177c:	23 2f       	mov	r18, r19
    177e:	22 1f       	adc	r18, r18
    1780:	33 0b       	sbc	r19, r19
    1782:	31 95       	neg	r19
    1784:	c2 27       	eor	r28, r18
    1786:	d3 27       	eor	r29, r19
    1788:	9e 01       	movw	r18, r28
    178a:	22 0f       	add	r18, r18
    178c:	33 1f       	adc	r19, r19
    178e:	22 0f       	add	r18, r18
    1790:	33 1f       	adc	r19, r19
    1792:	22 0f       	add	r18, r18
    1794:	33 1f       	adc	r19, r19
    1796:	22 0f       	add	r18, r18
    1798:	33 1f       	adc	r19, r19
    179a:	22 0f       	add	r18, r18
    179c:	33 1f       	adc	r19, r19
    179e:	c2 27       	eor	r28, r18
    17a0:	d3 27       	eor	r29, r19
    17a2:	c0 93 ba 42 	sts	0x42BA, r28	; 0x8042ba <__xor16_e75_state>
    17a6:	d0 93 bb 42 	sts	0x42BB, r29	; 0x8042bb <__xor16_e75_state+0x1>
setup():
    17aa:	89 e2       	ldi	r24, 0x29	; 41
    17ac:	92 e4       	ldi	r25, 0x42	; 66
    17ae:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:250
    seed_xor16_e75(seed);
    seed = xor16_e75();
    SERIALPORT.print("e75: ");
    17b2:	ce 01       	movw	r24, r28
    17b4:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_f11():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:251
    SERIALPORT.println(seed);
    17b8:	20 97       	sbiw	r28, 0x00	; 0
    17ba:	21 f0       	breq	.+8      	; 0x17c4 <setup+0x1368>
    17bc:	c0 93 bc 42 	sts	0x42BC, r28	; 0x8042bc <__xor16_f11_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f11.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    17c0:	d0 93 bd 42 	sts	0x42BD, r29	; 0x8042bd <__xor16_f11_state+0x1>
xor16_f11():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f11.cpp:13
    __xor16_f11_state = seed;
    17c4:	c0 91 bc 42 	lds	r28, 0x42BC	; 0x8042bc <__xor16_f11_state>
    17c8:	d0 91 bd 42 	lds	r29, 0x42BD	; 0x8042bd <__xor16_f11_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f11.cpp:35
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_f11_state)::"r18","r19");
    17cc:	33 27       	eor	r19, r19
    17ce:	c0 fb       	bst	r28, 0
    17d0:	37 f9       	bld	r19, 7
    17d2:	d3 27       	eor	r29, r19
    17d4:	9e 01       	movw	r18, r28
    17d6:	36 95       	lsr	r19
    17d8:	27 95       	ror	r18
    17da:	c2 27       	eor	r28, r18
    17dc:	d3 27       	eor	r29, r19
    17de:	9e 01       	movw	r18, r28
    17e0:	22 0f       	add	r18, r18
    17e2:	33 1f       	adc	r19, r19
    17e4:	c2 27       	eor	r28, r18
    17e6:	d3 27       	eor	r29, r19
    17e8:	c0 93 bc 42 	sts	0x42BC, r28	; 0x8042bc <__xor16_f11_state>
    17ec:	d0 93 bd 42 	sts	0x42BD, r29	; 0x8042bd <__xor16_f11_state+0x1>
setup():
    17f0:	8f e2       	ldi	r24, 0x2F	; 47
    17f2:	92 e4       	ldi	r25, 0x42	; 66
    17f4:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:254
    seed_xor16_f11(seed);
    seed = xor16_f11();
    SERIALPORT.print("f11: ");
    17f8:	ce 01       	movw	r24, r28
    17fa:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_f13():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:255
    SERIALPORT.println(seed);
    17fe:	20 97       	sbiw	r28, 0x00	; 0
    1800:	21 f0       	breq	.+8      	; 0x180a <setup+0x13ae>
    1802:	c0 93 be 42 	sts	0x42BE, r28	; 0x8042be <__xor16_f13_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f13.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1806:	d0 93 bf 42 	sts	0x42BF, r29	; 0x8042bf <__xor16_f13_state+0x1>
xor16_f13():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f13.cpp:13
    __xor16_f13_state = seed;
    180a:	c0 91 be 42 	lds	r28, 0x42BE	; 0x8042be <__xor16_f13_state>
    180e:	d0 91 bf 42 	lds	r29, 0x42BF	; 0x8042bf <__xor16_f13_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f13.cpp:39
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_f13_state)::"r18","r19");
    1812:	33 27       	eor	r19, r19
    1814:	c0 fb       	bst	r28, 0
    1816:	37 f9       	bld	r19, 7
    1818:	d3 27       	eor	r29, r19
    181a:	9e 01       	movw	r18, r28
    181c:	36 95       	lsr	r19
    181e:	27 95       	ror	r18
    1820:	c2 27       	eor	r28, r18
    1822:	d3 27       	eor	r29, r19
    1824:	9e 01       	movw	r18, r28
    1826:	22 0f       	add	r18, r18
    1828:	33 1f       	adc	r19, r19
    182a:	22 0f       	add	r18, r18
    182c:	33 1f       	adc	r19, r19
    182e:	22 0f       	add	r18, r18
    1830:	33 1f       	adc	r19, r19
    1832:	c2 27       	eor	r28, r18
    1834:	d3 27       	eor	r29, r19
    1836:	c0 93 be 42 	sts	0x42BE, r28	; 0x8042be <__xor16_f13_state>
    183a:	d0 93 bf 42 	sts	0x42BF, r29	; 0x8042bf <__xor16_f13_state+0x1>
setup():
    183e:	85 e3       	ldi	r24, 0x35	; 53
    1840:	92 e4       	ldi	r25, 0x42	; 66
    1842:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:258
    seed_xor16_f13(seed);
    seed = xor16_f13();
    SERIALPORT.print("f13: ");
    1846:	ce 01       	movw	r24, r28
    1848:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_f52():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:259
    SERIALPORT.println(seed);
    184c:	20 97       	sbiw	r28, 0x00	; 0
    184e:	21 f0       	breq	.+8      	; 0x1858 <setup+0x13fc>
    1850:	c0 93 c0 42 	sts	0x42C0, r28	; 0x8042c0 <__xor16_f52_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f52.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1854:	d0 93 c1 42 	sts	0x42C1, r29	; 0x8042c1 <__xor16_f52_state+0x1>
xor16_f52():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f52.cpp:13
    __xor16_f52_state = seed;
    1858:	c0 91 c0 42 	lds	r28, 0x42C0	; 0x8042c0 <__xor16_f52_state>
    185c:	d0 91 c1 42 	lds	r29, 0x42C1	; 0x8042c1 <__xor16_f52_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f52.cpp:45
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_f52_state)::"r18","r19");
    1860:	33 27       	eor	r19, r19
    1862:	c0 fb       	bst	r28, 0
    1864:	37 f9       	bld	r19, 7
    1866:	d3 27       	eor	r29, r19
    1868:	9e 01       	movw	r18, r28
    186a:	36 95       	lsr	r19
    186c:	27 95       	ror	r18
    186e:	36 95       	lsr	r19
    1870:	27 95       	ror	r18
    1872:	36 95       	lsr	r19
    1874:	27 95       	ror	r18
    1876:	36 95       	lsr	r19
    1878:	27 95       	ror	r18
    187a:	36 95       	lsr	r19
    187c:	27 95       	ror	r18
    187e:	c2 27       	eor	r28, r18
    1880:	d3 27       	eor	r29, r19
    1882:	9e 01       	movw	r18, r28
    1884:	22 0f       	add	r18, r18
    1886:	33 1f       	adc	r19, r19
    1888:	22 0f       	add	r18, r18
    188a:	33 1f       	adc	r19, r19
    188c:	c2 27       	eor	r28, r18
    188e:	d3 27       	eor	r29, r19
    1890:	c0 93 c0 42 	sts	0x42C0, r28	; 0x8042c0 <__xor16_f52_state>
    1894:	d0 93 c1 42 	sts	0x42C1, r29	; 0x8042c1 <__xor16_f52_state+0x1>
setup():
    1898:	8b e3       	ldi	r24, 0x3B	; 59
    189a:	92 e4       	ldi	r25, 0x42	; 66
    189c:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:262
    seed_xor16_f52(seed);
    seed = xor16_f52();
    SERIALPORT.print("f52: ");
    18a0:	ce 01       	movw	r24, r28
    18a2:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_f72():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:263
    SERIALPORT.println(seed);
    18a6:	20 97       	sbiw	r28, 0x00	; 0
    18a8:	21 f0       	breq	.+8      	; 0x18b2 <setup+0x1456>
    18aa:	c0 93 c2 42 	sts	0x42C2, r28	; 0x8042c2 <__xor16_f72_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f72.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    18ae:	d0 93 c3 42 	sts	0x42C3, r29	; 0x8042c3 <__xor16_f72_state+0x1>
xor16_f72():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f72.cpp:13
    __xor16_f72_state = seed;
    18b2:	c0 91 c2 42 	lds	r28, 0x42C2	; 0x8042c2 <__xor16_f72_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f72.cpp:40
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_f72_state)::"r18","r19");
    18b6:	d0 91 c3 42 	lds	r29, 0x42C3	; 0x8042c3 <__xor16_f72_state+0x1>
    18ba:	33 27       	eor	r19, r19
    18bc:	c0 fb       	bst	r28, 0
    18be:	37 f9       	bld	r19, 7
    18c0:	d3 27       	eor	r29, r19
    18c2:	9e 01       	movw	r18, r28
    18c4:	22 0f       	add	r18, r18
    18c6:	23 2f       	mov	r18, r19
    18c8:	22 1f       	adc	r18, r18
    18ca:	33 0b       	sbc	r19, r19
    18cc:	31 95       	neg	r19
    18ce:	c2 27       	eor	r28, r18
    18d0:	d3 27       	eor	r29, r19
    18d2:	9e 01       	movw	r18, r28
    18d4:	22 0f       	add	r18, r18
    18d6:	33 1f       	adc	r19, r19
    18d8:	22 0f       	add	r18, r18
    18da:	33 1f       	adc	r19, r19
    18dc:	c2 27       	eor	r28, r18
    18de:	d3 27       	eor	r29, r19
    18e0:	c0 93 c2 42 	sts	0x42C2, r28	; 0x8042c2 <__xor16_f72_state>
    18e4:	d0 93 c3 42 	sts	0x42C3, r29	; 0x8042c3 <__xor16_f72_state+0x1>
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:266
    seed_xor16_f72(seed);
    seed = xor16_f72();
    SERIALPORT.print("f72: ");
    18e8:	81 e4       	ldi	r24, 0x41	; 65
    18ea:	92 e4       	ldi	r25, 0x42	; 66
    18ec:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:267
    SERIALPORT.println(seed);
    18f0:	ce 01       	movw	r24, r28
    18f2:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
write():
    18f6:	67 e4       	ldi	r22, 0x47	; 71
    18f8:	72 e4       	ldi	r23, 0x42	; 66
    18fa:	88 ec       	ldi	r24, 0xC8	; 200
    18fc:	92 e4       	ldi	r25, 0x42	; 66
    18fe:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
    1902:	67 e5       	ldi	r22, 0x57	; 87
    1904:	70 e4       	ldi	r23, 0x40	; 64
    1906:	88 ec       	ldi	r24, 0xC8	; 200
    1908:	92 e4       	ldi	r25, 0x42	; 66
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:271
    SERIALPORT.println("Done");
  #endif
#endif
}
    190a:	df 91       	pop	r29
    190c:	cf 91       	pop	r28
    190e:	ff 90       	pop	r15
    1910:	ef 90       	pop	r14
    1912:	df 90       	pop	r13
    1914:	cf 90       	pop	r12
write():
    1916:	0c 94 dc 01 	jmp	0x3b8	; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
setup():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:661
   */

  /*******************************
   *  Phase 1: Input Processing  |
   ******************************/
  if (!(ADC0.CTRLA & 0x01)) return ADC_ENH_ERROR_DISABLED;
    191a:	c9 ef       	ldi	r28, 0xF9	; 249
write():
    191c:	6a e7       	ldi	r22, 0x7A	; 122
    191e:	70 e4       	ldi	r23, 0x40	; 64
    1920:	88 ec       	ldi	r24, 0xC8	; 200
    1922:	92 e4       	ldi	r25, 0x42	; 66
    1924:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
    1928:	67 e5       	ldi	r22, 0x57	; 87
    192a:	70 e4       	ldi	r23, 0x40	; 64
    192c:	88 ec       	ldi	r24, 0xC8	; 200
    192e:	92 e4       	ldi	r25, 0x42	; 66
    1930:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:23
    #else
      int32_t adcread = analogReadEnh(PIN_PD4, ADC_ACC16);
    #endif
    if (adcread < 0) {
      SERIALPORT.println("ADC failure!! Please report the conditions under which this occurred via github issue. ");
      SERIALPORT.print("Error code: ");
    1934:	82 ed       	ldi	r24, 0xD2	; 210
    1936:	90 e4       	ldi	r25, 0x40	; 64
    1938:	0e 94 e5 01 	call	0x3ca	; 0x3ca <Print::print(char const*) [clone .constprop.9]>
printHex():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:855
          printHex(*(ptr++));
          printHex(*(ptr++));
          printHex(*(ptr));
        } else {
          ptr+=3;
          printHex(*(ptr--));
    193c:	82 e8       	ldi	r24, 0x82	; 130
    193e:	0e 94 6d 01 	call	0x2da	; 0x2da <HardwareSerial::printHex(unsigned char) [clone .constprop.19]>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:856
          printHex(*(ptr--));
    1942:	84 ed       	ldi	r24, 0xD4	; 212
    1944:	0e 94 6d 01 	call	0x2da	; 0x2da <HardwareSerial::printHex(unsigned char) [clone .constprop.19]>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:857
          printHex(*(ptr--));
    1948:	8a e8       	ldi	r24, 0x8A	; 138
    194a:	0e 94 6d 01 	call	0x2da	; 0x2da <HardwareSerial::printHex(unsigned char) [clone .constprop.19]>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:858
          printHex(*(ptr));
    194e:	8c 2f       	mov	r24, r28
    1950:	0e 94 6d 01 	call	0x2da	; 0x2da <HardwareSerial::printHex(unsigned char) [clone .constprop.19]>
write():
    1954:	67 e5       	ldi	r22, 0x57	; 87
    1956:	70 e4       	ldi	r23, 0x40	; 64
    1958:	88 ec       	ldi	r24, 0xC8	; 200
    195a:	92 e4       	ldi	r25, 0x42	; 66
    195c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
    1960:	ff cf       	rjmp	.-2      	; 0x1960 <setup+0x1504>
setup():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:688
          Not worth wasting on the scale of 20-some-odd bytes of flash just to give an error to people who dynamically generate invalid analog pins
          and try to use them with analogReadEnh(), instead of just returning whatever we get from reading the bogus channel */
    return ADC_ENH_ERROR_BAD_PIN_OR_CHANNEL;
  }
  if (ADC0.COMMAND & ADC_STCONV_bm) {
    return ADC_ENH_ERROR_BUSY;
    1962:	cf ef       	ldi	r28, 0xFF	; 255
    1964:	db cf       	rjmp	.-74     	; 0x191c <setup+0x14c0>

00001966 <__vector_22>:
__vector_22():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:119
    ISR(USART0_DRE_vect, ISR_NAKED) {
      __asm__ __volatile__(
                "push  r30"       "\n\t"
                "push  r31"       "\n\t"
                "cbi   0x1F, 0"   "\n\t"
                :::);
    1966:	ef 93       	push	r30
    1968:	ff 93       	push	r31
    196a:	f8 98       	cbi	0x1f, 0	; 31
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:126
#if PROGMEM_SIZE > 8192
                "jmp _do_dre"     "\n\t"
#else
                "rjmp _do_dre"    "\n\t"
#endif
                ::"z"(&Serial0));
    196c:	e8 ec       	ldi	r30, 0xC8	; 200
    196e:	f2 e4       	ldi	r31, 0x42	; 66
    1970:	0b c0       	rjmp	.+22     	; 0x1988 <_do_dre()>

00001972 <__vector_21>:
__vector_21():
    1972:	ef 93       	push	r30
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:96
      ISR(USART0_RXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t" //we start out 5-6 clocks behind the ball, then do 2 push + 2 ldi + 2-3 for jump = 11 or 13 clocks to _do_rxc (and dre is the same)
              "push      r31"     "\n\t"
              "cbi   0x1F, 0"     "\n\t"
              :::);
    1974:	ff 93       	push	r31
    1976:	f8 98       	cbi	0x1f, 0	; 31
    1978:	e8 ec       	ldi	r30, 0xC8	; 200
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:103
#if PROGMEM_SIZE > 8192
              "jmp   _do_rxc"     "\n\t"
#else
              "rjmp   _do_rxc"    "\n\t"
#endif
              ::"z"(&Serial0));
    197a:	f2 e4       	ldi	r31, 0x42	; 66
    197c:	34 c0       	rjmp	.+104    	; 0x19e6 <_do_rxc()>

0000197e <__vector_23>:
__vector_23():
    197e:	ef 93       	push	r30
    1980:	ff 93       	push	r31
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:59
#elif defined(USE_ASM_TXC) && USE_ASM_TXC == 2
    ISR(USART0_TXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t"
              "push      r31"     "\n\t"
              :::);
    1982:	e8 ec       	ldi	r30, 0xC8	; 200
    1984:	f2 e4       	ldi	r31, 0x42	; 66
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:66
#if PROGMEM_SIZE > 8192
              "jmp   _do_txc"     "\n\t"
#else
              "rjmp   _do_txc"    "\n\t"
#endif
              ::"z"(&Serial0));
    1986:	5f c0       	rjmp	.+190    	; 0x1a46 <_do_txc()>

00001988 <_do_dre()>:
_Z7_do_drev():
    1988:	2f 93       	push	r18
    198a:	2f b7       	in	r18, 0x3f	; 63
    198c:	2f 93       	push	r18
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:387
          "out        0x3f,     r18"      "\n\t"  // restore SREG
          "pop         r18"               "\n\t"  // pop old r18
          "pop         r31"               "\n\t"  // pop the Z that the isr pushed.
          "pop         r30"               "\n\t"
          "reti"                          "\n"   // and RETI!
          ::);
    198e:	8f 93       	push	r24
    1990:	9f 93       	push	r25
    1992:	af 93       	push	r26
    1994:	bf 93       	push	r27
    1996:	68 94       	set

00001998 <_poll_dre>:
    1998:	cf 93       	push	r28
    199a:	df 93       	push	r29
    199c:	20 e0       	ldi	r18, 0x00	; 0
    199e:	c0 85       	ldd	r28, Z+8	; 0x08
    19a0:	d8 e0       	ldi	r29, 0x08	; 8
    19a2:	92 89       	ldd	r25, Z+18	; 0x12
    19a4:	df 01       	movw	r26, r30
    19a6:	a9 0f       	add	r26, r25
    19a8:	b2 1f       	adc	r27, r18
    19aa:	ad 5a       	subi	r26, 0xAD	; 173
    19ac:	bf 4f       	sbci	r27, 0xFF	; 255
    19ae:	8c 91       	ld	r24, X
    19b0:	20 e4       	ldi	r18, 0x40	; 64
    19b2:	2c 83       	std	Y+4, r18	; 0x04
    19b4:	8a 83       	std	Y+2, r24	; 0x02
    19b6:	9f 5f       	subi	r25, 0xFF	; 255
    19b8:	9f 73       	andi	r25, 0x3F	; 63
    19ba:	8d 81       	ldd	r24, Y+5	; 0x05
    19bc:	21 89       	ldd	r18, Z+17	; 0x11
    19be:	29 13       	cpse	r18, r25
    19c0:	02 c0       	rjmp	.+4      	; 0x19c6 <_done_dre_irq>
    19c2:	8f 7d       	andi	r24, 0xDF	; 223
    19c4:	8d 83       	std	Y+5, r24	; 0x05

000019c6 <_done_dre_irq>:
    19c6:	92 8b       	std	Z+18, r25	; 0x12
    19c8:	df 91       	pop	r29
    19ca:	cf 91       	pop	r28
    19cc:	16 f0       	brts	.+4      	; 0x19d2 <_done_dre_irq+0xc>
    19ce:	0c 94 20 01 	jmp	0x240	; 0x240 <_poll_dre_done>
    19d2:	bf 91       	pop	r27
    19d4:	af 91       	pop	r26
    19d6:	9f 91       	pop	r25
    19d8:	8f 91       	pop	r24
    19da:	2f 91       	pop	r18
    19dc:	2f bf       	out	0x3f, r18	; 63
    19de:	2f 91       	pop	r18
    19e0:	ff 91       	pop	r31
    19e2:	ef 91       	pop	r30
    19e4:	18 95       	reti

000019e6 <_do_rxc()>:
_Z7_do_rxcv():
    19e6:	2f 93       	push	r18
    19e8:	2f b7       	in	r18, 0x3f	; 63
    19ea:	2f 93       	push	r18
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:252
            "pop        r30"              "\n\t" // pointer to serial instance
            "reti"                        "\n\t" // return
          "_buff_full_rxc:"               "\n\t" // _buff_full_rxc moved to after the reti, and then rjmps back, saving 2 clocks for the common case
            "ori        r19,      0x40"   "\n\t" // record that there was a ring buffer overflow. 1 clk
            "rjmp _end_rxc"               "\n\t" // and now jump back to end. That way we don't need to jump over this in the middle of the common case.
            ::); // total: 77 or 79 clocks, just barely squeaks by for cyclic RX of up to RX_BUFFER_SIZE characters.
    19ec:	3f 93       	push	r19
    19ee:	8f 93       	push	r24
    19f0:	9f 93       	push	r25
    19f2:	cf 93       	push	r28
    19f4:	df 93       	push	r29
    19f6:	c0 85       	ldd	r28, Z+8	; 0x08
    19f8:	d8 e0       	ldi	r29, 0x08	; 8
    19fa:	2e 81       	ldd	r18, Y+6	; 0x06
    19fc:	2f 7e       	andi	r18, 0xEF	; 239
    19fe:	2e 83       	std	Y+6, r18	; 0x06
    1a00:	89 81       	ldd	r24, Y+1	; 0x01
    1a02:	98 81       	ld	r25, Y
    1a04:	86 74       	andi	r24, 0x46	; 70
    1a06:	88 0f       	add	r24, r24
    1a08:	36 85       	ldd	r19, Z+14	; 0x0e
    1a0a:	38 2b       	or	r19, r24
    1a0c:	82 fd       	sbrc	r24, 2
    1a0e:	0d c0       	rjmp	.+26     	; 0x1a2a <_end_rxc>
    1a10:	c7 85       	ldd	r28, Z+15	; 0x0f
    1a12:	81 e0       	ldi	r24, 0x01	; 1
    1a14:	8c 0f       	add	r24, r28
    1a16:	8f 73       	andi	r24, 0x3F	; 63
    1a18:	20 89       	ldd	r18, Z+16	; 0x10
    1a1a:	28 17       	cp	r18, r24
    1a1c:	91 f0       	breq	.+36     	; 0x1a42 <_buff_full_rxc>
    1a1e:	ce 0f       	add	r28, r30
    1a20:	df 2f       	mov	r29, r31
    1a22:	20 e0       	ldi	r18, 0x00	; 0
    1a24:	d2 1f       	adc	r29, r18
    1a26:	9b 8b       	std	Y+19, r25	; 0x13
    1a28:	87 87       	std	Z+15, r24	; 0x0f

00001a2a <_end_rxc>:
    1a2a:	36 87       	std	Z+14, r19	; 0x0e
    1a2c:	df 91       	pop	r29
    1a2e:	cf 91       	pop	r28
    1a30:	9f 91       	pop	r25
    1a32:	8f 91       	pop	r24
    1a34:	3f 91       	pop	r19
    1a36:	2f 91       	pop	r18
    1a38:	2f bf       	out	0x3f, r18	; 63
    1a3a:	2f 91       	pop	r18
    1a3c:	ff 91       	pop	r31
    1a3e:	ef 91       	pop	r30
    1a40:	18 95       	reti

00001a42 <_buff_full_rxc>:
    1a42:	30 64       	ori	r19, 0x40	; 64
    1a44:	f2 cf       	rjmp	.-28     	; 0x1a2a <_end_rxc>

00001a46 <_do_txc()>:
_Z7_do_txcv():
    1a46:	8f 93       	push	r24
    1a48:	8f b7       	in	r24, 0x3f	; 63
    1a4a:	8f 93       	push	r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:127
            "pop        r24"              "\n\t"  // pop r24 restore it
            "pop        r31"              "\n\t"  // and r31
            "pop        r30"              "\n\t"  // Pop the register the ISR did
            "reti"                        "\n"    // return from the interrupt.
            ::
          );
    1a4c:	9f 93       	push	r25
    1a4e:	cf 93       	push	r28
    1a50:	df 93       	push	r29
    1a52:	c0 85       	ldd	r28, Z+8	; 0x08
    1a54:	d8 e0       	ldi	r29, 0x08	; 8
    1a56:	9d 81       	ldd	r25, Y+5	; 0x05

00001a58 <_txc_flush_rx>:
    1a58:	88 81       	ld	r24, Y
    1a5a:	8c 81       	ldd	r24, Y+4	; 0x04
    1a5c:	87 fd       	sbrc	r24, 7
    1a5e:	fc cf       	rjmp	.-8      	; 0x1a58 <_txc_flush_rx>
    1a60:	9f 7b       	andi	r25, 0xBF	; 191
    1a62:	90 68       	ori	r25, 0x80	; 128
    1a64:	9d 83       	std	Y+5, r25	; 0x05
    1a66:	df 91       	pop	r29
    1a68:	cf 91       	pop	r28
    1a6a:	9f 91       	pop	r25
    1a6c:	8f 91       	pop	r24
    1a6e:	8f bf       	out	0x3f, r24	; 63
    1a70:	8f 91       	pop	r24
    1a72:	ff 91       	pop	r31
    1a74:	ef 91       	pop	r30
    1a76:	18 95       	reti

00001a78 <__vector_31>:
__vector_31():
    1a78:	ef 93       	push	r30
    1a7a:	ff 93       	push	r31
    1a7c:	e4 ec       	ldi	r30, 0xC4	; 196
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:135
      }
      RTC.INTFLAGS = RTC_OVF_bm | RTC_CMP_bm; // clear flag
    }
  #elif !defined(MILLIS_USE_TIMERNONE)
    ISR(MILLIS_VECTOR, ISR_NAKED) {
      __asm__ __volatile__(
    1a7e:	f2 e4       	ldi	r31, 0x42	; 66
    1a80:	8f 93       	push	r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:140
      "push       r30"          "\n\t" // First we make room for the pointer to timingStruct by pushing the Z registers
      "push       r31"          "\n\t" //
      ::);
    #if defined(MILLIS_USE_TCB)
      __asm__ __volatile__(
    1a82:	8f b7       	in	r24, 0x3f	; 63
    1a84:	8f 93       	push	r24
    1a86:	80 81       	ld	r24, Z
    1a88:	8f 5f       	subi	r24, 0xFF	; 255
    1a8a:	80 83       	st	Z, r24
    1a8c:	81 81       	ldd	r24, Z+1	; 0x01
    1a8e:	8f 4f       	sbci	r24, 0xFF	; 255
    1a90:	81 83       	std	Z+1, r24	; 0x01
    1a92:	82 81       	ldd	r24, Z+2	; 0x02
    1a94:	8f 4f       	sbci	r24, 0xFF	; 255
    1a96:	82 83       	std	Z+2, r24	; 0x02
    1a98:	83 81       	ldd	r24, Z+3	; 0x03
    1a9a:	8f 4f       	sbci	r24, 0xFF	; 255
    1a9c:	83 83       	std	Z+3, r24	; 0x03
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	80 93 26 0b 	sts	0x0B26, r24	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
    1aa4:	8f 91       	pop	r24
    1aa6:	8f bf       	out	0x3f, r24	; 63
    1aa8:	8f 91       	pop	r24
    1aaa:	ff 91       	pop	r31
    1aac:	ef 91       	pop	r30
    1aae:	18 95       	reti

00001ab0 <main>:
init():
    1ab0:	84 e0       	ldi	r24, 0x04	; 4
    1ab2:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <__TEXT_REGION_LENGTH__+0x7e0470>
init_clock():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1861
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0B << 2));
      #elif (F_CPU == 28000000)
        /* Overclocked - generally quite reliable at room temperature, but a dumb frequency (see PWM section) */
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0A << 2));
      #elif (F_CPU == 24000000)
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x09 << 2));
    1ab6:	88 ed       	ldi	r24, 0xD8	; 216
    1ab8:	94 e2       	ldi	r25, 0x24	; 36
    1aba:	84 bf       	out	0x34, r24	; 52
    1abc:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <__TEXT_REGION_LENGTH__+0x7e0068>
init_TCA0():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2208
}

void __attribute__((weak)) init_TCA0() {
  /* TCA0_PINS from pins_arduino.h */
  /* Enable Split Mode to get more PWM pins, since analogWrite() only provides 8-bit PWM anyway*/
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    1ac0:	31 e0       	ldi	r19, 0x01	; 1
    1ac2:	30 93 03 0a 	sts	0x0A03, r19	; 0x800a03 <__TEXT_REGION_LENGTH__+0x7e0a03>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2213

  // Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    1ac6:	9e ef       	ldi	r25, 0xFE	; 254
    1ac8:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <__TEXT_REGION_LENGTH__+0x7e0a26>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2214
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    1acc:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x7e0a27>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2241
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) // use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA0) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA0 to different divider"
    #endif
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    1ad0:	8b e0       	ldi	r24, 0x0B	; 11
    1ad2:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x7e0a00>
init_timers():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2189
  init_TCA0();
  #if (defined(TCA1))
    PORTMUX.TCAROUTEA = TCA0_PINS | TCA1_PINS;
    init_TCA1();
  #else
    PORTMUX.TCAROUTEA = TCA0_PINS;
    1ad6:	23 e0       	ldi	r18, 0x03	; 3
    1ad8:	20 93 e6 05 	sts	0x05E6, r18	; 0x8005e6 <__TEXT_REGION_LENGTH__+0x7e05e6>
init_TCBs():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2319
 * Set up routing (defined in pins_arduino.h)
 * Notice how there's no semicolon until after the preprocessor conditionals.
 * In other words, that's all one line.
 */

  PORTMUX.TCBROUTEA = 0
    1adc:	10 92 e7 05 	sts	0x05E7, r1	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7e05e7>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2391
    #elif defined(MILLIS_USE_TIMERB7)
      if(timer_B != (TCB_t *)&TCB7)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    1ae0:	47 e0       	ldi	r20, 0x07	; 7
    1ae2:	40 93 01 0b 	sts	0x0B01, r20	; 0x800b01 <__TEXT_REGION_LENGTH__+0x7e0b01>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2394

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    1ae6:	90 93 0c 0b 	sts	0x0B0C, r25	; 0x800b0c <__TEXT_REGION_LENGTH__+0x7e0b0c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2397
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    1aea:	10 92 0d 0b 	sts	0x0B0D, r1	; 0x800b0d <__TEXT_REGION_LENGTH__+0x7e0b0d>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2400

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    1aee:	85 e0       	ldi	r24, 0x05	; 5
    1af0:	80 93 00 0b 	sts	0x0B00, r24	; 0x800b00 <__TEXT_REGION_LENGTH__+0x7e0b00>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2391
    #elif defined(MILLIS_USE_TIMERB7)
      if(timer_B != (TCB_t *)&TCB7)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    1af4:	40 93 11 0b 	sts	0x0B11, r20	; 0x800b11 <__TEXT_REGION_LENGTH__+0x7e0b11>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2394

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    1af8:	90 93 1c 0b 	sts	0x0B1C, r25	; 0x800b1c <__TEXT_REGION_LENGTH__+0x7e0b1c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2397
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    1afc:	10 92 1d 0b 	sts	0x0B1D, r1	; 0x800b1d <__TEXT_REGION_LENGTH__+0x7e0b1d>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2400

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    1b00:	80 93 10 0b 	sts	0x0B10, r24	; 0x800b10 <__TEXT_REGION_LENGTH__+0x7e0b10>
init_TCD0():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2444
 * be set in the status register. We skip checking this here because, as we do many places the  *
 * initiialization functions assume that the chip starts from a reset condition.                */

void __attribute__((weak)) init_TCD0() {
  #if defined(USE_TIMERD0_PWM) || defined (MILLIS_USE_TIMERD0)
    TCD0.CMPACLR  = 0x0FFF;
    1b04:	4f ef       	ldi	r20, 0xFF	; 255
    1b06:	5f e0       	ldi	r21, 0x0F	; 15
    1b08:	40 93 aa 0b 	sts	0x0BAA, r20	; 0x800baa <__TEXT_REGION_LENGTH__+0x7e0baa>
    1b0c:	50 93 ab 0b 	sts	0x0BAB, r21	; 0x800bab <__TEXT_REGION_LENGTH__+0x7e0bab>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2448
    // Match with CMPBCLR clears all outputs. For normal PWM this just needs to be higher than
    // it will count to - so set to maximum (other settings used for non-overlapping PWM and
    // other advanced functionality)
    TCD0.CTRLC    = 0x80;                   // WOD outputs PWM B, WOC outputs PWM A
    1b10:	90 e8       	ldi	r25, 0x80	; 128
    1b12:	90 93 82 0b 	sts	0x0B82, r25	; 0x800b82 <__TEXT_REGION_LENGTH__+0x7e0b82>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2450
    // That doesn't need to be that way, but I declare that that's all we support through analogWrite()
    TCD0.CTRLB    = TIMERD0_WGMODE_SETTING;
    1b16:	10 92 81 0b 	sts	0x0B81, r1	; 0x800b81 <__TEXT_REGION_LENGTH__+0x7e0b81>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2453
    // One ramp or dual slope are the only options that are viable to reproduce classic behavior without
    // considerable calculation overhead. We use one-ramp mode
    TCD0.CMPBCLR  = TIMERD0_TOP_SETTING;
    1b1a:	4b ef       	ldi	r20, 0xFB	; 251
    1b1c:	53 e0       	ldi	r21, 0x03	; 3
    1b1e:	40 93 ae 0b 	sts	0x0BAE, r20	; 0x800bae <__TEXT_REGION_LENGTH__+0x7e0bae>
    1b22:	50 93 af 0b 	sts	0x0BAF, r21	; 0x800baf <__TEXT_REGION_LENGTH__+0x7e0baf>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2462
    #if defined(TIMERD0_SET_CLOCK)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (TIMERD0_SET_CLOCK));
    #endif


    TCD0.CTRLA    = TIMERD0_CLOCK_SETTING | TCD_ENABLE_bm;
    1b26:	91 e7       	ldi	r25, 0x71	; 113
    1b28:	90 93 80 0b 	sts	0x0B80, r25	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
init_ADC0():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1703

/********************************* ADC ****************************************/
#if defined(ADC0)
  void __attribute__((weak)) init_ADC0() {
    ADC_t* pADC;
    _fastPtr_d(pADC, &ADC0);
    1b2c:	e0 e0       	ldi	r30, 0x00	; 0
    1b2e:	f6 e0       	ldi	r31, 0x06	; 6
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1714
      #elif F_CPU >= 36000000
        pADC->CTRLC = ADC_PRESC_DIV28_gc; // 1.286 @ 36 MHz
      #elif F_CPU >  28000000
        pADC->CTRLC = ADC_PRESC_DIV24_gc; // 1.33 @ 32 MHz, 1.
      #elif F_CPU >= 24000000
        pADC->CTRLC = ADC_PRESC_DIV20_gc; // 1.2 @ 24, 1.25 @ 25, 1.4 @ 28  MHz
    1b30:	82 83       	std	Z+2, r24	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1726
      #elif F_CPU >= 4000000
        pADC->CTRLC = ADC_PRESC_DIV4_gc;  // 1 MHz
      #else  // 1 MHz / 2 = 500 kHz - the lowest setting
        pADC->CTRLC = ADC_PRESC_DIV2_gc;
      #endif
      pADC->SAMPCTRL = 14; // 16 ADC clock sampling time - should be about the same amount of *time* as originally?
    1b32:	9e e0       	ldi	r25, 0x0E	; 14
    1b34:	95 83       	std	Z+5, r25	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1728
      // This is WAY conservative! We could drop it down...
      pADC->CTRLD = ADC_INITDLY_DLY64_gc; // VREF can take 50uS to become ready, and we're running the ADC clock
    1b36:	90 e6       	ldi	r25, 0x60	; 96
    1b38:	93 83       	std	Z+3, r25	; 0x03
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1731
      // at around 1 MHz, so we want 64 ADC clocks when we start up a new reference so we don't get bad readings at first
      /* Enable ADC */
      pADC->CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc;
    1b3a:	80 83       	st	Z, r24
analogReference():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:590
  *****************************************************/

void analogReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.ADC0REF = (VREF.ADC0REF & ~(VREF_REFSEL_gm))|(mode);
    1b3c:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
    1b40:	88 7f       	andi	r24, 0xF8	; 248
    1b42:	85 60       	ori	r24, 0x05	; 5
    1b44:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
DACReference():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:133
#endif

#ifdef DAC0
  void DACReference(uint8_t mode) {
    check_valid_analog_ref(mode);
    VREF.DAC0REF = mode | (VREF.DAC0REF & (~VREF_REFSEL_gm));
    1b48:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
    1b4c:	88 7f       	andi	r24, 0xF8	; 248
    1b4e:	85 60       	ori	r24, 0x05	; 5
    1b50:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
init_millis():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1623
        #endif
        RTC.INTCTRL         = 0x01; // enable overflow interrupt
        RTC.CTRLA           = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
      */
    #else // It's a type b timer - we have already errored out if that wasn't defined
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
    1b54:	8f ed       	ldi	r24, 0xDF	; 223
    1b56:	9e e2       	ldi	r25, 0x2E	; 46
    1b58:	80 93 2c 0b 	sts	0x0B2C, r24	; 0x800b2c <__TEXT_REGION_LENGTH__+0x7e0b2c>
    1b5c:	90 93 2d 0b 	sts	0x0B2D, r25	; 0x800b2d <__TEXT_REGION_LENGTH__+0x7e0b2d>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1625
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
    1b60:	30 93 25 0b 	sts	0x0B25, r19	; 0x800b25 <__TEXT_REGION_LENGTH__+0x7e0b25>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1627
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
    1b64:	10 92 21 0b 	sts	0x0B21, r1	; 0x800b21 <__TEXT_REGION_LENGTH__+0x7e0b21>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1629
      // CLK_PER/1 is 0b00, . CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
    1b68:	20 93 20 0b 	sts	0x0B20, r18	; 0x800b20 <__TEXT_REGION_LENGTH__+0x7e0b20>
main():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:95
 * just waiting for the DU-series now                                                           */
int main() {
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
    1b6c:	78 94       	sei
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:96
  setup();
    1b6e:	0e 94 2e 02 	call	0x45c	; 0x45c <setup>
    1b72:	ff cf       	rjmp	.-2      	; 0x1b72 <main+0xc2>

00001b74 <_GLOBAL__sub_I___vector_23>:
_ZN5PrintC2Ev():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:42
  protected:
    void setWriteError(int err = 1) {
      write_error = err;
    }
  public:
    Print() : write_error(0) {}
    1b74:	e8 ec       	ldi	r30, 0xC8	; 200
    1b76:	f2 e4       	ldi	r31, 0x42	; 66
    1b78:	12 82       	std	Z+2, r1	; 0x02
    1b7a:	13 82       	std	Z+3, r1	; 0x03
_ZN6StreamC2Ev():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Stream.h:63
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {
      _timeout = 1000;
    1b7c:	88 ee       	ldi	r24, 0xE8	; 232
    1b7e:	93 e0       	ldi	r25, 0x03	; 3
    1b80:	a0 e0       	ldi	r26, 0x00	; 0
    1b82:	b0 e0       	ldi	r27, 0x00	; 0
    1b84:	84 83       	std	Z+4, r24	; 0x04
    1b86:	95 83       	std	Z+5, r25	; 0x05
    1b88:	a6 83       	std	Z+6, r26	; 0x06
    1b8a:	b7 83       	std	Z+7, r27	; 0x07
_ZN14HardwareSerialC2EPV12USART_structPhhh():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART_private.h:20
#if defined(USART0) || defined(USART1) || defined(USART2) || defined(USART3) || defined(USART4) || defined(USART5)

// Constructor
// no need to set the other variables to zero, init script already does that. Saves some flash
HardwareSerial::HardwareSerial(volatile USART_t *hwserial_module, uint8_t *usart_pins, uint8_t mux_count, uint8_t mux_default) :
    _hwserial_module(hwserial_module), _usart_pins(usart_pins), _mux_count(mux_count), _pin_set(mux_default) {
    1b8c:	89 e4       	ldi	r24, 0x49	; 73
    1b8e:	90 e4       	ldi	r25, 0x40	; 64
    1b90:	80 83       	st	Z, r24
    1b92:	91 83       	std	Z+1, r25	; 0x01
    1b94:	80 e0       	ldi	r24, 0x00	; 0
    1b96:	98 e0       	ldi	r25, 0x08	; 8
    1b98:	80 87       	std	Z+8, r24	; 0x08
    1b9a:	91 87       	std	Z+9, r25	; 0x09
    1b9c:	88 ea       	ldi	r24, 0xA8	; 168
    1b9e:	90 e0       	ldi	r25, 0x00	; 0
    1ba0:	82 87       	std	Z+10, r24	; 0x0a
    1ba2:	93 87       	std	Z+11, r25	; 0x0b
    1ba4:	82 e0       	ldi	r24, 0x02	; 2
    1ba6:	84 87       	std	Z+12, r24	; 0x0c
    1ba8:	15 86       	std	Z+13, r1	; 0x0d
    1baa:	16 86       	std	Z+14, r1	; 0x0e
_GLOBAL__sub_I___vector_23():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:130
#endif
                ::"z"(&Serial0));
      __builtin_unreachable();
    }
  #endif
  HardwareSerial Serial0(&USART0, (uint8_t*)_usart0_pins, MUXCOUNT_USART0, HWSERIAL0_MUX_DEFAULT);
    1bac:	08 95       	ret

00001bae <__udivmodsi4>:
__udivmodsi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    1bae:	a1 e2       	ldi	r26, 0x21	; 33
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    1bb0:	1a 2e       	mov	r1, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    1bb2:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    1bb4:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    1bb6:	fd 01       	movw	r30, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    1bb8:	0d c0       	rjmp	.+26     	; 0x1bd4 <__udivmodsi4_ep>

00001bba <__udivmodsi4_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    1bba:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    1bbc:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    1bbe:	ee 1f       	adc	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    1bc0:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    1bc2:	a2 17       	cp	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    1bc4:	b3 07       	cpc	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    1bc6:	e4 07       	cpc	r30, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    1bc8:	f5 07       	cpc	r31, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    1bca:	20 f0       	brcs	.+8      	; 0x1bd4 <__udivmodsi4_ep>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    1bcc:	a2 1b       	sub	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    1bce:	b3 0b       	sbc	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    1bd0:	e4 0b       	sbc	r30, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    1bd2:	f5 0b       	sbc	r31, r21

00001bd4 <__udivmodsi4_ep>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    1bd4:	66 1f       	adc	r22, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    1bd6:	77 1f       	adc	r23, r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    1bd8:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    1bda:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    1bdc:	1a 94       	dec	r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    1bde:	69 f7       	brne	.-38     	; 0x1bba <__udivmodsi4_loop>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    1be0:	60 95       	com	r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    1be2:	70 95       	com	r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    1be4:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    1be6:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    1be8:	9b 01       	movw	r18, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    1bea:	ac 01       	movw	r20, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    1bec:	bd 01       	movw	r22, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    1bee:	cf 01       	movw	r24, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    1bf0:	08 95       	ret

00001bf2 <__muluhisi3>:
__muluhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    1bf2:	12 d0       	rcall	.+36     	; 0x1c18 <__umulhisi3>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    1bf4:	a5 9f       	mul	r26, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    1bf6:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    1bf8:	b4 9f       	mul	r27, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    1bfa:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    1bfc:	a4 9f       	mul	r26, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    1bfe:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    1c00:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    1c02:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    1c04:	08 95       	ret

00001c06 <__tablejump2__>:
__tablejump2__():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    1c06:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    1c08:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2304
    1c0a:	00 24       	eor	r0, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2305
    1c0c:	00 1c       	adc	r0, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2306
    1c0e:	0b be       	out	0x3b, r0	; 59
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2312
    1c10:	07 90       	elpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2313
    1c12:	f6 91       	elpm	r31, Z
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2314
    1c14:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2319
    1c16:	09 94       	ijmp

00001c18 <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    1c18:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    1c1a:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    1c1c:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    1c1e:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    1c20:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    1c22:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    1c24:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    1c26:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    1c28:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    1c2a:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    1c2c:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    1c2e:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    1c30:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    1c32:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    1c34:	08 95       	ret

00001c36 <_exit>:
exit():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    1c36:	f8 94       	cli

00001c38 <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    1c38:	ff cf       	rjmp	.-2      	; 0x1c38 <__stop_program>
