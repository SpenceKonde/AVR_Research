
C:\Users\Spence\AppData\Local\Temp\arduino_build_434784/rngBetterTest.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
       0:  59 c0         rjmp  .+178      ; 0xb4 <__ctors_end>
       2:  00 00         nop
       4:  95 c0         rjmp  .+298      ; 0x130 <__bad_interrupt>
       6:  00 00         nop
       8:  93 c0         rjmp  .+294      ; 0x130 <__bad_interrupt>
       a:  00 00         nop
       c:  91 c0         rjmp  .+290      ; 0x130 <__bad_interrupt>
       e:  00 00         nop
      10:  8f c0         rjmp  .+286      ; 0x130 <__bad_interrupt>
      12:  00 00         nop
      14:  8d c0         rjmp  .+282      ; 0x130 <__bad_interrupt>
      16:  00 00         nop
      18:  8b c0         rjmp  .+278      ; 0x130 <__bad_interrupt>
      1a:  00 00         nop
      1c:  89 c0         rjmp  .+274      ; 0x130 <__bad_interrupt>
      1e:  00 00         nop
      20:  87 c0         rjmp  .+270      ; 0x130 <__bad_interrupt>
      22:  00 00         nop
      24:  85 c0         rjmp  .+266      ; 0x130 <__bad_interrupt>
      26:  00 00         nop
      28:  83 c0         rjmp  .+262      ; 0x130 <__bad_interrupt>
      2a:  00 00         nop
      2c:  81 c0         rjmp  .+258      ; 0x130 <__bad_interrupt>
      2e:  00 00         nop
      30:  7f c0         rjmp  .+254      ; 0x130 <__bad_interrupt>
      32:  00 00         nop
      34:  7d c0         rjmp  .+250      ; 0x130 <__bad_interrupt>
      36:  00 00         nop
      38:  7b c0         rjmp  .+246      ; 0x130 <__bad_interrupt>
      3a:  00 00         nop
      3c:  79 c0         rjmp  .+242      ; 0x130 <__bad_interrupt>
      3e:  00 00         nop
      40:  77 c0         rjmp  .+238      ; 0x130 <__bad_interrupt>
      42:  00 00         nop
      44:  75 c0         rjmp  .+234      ; 0x130 <__bad_interrupt>
      46:  00 00         nop
      48:  73 c0         rjmp  .+230      ; 0x130 <__bad_interrupt>
      4a:  00 00         nop
      4c:  71 c0         rjmp  .+226      ; 0x130 <__bad_interrupt>
      4e:  00 00         nop
      50:  6f c0         rjmp  .+222      ; 0x130 <__bad_interrupt>
      52:  00 00         nop
      54:  0c 94 b9 0c   jmp  0x1972  ; 0x1972 <__vector_21>
      58:  0c 94 b3 0c   jmp  0x1966  ; 0x1966 <__vector_22>
      5c:  0c 94 bf 0c   jmp  0x197e  ; 0x197e <__vector_23>
      60:  67 c0         rjmp  .+206      ; 0x130 <__bad_interrupt>
      62:  00 00         nop
      64:  65 c0         rjmp  .+202      ; 0x130 <__bad_interrupt>
      66:  00 00         nop
      68:  63 c0         rjmp  .+198      ; 0x130 <__bad_interrupt>
      6a:  00 00         nop
      6c:  61 c0         rjmp  .+194      ; 0x130 <__bad_interrupt>
      6e:  00 00         nop
      70:  5f c0         rjmp  .+190      ; 0x130 <__bad_interrupt>
      72:  00 00         nop
      74:  5d c0         rjmp  .+186      ; 0x130 <__bad_interrupt>
      76:  00 00         nop
      78:  5b c0         rjmp  .+182      ; 0x130 <__bad_interrupt>
      7a:  00 00         nop
      7c:  0c 94 3c 0d   jmp  0x1a78  ; 0x1a78 <__vector_31>
      80:  57 c0         rjmp  .+174      ; 0x130 <__bad_interrupt>
      82:  00 00         nop
      84:  55 c0         rjmp  .+170      ; 0x130 <__bad_interrupt>
      86:  00 00         nop
      88:  53 c0         rjmp  .+166      ; 0x130 <__bad_interrupt>
      8a:  00 00         nop
      8c:  51 c0         rjmp  .+162      ; 0x130 <__bad_interrupt>
      8e:  00 00         nop
      90:  4f c0         rjmp  .+158      ; 0x130 <__bad_interrupt>
      92:  00 00         nop
      94:  4d c0         rjmp  .+154      ; 0x130 <__bad_interrupt>
      96:  00 00         nop
      98:  4b c0         rjmp  .+150      ; 0x130 <__bad_interrupt>
      9a:  00 00         nop
      9c:  49 c0         rjmp  .+146      ; 0x130 <__bad_interrupt>
      9e:  00 00         nop
      a0:  47 c0         rjmp  .+142      ; 0x130 <__bad_interrupt>
      a2:  00 00         nop
      a4:  45 c0         rjmp  .+138      ; 0x130 <__bad_interrupt>
  ...

000000a8 <__trampolines_end>:
__trampolines_start():
      a8:  00 00         nop
      aa:  02 01         movw  r0, r4
      ac:  04 06         cpc  r0, r20
      ae:  03 00         .word  0x0003  ; ????
      b0:  03 00         .word  0x0003  ; ????

000000b2 <__ctors_start>:
__ctors_start():
      b2:  ba 0d         add  r27, r10

000000b4 <__ctors_end>:
__dtors_end():
      b4:  11 24         eor  r1, r1
      b6:  1f be         out  0x3f, r1  ; 63
      b8:  cf ef         ldi  r28, 0xFF  ; 255
      ba:  cd bf         out  0x3d, r28  ; 61
      bc:  df e7         ldi  r29, 0x7F  ; 127
      be:  de bf         out  0x3e, r29  ; 62

000000c0 <_initThreeStuff()>:
init_reset_flags():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:146

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
      c0:  80 91 40 00   lds  r24, 0x0040  ; 0x800040 <__TEXT_REGION_LENGTH__+0x7e0040>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:147
    RSTCTRL.RSTFR = flags;
      c4:  80 93 40 00   sts  0x0040, r24  ; 0x800040 <__TEXT_REGION_LENGTH__+0x7e0040>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:148
    if (flags == 0) {
      c8:  81 11         cpse  r24, r1
      ca:  05 c0         rjmp  .+10       ; 0xd6 <_initThreeStuff()+0x16>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:149
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
      cc:  98 ed         ldi  r25, 0xD8  ; 216
      ce:  21 e0         ldi  r18, 0x01  ; 1
      d0:  94 bf         out  0x34, r25  ; 52
      d2:  20 93 41 00   sts  0x0041, r18  ; 0x800041 <__TEXT_REGION_LENGTH__+0x7e0041>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:151
    }
    GPIOR0 = flags;
      d6:  8c bb         out  0x1c, r24  ; 28
doFLMAP():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:74
      #pragma message("PROGMEM_MAPPED points to section 0 of the flash")
    #else
      #warning "no FLMAP section defined, yet LOCK_FLMAP IS!"
      temp = 0x30; // should always end up as the highest up to 3.
    #endif
    NVMCTRL.CTRLB = temp;
      d8:  80 e3         ldi  r24, 0x30  ; 48
      da:  80 93 01 10   sts  0x1001, r24  ; 0x801001 <__TEXT_REGION_LENGTH__+0x7e1001>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:76
    temp |= 0x80;
    _PROTECTED_WRITE(NVMCTRL_CTRLB, temp);
      de:  88 ed         ldi  r24, 0xD8  ; 216
      e0:  90 eb         ldi  r25, 0xB0  ; 176
      e2:  84 bf         out  0x34, r24  ; 52
      e4:  90 93 01 10   sts  0x1001, r25  ; 0x801001 <__TEXT_REGION_LENGTH__+0x7e1001>

000000e8 <__do_copy_data>:
__do_copy_data():
      e8:  12 e4         ldi  r17, 0x42  ; 66
      ea:  a0 e0         ldi  r26, 0x00  ; 0
      ec:  b0 e4         ldi  r27, 0x40  ; 64
      ee:  ea e3         ldi  r30, 0x3A  ; 58
      f0:  fc e1         ldi  r31, 0x1C  ; 28
      f2:  00 e0         ldi  r16, 0x00  ; 0
      f4:  0b bf         out  0x3b, r16  ; 59
      f6:  02 c0         rjmp  .+4        ; 0xfc <__do_copy_data+0x14>
      f8:  07 90         elpm  r0, Z+
      fa:  0d 92         st  X+, r0
      fc:  ac 34         cpi  r26, 0x4C  ; 76
      fe:  b1 07         cpc  r27, r17
     100:  d9 f7         brne  .-10       ; 0xf8 <__do_copy_data+0x10>

00000102 <__do_clear_bss>:
__do_clear_bss():
     102:  23 e4         ldi  r18, 0x43  ; 67
     104:  ac e4         ldi  r26, 0x4C  ; 76
     106:  b2 e4         ldi  r27, 0x42  ; 66
     108:  01 c0         rjmp  .+2        ; 0x10c <.do_clear_bss_start>

0000010a <.do_clear_bss_loop>:
     10a:  1d 92         st  X+, r1

0000010c <.do_clear_bss_start>:
     10c:  ab 35         cpi  r26, 0x5B  ; 91
     10e:  b2 07         cpc  r27, r18
     110:  e1 f7         brne  .-8        ; 0x10a <.do_clear_bss_loop>

00000112 <__do_global_ctors>:
__do_global_ctors():
     112:  10 e0         ldi  r17, 0x00  ; 0
     114:  ca e5         ldi  r28, 0x5A  ; 90
     116:  d0 e0         ldi  r29, 0x00  ; 0
     118:  04 c0         rjmp  .+8        ; 0x122 <__do_global_ctors+0x10>
     11a:  21 97         sbiw  r28, 0x01  ; 1
     11c:  fe 01         movw  r30, r28
     11e:  0e 94 03 0e   call  0x1c06  ; 0x1c06 <__tablejump2__>
     122:  c9 35         cpi  r28, 0x59  ; 89
     124:  d1 07         cpc  r29, r17
     126:  c9 f7         brne  .-14       ; 0x11a <__do_global_ctors+0x8>
     128:  0e 94 58 0d   call  0x1ab0  ; 0x1ab0 <main>
     12c:  0c 94 1b 0e   jmp  0x1c36  ; 0x1c36 <_exit>

00000130 <__bad_interrupt>:
__vector_38():
     130:  67 cf         rjmp  .-306      ; 0x0 <__vectors>

00000132 <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
     132:  af 92         push  r10
     134:  bf 92         push  r11
     136:  cf 92         push  r12
     138:  df 92         push  r13
     13a:  ef 92         push  r14
     13c:  ff 92         push  r15
     13e:  0f 93         push  r16
     140:  1f 93         push  r17
     142:  cf 93         push  r28
     144:  df 93         push  r29
     146:  6c 01         movw  r12, r24
     148:  7b 01         movw  r14, r22
     14a:  8b 01         movw  r16, r22
     14c:  04 0f         add  r16, r20
     14e:  15 1f         adc  r17, r21
     150:  eb 01         movw  r28, r22
     152:  5e 01         movw  r10, r28
     154:  ae 18         sub  r10, r14
     156:  bf 08         sbc  r11, r15
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     158:  c0 17         cp  r28, r16
     15a:  d1 07         cpc  r29, r17
     15c:  59 f0         breq  .+22       ; 0x174 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:32
    if (write(*buffer++)) {
     15e:  69 91         ld  r22, Y+
     160:  d6 01         movw  r26, r12
     162:  ed 91         ld  r30, X+
     164:  fc 91         ld  r31, X
     166:  01 90         ld  r0, Z+
     168:  f0 81         ld  r31, Z
     16a:  e0 2d         mov  r30, r0
     16c:  c6 01         movw  r24, r12
     16e:  09 95         icall
     170:  89 2b         or  r24, r25
     172:  79 f7         brne  .-34       ; 0x152 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     174:  c5 01         movw  r24, r10
     176:  df 91         pop  r29
     178:  cf 91         pop  r28
     17a:  1f 91         pop  r17
     17c:  0f 91         pop  r16
     17e:  ff 90         pop  r15
     180:  ef 90         pop  r14
     182:  df 90         pop  r13
     184:  cf 90         pop  r12
     186:  bf 90         pop  r11
     188:  af 90         pop  r10
     18a:  08 95         ret

0000018c <HardwareSerial::availableForWrite()>:
availableForWrite():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:727
      int HardwareSerial::availableForWrite(void) {
        tx_buffer_index_t head;
        tx_buffer_index_t tail;

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
     18c:  fc 01         movw  r30, r24
     18e:  51 89         ldd  r21, Z+17  ; 0x11
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:728
          tail = _tx_buffer_tail;
     190:  42 89         ldd  r20, Z+18  ; 0x12
     192:  25 2f         mov  r18, r21
     194:  30 e0         ldi  r19, 0x00  ; 0
     196:  84 2f         mov  r24, r20
     198:  90 e0         ldi  r25, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:731
        }
        if (head >= tail) {
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     19a:  82 1b         sub  r24, r18
     19c:  93 0b         sbc  r25, r19
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:730

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
          tail = _tx_buffer_tail;
        }
        if (head >= tail) {
     19e:  54 17         cp  r21, r20
     1a0:  10 f0         brcs  .+4        ; 0x1a6 <HardwareSerial::availableForWrite()+0x1a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:731
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     1a2:  cf 96         adiw  r24, 0x3f  ; 63
     1a4:  08 95         ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:733
        }
        return tail - head - 1;
     1a6:  01 97         sbiw  r24, 0x01  ; 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:734
      }
     1a8:  08 95         ret

000001aa <HardwareSerial::read()>:
read():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:711
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }

    int HardwareSerial::read(void) {
     1aa:  fc 01         movw  r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:713
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
     1ac:  97 85         ldd  r25, Z+15  ; 0x0f
     1ae:  80 89         ldd  r24, Z+16  ; 0x10
     1b0:  98 17         cp  r25, r24
     1b2:  61 f0         breq  .+24       ; 0x1cc <HardwareSerial::read()+0x22>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:716
        return -1;
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
     1b4:  a0 89         ldd  r26, Z+16  ; 0x10
     1b6:  ae 0f         add  r26, r30
     1b8:  bf 2f         mov  r27, r31
     1ba:  b1 1d         adc  r27, r1
     1bc:  53 96         adiw  r26, 0x13  ; 19
     1be:  8c 91         ld  r24, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:717
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
     1c0:  90 89         ldd  r25, Z+16  ; 0x10
     1c2:  9f 5f         subi  r25, 0xFF  ; 255
     1c4:  9f 73         andi  r25, 0x3F  ; 63
     1c6:  90 8b         std  Z+16, r25  ; 0x10
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:718
        return c;
     1c8:  90 e0         ldi  r25, 0x00  ; 0
     1ca:  08 95         ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:714
    }

    int HardwareSerial::read(void) {
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
     1cc:  8f ef         ldi  r24, 0xFF  ; 255
     1ce:  9f ef         ldi  r25, 0xFF  ; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:720
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
        return c;
      }
    }
     1d0:  08 95         ret

000001d2 <HardwareSerial::peek()>:
peek():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:703

    int HardwareSerial::available(void) {
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
     1d2:  fc 01         movw  r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:704
      if (_rx_buffer_head == _rx_buffer_tail) {
     1d4:  97 85         ldd  r25, Z+15  ; 0x0f
     1d6:  80 89         ldd  r24, Z+16  ; 0x10
     1d8:  98 17         cp  r25, r24
     1da:  31 f0         breq  .+12       ; 0x1e8 <HardwareSerial::peek()+0x16>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:707
        return -1;
      } else {
        return _rx_buffer[_rx_buffer_tail];
     1dc:  80 89         ldd  r24, Z+16  ; 0x10
     1de:  e8 0f         add  r30, r24
     1e0:  f1 1d         adc  r31, r1
     1e2:  83 89         ldd  r24, Z+19  ; 0x13
     1e4:  90 e0         ldi  r25, 0x00  ; 0
     1e6:  08 95         ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:705
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
     1e8:  8f ef         ldi  r24, 0xFF  ; 255
     1ea:  9f ef         ldi  r25, 0xFF  ; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:709
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }
     1ec:  08 95         ret

000001ee <HardwareSerial::available()>:
available():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:699
      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
    }

    int HardwareSerial::available(void) {
     1ee:  fc 01         movw  r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:700
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
     1f0:  97 85         ldd  r25, Z+15  ; 0x0f
     1f2:  20 89         ldd  r18, Z+16  ; 0x10
     1f4:  89 2f         mov  r24, r25
     1f6:  90 e0         ldi  r25, 0x00  ; 0
     1f8:  80 5c         subi  r24, 0xC0  ; 192
     1fa:  9f 4f         sbci  r25, 0xFF  ; 255
     1fc:  82 1b         sub  r24, r18
     1fe:  91 09         sbc  r25, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:701
    }
     200:  8f 73         andi  r24, 0x3F  ; 63
     202:  99 27         eor  r25, r25
     204:  08 95         ret

00000206 <HardwareSerial::_poll_tx_data_empty()>:
_poll_tx_data_empty():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:426
        HardwareSerial._tx_buffer_tail = txTail;
      }
    #endif

    // To invoke data empty "interrupt" via a call, use this method
    void HardwareSerial::_poll_tx_data_empty(void) {
     206:  fc 01         movw  r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:427
      if ((!(SREG & CPU_I_bm)) ||  CPUINT.STATUS) {
     208:  0f b6         in  r0, 0x3f  ; 63
     20a:  07 fe         sbrs  r0, 7
     20c:  04 c0         rjmp  .+8        ; 0x216 <HardwareSerial::_poll_tx_data_empty()+0x10>
     20e:  80 91 11 01   lds  r24, 0x0111  ; 0x800111 <__TEXT_REGION_LENGTH__+0x7e0111>
     212:  88 23         and  r24, r24
     214:  a9 f0         breq  .+42       ; 0x240 <_poll_dre_done>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:444
        // so we'll have to poll the "data register empty" flag ourselves.
        // If it is set, pretend an interrupt has happened and call the handler
        // to free up space for us.
        // -Spence 10/23/20
        // Invoke interrupt handler only if conditions data register is empty
        if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     216:  a0 85         ldd  r26, Z+8  ; 0x08
     218:  b1 85         ldd  r27, Z+9  ; 0x09
     21a:  14 96         adiw  r26, 0x04  ; 4
     21c:  8c 91         ld  r24, X
     21e:  14 97         sbiw  r26, 0x04  ; 4
     220:  85 ff         sbrs  r24, 5
     222:  0e c0         rjmp  .+28       ; 0x240 <_poll_dre_done>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:445
          if (_tx_buffer_head == _tx_buffer_tail) {
     224:  91 89         ldd  r25, Z+17  ; 0x11
     226:  82 89         ldd  r24, Z+18  ; 0x12
     228:  98 13         cpse  r25, r24
     22a:  07 c0         rjmp  .+14       ; 0x23a <HardwareSerial::_poll_tx_data_empty()+0x34>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:447
            // Buffer empty, so disable "data register empty" interrupt
            (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     22c:  15 96         adiw  r26, 0x05  ; 5
     22e:  8c 91         ld  r24, X
     230:  15 97         sbiw  r26, 0x05  ; 5
     232:  8f 7d         andi  r24, 0xDF  ; 223
     234:  15 96         adiw  r26, 0x05  ; 5
     236:  8c 93         st  X, r24
     238:  08 95         ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:465
      #else
                    "rjmp _poll_dre"    "\n\t"
      #endif
                    "_poll_dre_done:"    "\n"
                    ::"z"((uint16_t)thisSerial)
                    : "r18","r19","r24","r25","r26","r27"); // these got saved and restored in the ISR context, but here we don't need top and in many cases no action is needed.
     23a:  e8 94         clt
     23c:  0c 94 cc 0c   jmp  0x1998  ; 0x1998 <_poll_dre>

00000240 <_poll_dre_done>:
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:474
        }
      }
      // In case interrupts are enabled, the interrupt routine will be invoked by itself
      // Note that this currently does not handle cases where the DRE interruopt becomes
      // disabled, yet you are actually attempting to send. I don't think it can happen.
    }
     240:  08 95         ret

00000242 <HardwareSerial::write(unsigned char)>:
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:767
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }


      size_t HardwareSerial::write(uint8_t c) {
     242:  0f 93         push  r16
     244:  1f 93         push  r17
     246:  cf 93         push  r28
     248:  df 93         push  r29
     24a:  ec 01         movw  r28, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:768
        _state |= 1; // Record that we have written to serial since it was begun.
     24c:  8e 85         ldd  r24, Y+14  ; 0x0e
     24e:  81 60         ori  r24, 0x01  ; 1
     250:  8e 87         std  Y+14, r24  ; 0x0e
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:773
        // If the buffer and the data register is empty, just write the byte
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
     252:  99 89         ldd  r25, Y+17  ; 0x11
     254:  8a 89         ldd  r24, Y+18  ; 0x12
     256:  98 13         cpse  r25, r24
     258:  0b c0         rjmp  .+22       ; 0x270 <HardwareSerial::write(unsigned char)+0x2e>
     25a:  e8 85         ldd  r30, Y+8  ; 0x08
     25c:  f9 85         ldd  r31, Y+9  ; 0x09
     25e:  84 81         ldd  r24, Z+4  ; 0x04
     260:  85 ff         sbrs  r24, 5
     262:  06 c0         rjmp  .+12       ; 0x270 <HardwareSerial::write(unsigned char)+0x2e>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:774
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     264:  8e 85         ldd  r24, Y+14  ; 0x0e
     266:  81 fd         sbrc  r24, 1
     268:  0d c0         rjmp  .+26       ; 0x284 <HardwareSerial::write(unsigned char)+0x42>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:781
            ctrla &= ~USART_RXCIE_bm;
            ctrla |=  USART_TXCIE_bm;
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
            (*_hwserial_module).CTRLA = ctrla;
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
     26a:  80 e4         ldi  r24, 0x40  ; 64
     26c:  84 83         std  Z+4, r24  ; 0x04
     26e:  12 c0         rjmp  .+36       ; 0x294 <HardwareSerial::write(unsigned char)+0x52>
     270:  06 2f         mov  r16, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:802
           * // that the interrupt handler is called in this situation
           * (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
           */
          return 1;
        }
        tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  // % SERIAL_TX_BUFFER_SIZE;
     272:  19 89         ldd  r17, Y+17  ; 0x11
     274:  1f 5f         subi  r17, 0xFF  ; 255
     276:  1f 73         andi  r17, 0x3F  ; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:806

        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
     278:  8a 89         ldd  r24, Y+18  ; 0x12
     27a:  81 13         cpse  r24, r17
     27c:  15 c0         rjmp  .+42       ; 0x2a8 <HardwareSerial::write(unsigned char)+0x66>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:807
          _poll_tx_data_empty();
     27e:  ce 01         movw  r24, r28
     280:  c2 df         rcall  .-124      ; 0x206 <HardwareSerial::_poll_tx_data_empty()>
     282:  fa cf         rjmp  .-12       ; 0x278 <HardwareSerial::write(unsigned char)+0x36>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:775
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
            uint8_t ctrla = (*_hwserial_module).CTRLA;
     284:  85 81         ldd  r24, Z+5  ; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:776
            ctrla &= ~USART_RXCIE_bm;
     286:  8f 77         andi  r24, 0x7F  ; 127
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:777
            ctrla |=  USART_TXCIE_bm;
     288:  80 64         ori  r24, 0x40  ; 64
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:778
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
     28a:  90 e4         ldi  r25, 0x40  ; 64
     28c:  94 83         std  Z+4, r25  ; 0x04
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:779
            (*_hwserial_module).CTRLA = ctrla;
     28e:  e8 85         ldd  r30, Y+8  ; 0x08
     290:  f9 85         ldd  r31, Y+9  ; 0x09
     292:  85 83         std  Z+5, r24  ; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:784
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
          }
          // MUST clear TXCIF **before** writing new char, otherwise ill-timed interrupt can cause it to erase the flag after the new charchter has been sent!
          (*_hwserial_module).TXDATAL = c;
     294:  e8 85         ldd  r30, Y+8  ; 0x08
     296:  f9 85         ldd  r31, Y+9  ; 0x09
     298:  62 83         std  Z+2, r22  ; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:822
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
        }
        return 1;
      }
     29a:  81 e0         ldi  r24, 0x01  ; 1
     29c:  90 e0         ldi  r25, 0x00  ; 0
     29e:  df 91         pop  r29
     2a0:  cf 91         pop  r28
     2a2:  1f 91         pop  r17
     2a4:  0f 91         pop  r16
     2a6:  08 95         ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:809
        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
          _poll_tx_data_empty();
        }
        _tx_buffer[_tx_buffer_head] = c;
     2a8:  e9 89         ldd  r30, Y+17  ; 0x11
     2aa:  ec 0f         add  r30, r28
     2ac:  fd 2f         mov  r31, r29
     2ae:  f1 1d         adc  r31, r1
     2b0:  ed 5a         subi  r30, 0xAD  ; 173
     2b2:  ff 4f         sbci  r31, 0xFF  ; 255
     2b4:  00 83         st  Z, r16
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:810
        _tx_buffer_head = i;
     2b6:  19 8b         std  Y+17, r17  ; 0x11
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:811
        if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     2b8:  8e 85         ldd  r24, Y+14  ; 0x0e
     2ba:  e8 85         ldd  r30, Y+8  ; 0x08
     2bc:  f9 85         ldd  r31, Y+9  ; 0x09
     2be:  81 ff         sbrs  r24, 1
     2c0:  09 c0         rjmp  .+18       ; 0x2d4 <HardwareSerial::write(unsigned char)+0x92>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:812
          uint8_t ctrla = (*_hwserial_module).CTRLA;
     2c2:  85 81         ldd  r24, Z+5  ; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:813
          ctrla &= ~USART_RXCIE_bm;
     2c4:  8f 77         andi  r24, 0x7F  ; 127
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:814
          ctrla |= USART_TXCIE_bm | USART_DREIE_bm;
     2c6:  80 66         ori  r24, 0x60  ; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:815
          (*_hwserial_module).STATUS = USART_TXCIF_bm;
     2c8:  90 e4         ldi  r25, 0x40  ; 64
     2ca:  94 83         std  Z+4, r25  ; 0x04
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:816
          (*_hwserial_module).CTRLA = ctrla;
     2cc:  e8 85         ldd  r30, Y+8  ; 0x08
     2ce:  f9 85         ldd  r31, Y+9  ; 0x09
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:819
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     2d0:  85 83         std  Z+5, r24  ; 0x05
     2d2:  e3 cf         rjmp  .-58       ; 0x29a <HardwareSerial::write(unsigned char)+0x58>
     2d4:  85 81         ldd  r24, Z+5  ; 0x05
     2d6:  80 62         ori  r24, 0x20  ; 32
     2d8:  fb cf         rjmp  .-10       ; 0x2d0 <HardwareSerial::write(unsigned char)+0x8e>

000002da <HardwareSerial::printHex(unsigned char) [clone .constprop.19]>:
printHex():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:824
        }
        return 1;
      }

      void HardwareSerial::printHex(const uint8_t b) {
     2da:  cf 93         push  r28
     2dc:  c8 2f         mov  r28, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:825
        char x = (b >> 4) | '0';
     2de:  68 2f         mov  r22, r24
     2e0:  62 95         swap  r22
     2e2:  6f 70         andi  r22, 0x0F  ; 15
     2e4:  60 63         ori  r22, 0x30  ; 48
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:826
        if (x > '9')
     2e6:  6a 33         cpi  r22, 0x3A  ; 58
     2e8:  0c f0         brlt  .+2        ; 0x2ec <HardwareSerial::printHex(unsigned char) [clone .constprop.19]+0x12>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:827
          x += 7;
     2ea:  69 5f         subi  r22, 0xF9  ; 249
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/HardwareSerial.h:298
    virtual    void flush(void);
    virtual  size_t write(uint8_t ch);
    inline   size_t write(unsigned long n)  {return write((uint8_t)n);}
    inline   size_t write(long n)           {return write((uint8_t)n);}
    inline   size_t write(unsigned int n)   {return write((uint8_t)n);}
    inline   size_t write(int n)            {return write((uint8_t)n);}
     2ec:  88 ec         ldi  r24, 0xC8  ; 200
     2ee:  92 e4         ldi  r25, 0x42  ; 66
     2f0:  a8 df         rcall  .-176      ; 0x242 <HardwareSerial::write(unsigned char)>
printHex():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:829
        write(x);
        x = (b & 0x0F) | '0';
     2f2:  6c 2f         mov  r22, r28
     2f4:  6f 70         andi  r22, 0x0F  ; 15
     2f6:  60 63         ori  r22, 0x30  ; 48
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:830
        if (x > '9')
     2f8:  6a 33         cpi  r22, 0x3A  ; 58
     2fa:  08 f0         brcs  .+2        ; 0x2fe <HardwareSerial::printHex(unsigned char) [clone .constprop.19]+0x24>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:831
          x += 7;
     2fc:  69 5f         subi  r22, 0xF9  ; 249
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/HardwareSerial.h:298
     2fe:  88 ec         ldi  r24, 0xC8  ; 200
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:833
        write(x);
      }
     300:  92 e4         ldi  r25, 0x42  ; 66
printHex():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/HardwareSerial.h:298
     302:  cf 91         pop  r28
write():
     304:  9e cf         rjmp  .-196      ; 0x242 <HardwareSerial::write(unsigned char)>

00000306 <HardwareSerial::flush()>:
flush():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:736
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
        }
        return tail - head - 1;
      }

      void HardwareSerial::flush() {
     306:  cf 93         push  r28
     308:  df 93         push  r29
     30a:  ec 01         movw  r28, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:740
        // If we have never written a byte, no need to flush. This special
        // case is needed since there is no way to force the TXCIF (transmit
        // complete) bit to 1 during initialization
        if (!_state & 1) {
     30c:  8e 85         ldd  r24, Y+14  ; 0x0e
     30e:  88 23         and  r24, r24
     310:  59 f0         breq  .+22       ; 0x328 <HardwareSerial::flush()+0x22>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:755
        // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
        // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
        // and in that case flush(), and write() with full buffer would just straight up hang...

        // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
        while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
     312:  e8 85         ldd  r30, Y+8  ; 0x08
     314:  f9 85         ldd  r31, Y+9  ; 0x09
     316:  85 81         ldd  r24, Z+5  ; 0x05
     318:  85 fd         sbrc  r24, 5
     31a:  03 c0         rjmp  .+6        ; 0x322 <HardwareSerial::flush()+0x1c>
     31c:  84 81         ldd  r24, Z+4  ; 0x04
     31e:  86 fd         sbrc  r24, 6
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:760

          // If interrupts are globally disabled or the and DR empty interrupt is disabled,
          // poll the "data register empty" interrupt flag to prevent deadlock

          _poll_tx_data_empty();
     320:  03 c0         rjmp  .+6        ; 0x328 <HardwareSerial::flush()+0x22>
     322:  ce 01         movw  r24, r28
     324:  70 df         rcall  .-288      ; 0x206 <HardwareSerial::_poll_tx_data_empty()>
     326:  f5 cf         rjmp  .-22       ; 0x312 <HardwareSerial::flush()+0xc>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:764
        }
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }
     328:  df 91         pop  r29
     32a:  cf 91         pop  r28
     32c:  08 95         ret

0000032e <micros>:
micros():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:450
      #else /* TCA */
        uint8_t ticks;
      #endif
      uint8_t flags;
      /* Save current state and disable interrupts */
      uint8_t oldSREG = SREG;
     32e:  9f b7         in  r25, 0x3f  ; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:451
      cli(); /* INTERRUPTS OFF */
     330:  f8 94         cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:467
        while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
        flags = TCD0.INTFLAGS;
        ticks = TCD0.CAPTUREA;
        */
      #else /* = defined(MILLIS_USE_TCB) */
        ticks = _timer->CNT;
     332:  e0 91 2a 0b   lds  r30, 0x0B2A  ; 0x800b2a <__TEXT_REGION_LENGTH__+0x7e0b2a>
     336:  f0 91 2b 0b   lds  r31, 0x0B2B  ; 0x800b2b <__TEXT_REGION_LENGTH__+0x7e0b2b>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:468
        flags = _timer->INTFLAGS;
     33a:  80 91 26 0b   lds  r24, 0x0B26  ; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:476
       * ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
       * so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it
       * doesn't matter.
       * Get current number of overflows and timer count */
      #if defined(MILLIS_USE_TCB)
        overflows = timingStruct.timer_millis;
     33e:  20 91 c4 42   lds  r18, 0x42C4  ; 0x8042c4 <timingStruct>
     342:  30 91 c5 42   lds  r19, 0x42C5  ; 0x8042c5 <timingStruct+0x1>
     346:  40 91 c6 42   lds  r20, 0x42C6  ; 0x8042c6 <timingStruct+0x2>
     34a:  50 91 c7 42   lds  r21, 0x42C7  ; 0x8042c7 <timingStruct+0x3>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:481
      #else
        overflows = timingStruct.timer_overflow_count;
      #endif
      /* Turn interrupts back on, assuming they were on when micros was called. */
      SREG = oldSREG; /* INTERRUPTS ON */
     34e:  9f bf         out  0x3f, r25  ; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:491
      */
      #if defined(MILLIS_USE_TCA)
        ticks = (TIME_TRACKING_TIMER_PERIOD) - ticks;
        if ((flags & TCA_SPLIT_HUNF_bm) && (ticks < 0x03)) {
      #else /* = defined(MILLIS_USE_TCB) */
        if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
     350:  80 ff         sbrs  r24, 0
     352:  08 c0         rjmp  .+16       ; 0x364 <micros+0x36>
     354:  cf 01         movw  r24, r30
     356:  88 27         eor  r24, r24
     358:  89 2b         or  r24, r25
     35a:  21 f4         brne  .+8        ; 0x364 <micros+0x36>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:496
      #endif
      #if (defined(MILLIS_USE_TCB) && (F_CPU <= 2000000UL))
        overflows += 2;
      #else
        overflows++;
     35c:  2f 5f         subi  r18, 0xFF  ; 255
     35e:  3f 4f         sbci  r19, 0xFF  ; 255
     360:  4f 4f         sbci  r20, 0xFF  ; 255
     362:  5f 4f         sbci  r21, 0xFF  ; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:788
            : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
          microseconds = overflows * 1000 + ticks; // nice and clean.

        #elif (F_CPU == 48000000UL || F_CPU == 24000000UL || F_CPU == 12000000UL || F_CPU == 6000000UL || F_CPU == 3000000UL)
          // The terrible twelves!
            __asm__ __volatile__(
     364:  0f 01         movw  r0, r30
     366:  16 94         lsr  r1
     368:  07 94         ror  r0
     36a:  16 94         lsr  r1
     36c:  07 94         ror  r0
     36e:  16 94         lsr  r1
     370:  07 94         ror  r0
     372:  16 94         lsr  r1
     374:  07 94         ror  r0
     376:  f0 01         movw  r30, r0
     378:  16 94         lsr  r1
     37a:  07 94         ror  r0
     37c:  e0 0d         add  r30, r0
     37e:  f1 1d         adc  r31, r1
     380:  16 94         lsr  r1
     382:  07 94         ror  r0
     384:  10 2c         mov  r1, r0
     386:  16 94         lsr  r1
     388:  01 18         sub  r0, r1
     38a:  16 94         lsr  r1
     38c:  01 0c         add  r0, r1
     38e:  16 94         lsr  r1
     390:  01 18         sub  r0, r1
     392:  16 94         lsr  r1
     394:  01 0c         add  r0, r1
     396:  16 94         lsr  r1
     398:  01 18         sub  r0, r1
     39a:  16 94         lsr  r1
     39c:  16 94         lsr  r1
     39e:  01 0c         add  r0, r1
     3a0:  11 24         eor  r1, r1
     3a2:  e0 19         sub  r30, r0
     3a4:  f1 09         sbc  r31, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:833
          "add r0,r1"     "\n\t"  // + ticks >> 9
          "eor r1,r1"     "\n\t"  // clear out r1
          "sub %A0,r0"    "\n\t"  // Add the sum of terms that fit in a byte to what was ticks in old code.
          "sbc %B0,r1"    "\n"    // carry - see,this is why AVR needs a known zero.
          : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
        microseconds = overflows * 1000 + ticks;
     3a6:  a8 ee         ldi  r26, 0xE8  ; 232
     3a8:  b3 e0         ldi  r27, 0x03  ; 3
     3aa:  0e 94 f9 0d   call  0x1bf2  ; 0x1bf2 <__muluhisi3>
     3ae:  6e 0f         add  r22, r30
     3b0:  7f 1f         adc  r23, r31
     3b2:  81 1d         adc  r24, r1
     3b4:  91 1d         adc  r25, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1042
          microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                        + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
        #endif
      #endif // end of timer-specific part of micros calculations
      return microseconds;
    }
     3b6:  08 95         ret

000003b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>:
_ZN5Print5writeEPKc.part.2():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:56
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
      }
      return write((const uint8_t *)str, strlen(str));
     3b8:  fb 01         movw  r30, r22
     3ba:  01 90         ld  r0, Z+
     3bc:  00 20         and  r0, r0
     3be:  e9 f7         brne  .-6        ; 0x3ba <Print::write(char const*) [clone .part.2] [clone .constprop.21]+0x2>
     3c0:  31 97         sbiw  r30, 0x01  ; 1
     3c2:  af 01         movw  r20, r30
     3c4:  46 1b         sub  r20, r22
     3c6:  57 0b         sbc  r21, r23
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:66

size_t Print::print(const String &s) {
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[]) {
     3c8:  b4 ce         rjmp  .-664      ; 0x132 <Print::write(unsigned char const*, unsigned int)>

000003ca <Print::print(char const*) [clone .constprop.9]>:
write():
     3ca:  bc 01         movw  r22, r24
     3cc:  88 ec         ldi  r24, 0xC8  ; 200
     3ce:  92 e4         ldi  r25, 0x42  ; 66
     3d0:  f3 cf         rjmp  .-26       ; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>

000003d2 <Print::println(unsigned int, int) [clone .constprop.10]>:
println():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:157
  size_t n = print(num, base);
  n += println();
  return n;
}

size_t Print::println(unsigned int num, int base) {
     3d2:  cf 92         push  r12
     3d4:  df 92         push  r13
     3d6:  ef 92         push  r14
     3d8:  ff 92         push  r15
     3da:  0f 93         push  r16
     3dc:  1f 93         push  r17
     3de:  cf 93         push  r28
     3e0:  df 93         push  r29
     3e2:  cd b7         in  r28, 0x3d  ; 61
     3e4:  de b7         in  r29, 0x3e  ; 62
     3e6:  a1 97         sbiw  r28, 0x21  ; 33
     3e8:  cd bf         out  0x3d, r28  ; 61
     3ea:  de bf         out  0x3e, r29  ; 62
print():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:83
size_t Print::print(int n, int base) {
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base) {
  return print((unsigned long) n, base);
     3ec:  9c 01         movw  r18, r24
     3ee:  50 e0         ldi  r21, 0x00  ; 0
     3f0:  40 e0         ldi  r20, 0x00  ; 0
printNumber():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:219

size_t Print::printNumber(unsigned long n, uint8_t base) {
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     3f2:  19 a2         std  Y+33, r1  ; 0x21
     3f4:  8e 01         movw  r16, r28
     3f6:  0f 5d         subi  r16, 0xDF  ; 223
     3f8:  1f 4f         sbci  r17, 0xFF  ; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:227
  if (base < 2) {
    base = 10;
  }

  do {
    char c = n % base;
     3fa:  8a e0         ldi  r24, 0x0A  ; 10
     3fc:  c8 2e         mov  r12, r24
     3fe:  d1 2c         mov  r13, r1
     400:  e1 2c         mov  r14, r1
     402:  f1 2c         mov  r15, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:228
    n /= base;
     404:  ca 01         movw  r24, r20
     406:  b9 01         movw  r22, r18
     408:  a7 01         movw  r20, r14
     40a:  96 01         movw  r18, r12
     40c:  0e 94 d7 0d   call  0x1bae  ; 0x1bae <__udivmodsi4>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:230

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     410:  60 5d         subi  r22, 0xD0  ; 208
     412:  f8 01         movw  r30, r16
     414:  62 93         st  -Z, r22
     416:  8f 01         movw  r16, r30
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:231
  } while (n);
     418:  21 15         cp  r18, r1
     41a:  31 05         cpc  r19, r1
     41c:  41 05         cpc  r20, r1
     41e:  51 05         cpc  r21, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:53
      setWriteError(0);
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
     420:  89 f7         brne  .-30       ; 0x404 <__LOCK_REGION_LENGTH__+0x4>
write():
     422:  30 97         sbiw  r30, 0x00  ; 0
     424:  c1 f0         breq  .+48       ; 0x456 <__LOCK_REGION_LENGTH__+0x56>
     426:  bf 01         movw  r22, r30
     428:  88 ec         ldi  r24, 0xC8  ; 200
     42a:  92 e4         ldi  r25, 0x42  ; 66
     42c:  c5 df         rcall  .-118      ; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
     42e:  8c 01         movw  r16, r24
     430:  67 e5         ldi  r22, 0x57  ; 87
     432:  70 e4         ldi  r23, 0x40  ; 64
     434:  88 ec         ldi  r24, 0xC8  ; 200
     436:  92 e4         ldi  r25, 0x42  ; 66
     438:  bf df         rcall  .-130      ; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
println():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:161

size_t Print::println(unsigned int num, int base) {
  size_t n = print(num, base);
  n += println();
  return n;
}
     43a:  80 0f         add  r24, r16
     43c:  91 1f         adc  r25, r17
     43e:  a1 96         adiw  r28, 0x21  ; 33
     440:  cd bf         out  0x3d, r28  ; 61
     442:  de bf         out  0x3e, r29  ; 62
     444:  df 91         pop  r29
     446:  cf 91         pop  r28
     448:  1f 91         pop  r17
     44a:  0f 91         pop  r16
     44c:  ff 90         pop  r15
     44e:  ef 90         pop  r14
     450:  df 90         pop  r13
     452:  cf 90         pop  r12
     454:  08 95         ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:54
        return 0;
     456:  10 e0         ldi  r17, 0x00  ; 0
     458:  00 e0         ldi  r16, 0x00  ; 0
     45a:  ea cf         rjmp  .-44       ; 0x430 <__LOCK_REGION_LENGTH__+0x30>

0000045c <setup>:
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:6

#include <rngBetter.h>
#define SERIALPORT Serial
#define SERIALSWAPLEVEL (0)

void setup() {
     45c:  cf 92         push  r12
     45e:  df 92         push  r13
     460:  ef 92         push  r14
     462:  ff 92         push  r15
     464:  cf 93         push  r28
     466:  df 93         push  r29
swap():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:526
    }


    bool HardwareSerial::swap(uint8_t newmux) {
      if (newmux < _mux_count) {
        _pin_set = newmux;
     468:  10 92 d5 42   sts  0x42D5, r1  ; 0x8042d5 <Serial0+0xd>
begin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:540
    }

    void HardwareSerial::begin(unsigned long baud, uint16_t options) {
      // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
      // without first calling end()
      if (_state & 1) {
     46c:  80 91 d6 42   lds  r24, 0x42D6  ; 0x8042d6 <Serial0+0xe>
     470:  80 ff         sbrs  r24, 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:684
        return NOT_A_MUX; // At this point, we have checked all group codes for this peripheral. It ain't there. Return NOT_A_MUX.
      }
    }
    void HardwareSerial::end() {
      // wait for transmission of outgoing data
      flush();
     472:  13 c0         rjmp  .+38       ; 0x49a <setup+0x3e>
end():
     474:  88 ec         ldi  r24, 0xC8  ; 200
     476:  92 e4         ldi  r25, 0x42  ; 66
     478:  46 df         rcall  .-372      ; 0x306 <HardwareSerial::flush()>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:687
      // Disable receiver and transmitter as well as the RX complete and the data register empty interrupts.
      // TXCIE only used in half duplex - we can just turn the damned thing off yo!
      volatile USART_t * temp = _hwserial_module; /* compiler does a slightly better job with this. */
     47a:  e0 91 d0 42   lds  r30, 0x42D0  ; 0x8042d0 <Serial0+0x8>
     47e:  f0 91 d1 42   lds  r31, 0x42D1  ; 0x8042d1 <Serial0+0x9>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:688
      temp -> CTRLB &= 0; //~(USART_RXEN_bm | USART_TXEN_bm);
     482:  86 81         ldd  r24, Z+6  ; 0x06
     484:  16 82         std  Z+6, r1  ; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:689
      temp -> CTRLA &= 0; //~(USART_RXCIE_bm | USART_DREIE_bm | USART_TXCIE_bm);
     486:  85 81         ldd  r24, Z+5  ; 0x05
     488:  15 82         std  Z+5, r1  ; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:690
      temp -> STATUS =  USART_TXCIF_bm; // want to make sure no chanceofthat firing in error. TXCIE only used in half duplex
     48a:  80 e4         ldi  r24, 0x40  ; 64
     48c:  84 83         std  Z+4, r24  ; 0x04
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:692
      // clear any received data
      _rx_buffer_head = _rx_buffer_tail;
     48e:  80 91 d8 42   lds  r24, 0x42D8  ; 0x8042d8 <Serial0+0x10>
     492:  80 93 d7 42   sts  0x42D7, r24  ; 0x8042d7 <Serial0+0xf>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:696

      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
     496:  10 92 d6 42   sts  0x42D6, r1  ; 0x8042d6 <Serial0+0xe>
begin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:579
        setpinmask             |= 0x10;         // this tells _set_pins not to disturb the configuration on the RX pin.
      }
      if (ctrla & USART_RS485_bm) {             // RS485 mode recorded here too... because we need to set
        setpinmask             |= 0x01;         // set pin output if we need to do that. Datasheet isn't clear
      }
      uint8_t oldSREG = SREG;
     49a:  6f b7         in  r22, 0x3f  ; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:580
      cli();
     49c:  f8 94         cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:581
      volatile USART_t* MyUSART = _hwserial_module;
     49e:  e0 91 d0 42   lds  r30, 0x42D0  ; 0x8042d0 <Serial0+0x8>
     4a2:  f0 91 d1 42   lds  r31, 0x42D1  ; 0x8042d1 <Serial0+0x9>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:582
      (*MyUSART).CTRLB          = 0;            // gotta disable first - some things are enable-locked.
     4a6:  16 82         std  Z+6, r1  ; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:583
      (*MyUSART).CTRLC          = ctrlc;        // No reason not to set first.
     4a8:  33 e0         ldi  r19, 0x03  ; 3
     4aa:  37 83         std  Z+7, r19  ; 0x07
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:584
      (*MyUSART).BAUD           = baud_setting; // Wish I could have set it long ago
     4ac:  81 e4         ldi  r24, 0x41  ; 65
     4ae:  93 e0         ldi  r25, 0x03  ; 3
     4b0:  80 87         std  Z+8, r24  ; 0x08
     4b2:  91 87         std  Z+9, r25  ; 0x09
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:590
      if (ctrla & 0x20) {                       // Now we have to do a bit of work
        setpinmask             &= 0x7F;         // Remove the RX pin in this case because we get the input from elsewhere.
        (*MyUSART).EVCTRL       = 1;            // enable event input - not clear from datasheet what's needed to
        (*MyUSART).TXPLCTRL     = 0xFF;         // Disable pulse length encoding.
      } else {
        (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
     4b4:  14 86         std  Z+12, r1  ; 0x0c
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:592
      }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
      (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
     4b6:  80 e8         ldi  r24, 0x80  ; 128
     4b8:  85 83         std  Z+5, r24  ; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:593
      (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
     4ba:  80 ec         ldi  r24, 0xC0  ; 192
     4bc:  86 83         std  Z+6, r24  ; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:594
        _set_pins(_usart_pins, _mux_count, _pin_set, setpinmask); // set up the pin(s)
     4be:  20 91 d5 42   lds  r18, 0x42D5  ; 0x8042d5 <Serial0+0xd>
     4c2:  70 91 d4 42   lds  r23, 0x42D4  ; 0x8042d4 <Serial0+0xc>
     4c6:  80 91 d2 42   lds  r24, 0x42D2  ; 0x8042d2 <Serial0+0xa>
     4ca:  90 91 d3 42   lds  r25, 0x42D3  ; 0x8042d3 <Serial0+0xb>
_set_pins():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:641
    //  1  1  1  0      TX set output, RX not changed. Loopback mode: you can only see what you send since TX is OUTPUT and that's what's connected to RX.
    //  1  1  1  1      TX set input pullup. Half-duplex mode.
    // * indicates that RS485 mode if requested will be enabled, even though it is inappropriate. These configurations are documented unsupported.
    // Static
    void HardwareSerial::_set_pins(uint8_t* mux_table_ptr, uint8_t mux_count, uint8_t mux_setting, uint8_t enmask) {
      uint8_t* mux_row_ptr   = mux_table_ptr + (mux_setting * USART_PINS_WIDTH);
     4ce:  fc 01         movw  r30, r24
     4d0:  23 9f         mul  r18, r19
     4d2:  e0 0d         add  r30, r0
     4d4:  f1 1d         adc  r31, r1
     4d6:  11 24         eor  r1, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:642
      uint16_t mux_row_gc_tx = pgm_read_word_near(mux_row_ptr); // Clever trick for faster PGM reads of consecutive bytes!
     4d8:  45 91         lpm  r20, Z+
     4da:  54 91         lpm  r21, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:644
      uint8_t mux_group_code = (uint8_t) (mux_row_gc_tx);       // this is the mux
      if (mux_setting < mux_count) {              // if false, pinmux none was selected, and we skip the pin configuration.
     4dc:  27 17         cp  r18, r23
     4de:  08 f0         brcs  .+2        ; 0x4e2 <setup+0x86>
     4e0:  3e c0         rjmp  .+124      ; 0x55e <setup+0x102>
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     4e2:  57 31         cpi  r21, 0x17  ; 23
     4e4:  90 f4         brcc  .+36       ; 0x50a <setup+0xae>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/Arduino.h:792
  #if !defined(NUM_TOTAL_PINS)
    #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
  #endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
     4e6:  25 2f         mov  r18, r21
     4e8:  30 e0         ldi  r19, 0x00  ; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:79
     4ea:  f9 01         movw  r30, r18
     4ec:  e2 5d         subi  r30, 0xD2  ; 210
     4ee:  ff 4b         sbci  r31, 0xBF  ; 191
     4f0:  a0 81         ld  r26, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     4f2:  af 3f         cpi  r26, 0xFF  ; 255
     4f4:  51 f0         breq  .+20       ; 0x50a <setup+0xae>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
     4f6:  29 5e         subi  r18, 0xE9  ; 233
     4f8:  3f 4b         sbci  r19, 0xBF  ; 191
     4fa:  e9 01         movw  r28, r18
     4fc:  e8 81         ld  r30, Y
     4fe:  d0 e2         ldi  r29, 0x20  ; 32
     500:  ed 9f         mul  r30, r29
     502:  f0 01         movw  r30, r0
     504:  11 24         eor  r1, r1
     506:  fc 5f         subi  r31, 0xFC  ; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
     508:  a1 83         std  Z+1, r26  ; 0x01
_set_pins():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:653
          pinMode(mux_pin_tx, OUTPUT);            // If and only if TX is enabled and open drain isn't should the TX pin be output.
        } else if (enmask & 0x50) {               // if it is enabled but is in open drain mode, or is disabled, but loopback is enabled
          pinMode(mux_pin_tx, INPUT_PULLUP);      // TX should be INPUT_PULLUP.
        }
        if (enmask & 0x80 && !(enmask & 0x10)) {  // Likewise if RX is enabled, unless loopback mode is too
          pinMode(mux_pin_tx + 1, INPUT_PULLUP);  // (in which case we caught it above), it should be pulled up
     50a:  21 e0         ldi  r18, 0x01  ; 1
     50c:  25 0f         add  r18, r21
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     50e:  27 31         cpi  r18, 0x17  ; 23
     510:  30 f5         brcc  .+76       ; 0x55e <setup+0x102>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/Arduino.h:792
     512:  30 e0         ldi  r19, 0x00  ; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:79
     514:  f9 01         movw  r30, r18
     516:  e2 5d         subi  r30, 0xD2  ; 210
     518:  ff 4b         sbci  r31, 0xBF  ; 191
     51a:  c0 81         ld  r28, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     51c:  cf 3f         cpi  r28, 0xFF  ; 255
     51e:  f9 f0         breq  .+62       ; 0x55e <setup+0x102>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
     520:  f9 01         movw  r30, r18
     522:  e9 5e         subi  r30, 0xE9  ; 233
     524:  ff 4b         sbci  r31, 0xBF  ; 191
     526:  a0 81         ld  r26, Z
     528:  e0 e2         ldi  r30, 0x20  ; 32
     52a:  ae 9f         mul  r26, r30
     52c:  d0 01         movw  r26, r0
     52e:  11 24         eor  r1, r1
     530:  bc 5f         subi  r27, 0xFC  ; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:89
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
     532:  20 50         subi  r18, 0x00  ; 0
     534:  30 4c         sbci  r19, 0xC0  ; 192
     536:  f9 01         movw  r30, r18
     538:  d0 81         ld  r29, Z
setup():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:90
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
     53a:  f0 e0         ldi  r31, 0x00  ; 0
     53c:  e0 e0         ldi  r30, 0x00  ; 0
_pinMode():
     53e:  d8 30         cpi  r29, 0x08  ; 8
     540:  30 f4         brcc  .+12       ; 0x54e <setup+0xf2>
     542:  9d 01         movw  r18, r26
     544:  20 5f         subi  r18, 0xF0  ; 240
     546:  3f 4f         sbci  r19, 0xFF  ; 255
     548:  f9 01         movw  r30, r18
     54a:  ed 0f         add  r30, r29
     54c:  f1 1d         adc  r31, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:91
    uint8_t status = SREG;              /* Save state */
     54e:  3f b7         in  r19, 0x3f  ; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:92
    cli();                              /* Interrupts off for PINnCTRL stuff */
     550:  f8 94         cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:93
    port->DIRCLR = bit_mask;            /* Configure direction as input */
     552:  12 96         adiw  r26, 0x02  ; 2
     554:  cc 93         st  X, r28
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:95
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
     556:  20 81         ld  r18, Z
     558:  28 60         ori  r18, 0x08  ; 8
     55a:  20 83         st  Z, r18
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:99
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    }
    SREG = status;                      /* Restore state */
     55c:  3f bf         out  0x3f, r19  ; 63
_mux_set():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:611
      uint8_t temp   = *portmux;
      temp          &= ~((uint8_t) (mux_options_off_gm >> 8)); // Group Mask
      temp          |= mux_code;
      *portmux       = temp;
    #else
      uint8_t* mux_info_ptr = mux_table_ptr + (mux_count * USART_PINS_WIDTH) + 2;
     55e:  fc 01         movw  r30, r24
     560:  23 e0         ldi  r18, 0x03  ; 3
     562:  72 9f         mul  r23, r18
     564:  e0 0d         add  r30, r0
     566:  f1 1d         adc  r31, r1
     568:  11 24         eor  r1, r1
     56a:  32 96         adiw  r30, 0x02  ; 2
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:615
      /* Only one register, so no offset, so only read a byte */
      uint8_t mux_mask = pgm_read_byte_near(mux_info_ptr);     // only read the group mask
      volatile uint8_t* portmux = (uint8_t*)(HWSERIAL_MUX_REGISTER_BASE);
      uint8_t temp   = *portmux;
     56c:  e4 91         lpm  r30, Z
     56e:  80 91 e2 05   lds  r24, 0x05E2  ; 0x8005e2 <__TEXT_REGION_LENGTH__+0x7e05e2>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:616
      temp          &= ~(mux_mask);
     572:  e0 95         com  r30
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:617
      temp          |= mux_code;
     574:  e8 23         and  r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:618
      *portmux       = temp;
     576:  e4 2b         or  r30, r20
     578:  e0 93 e2 05   sts  0x05E2, r30  ; 0x8005e2 <__TEXT_REGION_LENGTH__+0x7e05e2>
begin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1105
#if (!(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC) || (F_CPU == 7000000L || F_CPU == 14000000)))
  // delay implementation when we do have micros() - we know it won't work at 7 or 14, and those can be generated
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
    uint16_t start = (uint16_t)micros();
     57c:  6f bf         out  0x3f, r22  ; 63
delay():
     57e:  d7 de         rcall  .-594      ; 0x32e <micros>
     580:  eb 01         movw  r28, r22
     582:  88 ee         ldi  r24, 0xE8  ; 232
     584:  c8 2e         mov  r12, r24
     586:  83 e0         ldi  r24, 0x03  ; 3
     588:  d8 2e         mov  r13, r24
     58a:  e1 2c         mov  r14, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1109
    while (true) {
      if (ms == 0) break;
      yield();
      uint16_t us_passed = (uint16_t)micros() - start;
     58c:  f1 2c         mov  r15, r1
     58e:  cf de         rcall  .-610      ; 0x32e <micros>
     590:  6c 1b         sub  r22, r28
     592:  7d 0b         sbc  r23, r29
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1110
      if (us_passed >= 1000) {
     594:  68 3e         cpi  r22, 0xE8  ; 232
     596:  73 40         sbci  r23, 0x03  ; 3
     598:  d0 f3         brcs  .-12       ; 0x58e <setup+0x132>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1111
        ms--;
     59a:  e1 e0         ldi  r30, 0x01  ; 1
     59c:  ce 1a         sub  r12, r30
     59e:  d1 08         sbc  r13, r1
     5a0:  e1 08         sbc  r14, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1112
        start += 1000;
     5a2:  f1 08         sbc  r15, r1
     5a4:  c8 51         subi  r28, 0x18  ; 24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1107
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
    uint16_t start = (uint16_t)micros();
    while (true) {
      if (ms == 0) break;
     5a6:  dc 4f         sbci  r29, 0xFC  ; 252
     5a8:  c1 14         cp  r12, r1
     5aa:  d1 04         cpc  r13, r1
     5ac:  e1 04         cpc  r14, r1
     5ae:  f1 04         cpc  r15, r1
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:12
  // put your setup code here, to run once:
  // Validating all API calls. 
  SERIALPORT.swap(SERIALSWAPLEVEL);
  SERIALPORT.begin(115200);
  delay(1000);
  SERIALPORT.print("Generate seed (from just adc): ");
     5b0:  71 f7         brne  .-36       ; 0x58e <setup+0x132>
setup():
     5b2:  8a e5         ldi  r24, 0x5A  ; 90
     5b4:  90 e4         ldi  r25, 0x40  ; 64
     5b6:  09 df         rcall  .-494      ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
_analogReadEnh():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:661
   */

  /*******************************
   *  Phase 1: Input Processing  |
   ******************************/
  if (!(ADC0.CTRLA & 0x01)) return ADC_ENH_ERROR_DISABLED;
     5b8:  80 91 00 06   lds  r24, 0x0600  ; 0x800600 <__TEXT_REGION_LENGTH__+0x7e0600>
     5bc:  80 fd         sbrc  r24, 0
     5be:  02 c0         rjmp  .+4        ; 0x5c4 <setup+0x168>
     5c0:  0c 94 8d 0c   jmp  0x191a  ; 0x191a <setup+0x14be>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:687
        This does not check for internal sources that don't exist (all valid internal sources are checked for in the case of compile-time-known pins)
          Not worth wasting on the scale of 20-some-odd bytes of flash just to give an error to people who dynamically generate invalid analog pins
          and try to use them with analogReadEnh(), instead of just returning whatever we get from reading the bogus channel */
    return ADC_ENH_ERROR_BAD_PIN_OR_CHANNEL;
  }
  if (ADC0.COMMAND & ADC_STCONV_bm) {
     5c4:  80 91 0a 06   lds  r24, 0x060A  ; 0x80060a <__TEXT_REGION_LENGTH__+0x7e060a>
     5c8:  80 ff         sbrs  r24, 0
     5ca:  02 c0         rjmp  .+4        ; 0x5d0 <setup+0x174>
     5cc:  0c 94 b1 0c   jmp  0x1962  ; 0x1962 <setup+0x1506>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:718
        busy before entering this block. */
  } // end neg != SINGLE_ENDED
  /********************************************
   *  Phase 2: Configure ADC and take reading  |
   ********************************************/
  ADC0.MUXPOS = pin;
     5d0:  94 e0         ldi  r25, 0x04  ; 4
     5d2:  90 93 08 06   sts  0x0608, r25  ; 0x800608 <__TEXT_REGION_LENGTH__+0x7e0608>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:719
  uint8_t _ctrlb = ADC0.CTRLB;
     5d6:  50 91 01 06   lds  r21, 0x0601  ; 0x800601 <__TEXT_REGION_LENGTH__+0x7e0601>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:720
  uint8_t _ctrla = ADC0.CTRLA;
     5da:  40 91 00 06   lds  r20, 0x0600  ; 0x800600 <__TEXT_REGION_LENGTH__+0x7e0600>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:721
  ADC0.CTRLA = ADC_ENABLE_bm | (res == ADC_NATIVE_RESOLUTION_LOW ? ADC_RESSEL_10BIT_gc : 0) | (neg == SINGLE_ENDED ? 0 : ADC_CONVMODE_bm);
     5de:  81 e0         ldi  r24, 0x01  ; 1
     5e0:  80 93 00 06   sts  0x0600, r24  ; 0x800600 <__TEXT_REGION_LENGTH__+0x7e0600>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:722
  ADC0.CTRLB = sampnum;
     5e4:  90 93 01 06   sts  0x0601, r25  ; 0x800601 <__TEXT_REGION_LENGTH__+0x7e0601>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:724

  ADC0.COMMAND = ADC_STCONV_bm;
     5e8:  80 93 0a 06   sts  0x060A, r24  ; 0x80060a <__TEXT_REGION_LENGTH__+0x7e060a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:725
  while (!(ADC0.INTFLAGS & ADC_RESRDY_bm));
     5ec:  80 91 0d 06   lds  r24, 0x060D  ; 0x80060d <__TEXT_REGION_LENGTH__+0x7e060d>
     5f0:  80 ff         sbrs  r24, 0
     5f2:  fc cf         rjmp  .-8        ; 0x5ec <setup+0x190>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:726
  int32_t result = ADC0.RES; // This should clear the flag
     5f4:  20 91 10 06   lds  r18, 0x0610  ; 0x800610 <__TEXT_REGION_LENGTH__+0x7e0610>
     5f8:  30 91 11 06   lds  r19, 0x0611  ; 0x800611 <__TEXT_REGION_LENGTH__+0x7e0611>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:762
   ******************************/
  #if (defined(ERRATA_ADC_PIN_DISABLE) && ERRATA_ADC_PIN_DISABLE != 0)
    // That may become defined when DA-series silicon is available with the fix
    ADC0.MUXPOS = 0x40;
  #endif
  ADC0.CTRLB = _ctrlb;      // the user having something set in CTRLB is not implausuble
     5fc:  50 93 01 06   sts  0x0601, r21  ; 0x800601 <__TEXT_REGION_LENGTH__+0x7e0601>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:763
  ADC0.CTRLA = _ctrla;      // undo the mess we just made in ADC0.CTRLA
     600:  40 93 00 06   sts  0x0600, r20  ; 0x800600 <__TEXT_REGION_LENGTH__+0x7e0600>
ADCtoSeed():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/rngBetter.cpp:78
          "swap %B1"         "\n\t"
          "eor %A0, %B1"     "\n\t"
          "eor %B0, %A1"     "\n\t"
        :"+d"((uint16_t)tempseed)
        :"r"((uint16_t)reading)
        :);
     604:  81 e0         ldi  r24, 0x01  ; 1
     606:  90 e0         ldi  r25, 0x00  ; 0
     608:  c9 01         movw  r24, r18
     60a:  82 95         swap  r24
     60c:  32 95         swap  r19
     60e:  83 27         eor  r24, r19
     610:  92 27         eor  r25, r18
seed_xor16_11e():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11e.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     612:  00 97         sbiw  r24, 0x00  ; 0
     614:  21 f0         breq  .+8        ; 0x61e <setup+0x1c2>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11e.cpp:13
    __xor16_11e_state = seed;
     616:  80 93 4c 42   sts  0x424C, r24  ; 0x80424c <__data_end>
     61a:  90 93 4d 42   sts  0x424D, r25  ; 0x80424d <__data_end+0x1>
xor16_11e():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11e.cpp:37
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 6"        "\n\t"
      "bst    %A0, 1"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_11e_state)::"r18","r19");
     61e:  c0 91 4c 42   lds  r28, 0x424C  ; 0x80424c <__data_end>
     622:  d0 91 4d 42   lds  r29, 0x424D  ; 0x80424d <__data_end+0x1>
     626:  9e 01         movw  r18, r28
     628:  22 0f         add  r18, r18
     62a:  33 1f         adc  r19, r19
     62c:  c2 27         eor  r28, r18
     62e:  d3 27         eor  r29, r19
     630:  9e 01         movw  r18, r28
     632:  36 95         lsr  r19
     634:  27 95         ror  r18
     636:  c2 27         eor  r28, r18
     638:  d3 27         eor  r29, r19
     63a:  33 27         eor  r19, r19
     63c:  c0 fb         bst  r28, 0
     63e:  36 f9         bld  r19, 6
     640:  c1 fb         bst  r28, 1
     642:  37 f9         bld  r19, 7
     644:  d3 27         eor  r29, r19
     646:  c0 93 4c 42   sts  0x424C, r28  ; 0x80424c <__data_end>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:30
      while (1);
    }
    uint16_t seed = rng16::ADCtoSeed((uint16_t) adcread, 16);
    seed_xor16_11e(seed);
    seed = xor16_11e();
    SERIALPORT.print("11e: ");
     64a:  d0 93 4d 42   sts  0x424D, r29  ; 0x80424d <__data_end+0x1>
setup():
     64e:  8f ed         ldi  r24, 0xDF  ; 223
     650:  90 e4         ldi  r25, 0x40  ; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:31
    SERIALPORT.println(seed);
     652:  bb de         rcall  .-650      ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     654:  ce 01         movw  r24, r28
     656:  bd de         rcall  .-646      ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_11f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11f.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     658:  20 97         sbiw  r28, 0x00  ; 0
     65a:  21 f0         breq  .+8        ; 0x664 <setup+0x208>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11f.cpp:13
    __xor16_11f_state = seed;
     65c:  c0 93 4e 42   sts  0x424E, r28  ; 0x80424e <__xor16_11f_state>
     660:  d0 93 4f 42   sts  0x424F, r29  ; 0x80424f <__xor16_11f_state+0x1>
xor16_11f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_11f.cpp:35
      "eor    %B0, r19"      "\n\t"
      "eor    r19, r19"      "\n\t"
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_11f_state)::"r18","r19");
     664:  c0 91 4e 42   lds  r28, 0x424E  ; 0x80424e <__xor16_11f_state>
     668:  d0 91 4f 42   lds  r29, 0x424F  ; 0x80424f <__xor16_11f_state+0x1>
     66c:  9e 01         movw  r18, r28
     66e:  22 0f         add  r18, r18
     670:  33 1f         adc  r19, r19
     672:  c2 27         eor  r28, r18
     674:  d3 27         eor  r29, r19
     676:  9e 01         movw  r18, r28
     678:  36 95         lsr  r19
     67a:  27 95         ror  r18
     67c:  c2 27         eor  r28, r18
     67e:  d3 27         eor  r29, r19
     680:  33 27         eor  r19, r19
     682:  c0 fb         bst  r28, 0
     684:  37 f9         bld  r19, 7
     686:  d3 27         eor  r29, r19
     688:  c0 93 4e 42   sts  0x424E, r28  ; 0x80424e <__xor16_11f_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:34
    seed_xor16_11f(seed);
    seed = xor16_11f();
    SERIALPORT.print("11f: ");
     68c:  d0 93 4f 42   sts  0x424F, r29  ; 0x80424f <__xor16_11f_state+0x1>
setup():
     690:  85 ee         ldi  r24, 0xE5  ; 229
     692:  90 e4         ldi  r25, 0x40  ; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:35
    SERIALPORT.println(seed);
     694:  9a de         rcall  .-716      ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     696:  ce 01         movw  r24, r28
     698:  9c de         rcall  .-712      ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_152():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_152.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     69a:  20 97         sbiw  r28, 0x00  ; 0
     69c:  21 f0         breq  .+8        ; 0x6a6 <setup+0x24a>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_152.cpp:13
    __xor16_152_state = seed;
     69e:  c0 93 50 42   sts  0x4250, r28  ; 0x804250 <__xor16_152_state>
     6a2:  d0 93 51 42   sts  0x4251, r29  ; 0x804251 <__xor16_152_state+0x1>
xor16_152():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_152.cpp:46
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_152_state)::"r18","r19");
     6a6:  c0 91 50 42   lds  r28, 0x4250  ; 0x804250 <__xor16_152_state>
     6aa:  d0 91 51 42   lds  r29, 0x4251  ; 0x804251 <__xor16_152_state+0x1>
     6ae:  9e 01         movw  r18, r28
     6b0:  22 0f         add  r18, r18
     6b2:  33 1f         adc  r19, r19
     6b4:  c2 27         eor  r28, r18
     6b6:  d3 27         eor  r29, r19
     6b8:  9e 01         movw  r18, r28
     6ba:  36 95         lsr  r19
     6bc:  27 95         ror  r18
     6be:  36 95         lsr  r19
     6c0:  27 95         ror  r18
     6c2:  36 95         lsr  r19
     6c4:  27 95         ror  r18
     6c6:  36 95         lsr  r19
     6c8:  27 95         ror  r18
     6ca:  36 95         lsr  r19
     6cc:  27 95         ror  r18
     6ce:  c2 27         eor  r28, r18
     6d0:  d3 27         eor  r29, r19
     6d2:  9e 01         movw  r18, r28
     6d4:  22 0f         add  r18, r18
     6d6:  33 1f         adc  r19, r19
     6d8:  22 0f         add  r18, r18
     6da:  33 1f         adc  r19, r19
     6dc:  c2 27         eor  r28, r18
     6de:  d3 27         eor  r29, r19
     6e0:  c0 93 50 42   sts  0x4250, r28  ; 0x804250 <__xor16_152_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:38
    seed_xor16_152(seed);
    seed = xor16_152();
    SERIALPORT.print("152: ");
     6e4:  d0 93 51 42   sts  0x4251, r29  ; 0x804251 <__xor16_152_state+0x1>
setup():
     6e8:  8b ee         ldi  r24, 0xEB  ; 235
     6ea:  90 e4         ldi  r25, 0x40  ; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:39
    SERIALPORT.println(seed);
     6ec:  6e de         rcall  .-804      ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     6ee:  ce 01         movw  r24, r28
     6f0:  70 de         rcall  .-800      ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_174():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_174.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     6f2:  20 97         sbiw  r28, 0x00  ; 0
     6f4:  21 f0         breq  .+8        ; 0x6fe <setup+0x2a2>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_174.cpp:13
    __xor16_174_state = seed;
     6f6:  c0 93 52 42   sts  0x4252, r28  ; 0x804252 <__xor16_174_state>
     6fa:  d0 93 53 42   sts  0x4253, r29  ; 0x804253 <__xor16_174_state+0x1>
xor16_174():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_174.cpp:45
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_174_state)::"r18","r19");
     6fe:  c0 91 52 42   lds  r28, 0x4252  ; 0x804252 <__xor16_174_state>
     702:  d0 91 53 42   lds  r29, 0x4253  ; 0x804253 <__xor16_174_state+0x1>
     706:  9e 01         movw  r18, r28
     708:  22 0f         add  r18, r18
     70a:  33 1f         adc  r19, r19
     70c:  c2 27         eor  r28, r18
     70e:  d3 27         eor  r29, r19
     710:  9e 01         movw  r18, r28
     712:  22 0f         add  r18, r18
     714:  23 2f         mov  r18, r19
     716:  22 1f         adc  r18, r18
     718:  33 0b         sbc  r19, r19
     71a:  31 95         neg  r19
     71c:  c2 27         eor  r28, r18
     71e:  d3 27         eor  r29, r19
     720:  9e 01         movw  r18, r28
     722:  22 0f         add  r18, r18
     724:  33 1f         adc  r19, r19
     726:  22 0f         add  r18, r18
     728:  33 1f         adc  r19, r19
     72a:  22 0f         add  r18, r18
     72c:  33 1f         adc  r19, r19
     72e:  22 0f         add  r18, r18
     730:  33 1f         adc  r19, r19
     732:  c2 27         eor  r28, r18
     734:  d3 27         eor  r29, r19
     736:  c0 93 52 42   sts  0x4252, r28  ; 0x804252 <__xor16_174_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:42
    seed_xor16_174(seed);
    seed = xor16_174();
    SERIALPORT.print("174: ");
     73a:  d0 93 53 42   sts  0x4253, r29  ; 0x804253 <__xor16_174_state+0x1>
setup():
     73e:  81 ef         ldi  r24, 0xF1  ; 241
     740:  90 e4         ldi  r25, 0x40  ; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:43
    SERIALPORT.println(seed);
     742:  43 de         rcall  .-890      ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     744:  ce 01         movw  r24, r28
     746:  45 de         rcall  .-886      ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_17b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_17b.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     748:  20 97         sbiw  r28, 0x00  ; 0
     74a:  21 f0         breq  .+8        ; 0x754 <setup+0x2f8>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_17b.cpp:13
    __xor16_17b_state = seed;
     74c:  c0 93 54 42   sts  0x4254, r28  ; 0x804254 <__xor16_17b_state>
     750:  d0 93 55 42   sts  0x4255, r29  ; 0x804255 <__xor16_17b_state+0x1>
xor16_17b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_17b.cpp:39
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_17b_state)::"r18","r19");
     754:  c0 91 54 42   lds  r28, 0x4254  ; 0x804254 <__xor16_17b_state>
     758:  d0 91 55 42   lds  r29, 0x4255  ; 0x804255 <__xor16_17b_state+0x1>
     75c:  9e 01         movw  r18, r28
     75e:  22 0f         add  r18, r18
     760:  33 1f         adc  r19, r19
     762:  c2 27         eor  r28, r18
     764:  d3 27         eor  r29, r19
     766:  9e 01         movw  r18, r28
     768:  22 0f         add  r18, r18
     76a:  23 2f         mov  r18, r19
     76c:  22 1f         adc  r18, r18
     76e:  33 0b         sbc  r19, r19
     770:  31 95         neg  r19
     772:  c2 27         eor  r28, r18
     774:  d3 27         eor  r29, r19
     776:  3c 2f         mov  r19, r28
     778:  33 0f         add  r19, r19
     77a:  33 0f         add  r19, r19
     77c:  33 0f         add  r19, r19
     77e:  d3 27         eor  r29, r19
     780:  c0 93 54 42   sts  0x4254, r28  ; 0x804254 <__xor16_17b_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:46
    seed_xor16_17b(seed);
    seed = xor16_17b();
    SERIALPORT.print("17b: ");
     784:  d0 93 55 42   sts  0x4255, r29  ; 0x804255 <__xor16_17b_state+0x1>
setup():
     788:  87 ef         ldi  r24, 0xF7  ; 247
     78a:  90 e4         ldi  r25, 0x40  ; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:47
    SERIALPORT.println(seed);
     78c:  1e de         rcall  .-964      ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     78e:  ce 01         movw  r24, r28
     790:  20 de         rcall  .-960      ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_1b3():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1b3.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     792:  20 97         sbiw  r28, 0x00  ; 0
     794:  21 f0         breq  .+8        ; 0x79e <setup+0x342>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1b3.cpp:13
    __xor16_1b3_state = seed;
     796:  c0 93 56 42   sts  0x4256, r28  ; 0x804256 <__xor16_1b3_state>
     79a:  d0 93 57 42   sts  0x4257, r29  ; 0x804257 <__xor16_1b3_state+0x1>
xor16_1b3():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1b3.cpp:40
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_1b3_state)::"r18","r19");
     79e:  c0 91 56 42   lds  r28, 0x4256  ; 0x804256 <__xor16_1b3_state>
     7a2:  d0 91 57 42   lds  r29, 0x4257  ; 0x804257 <__xor16_1b3_state+0x1>
     7a6:  9e 01         movw  r18, r28
     7a8:  22 0f         add  r18, r18
     7aa:  33 1f         adc  r19, r19
     7ac:  c2 27         eor  r28, r18
     7ae:  d3 27         eor  r29, r19
     7b0:  2d 2f         mov  r18, r29
     7b2:  26 95         lsr  r18
     7b4:  26 95         lsr  r18
     7b6:  26 95         lsr  r18
     7b8:  c2 27         eor  r28, r18
     7ba:  9e 01         movw  r18, r28
     7bc:  22 0f         add  r18, r18
     7be:  33 1f         adc  r19, r19
     7c0:  22 0f         add  r18, r18
     7c2:  33 1f         adc  r19, r19
     7c4:  22 0f         add  r18, r18
     7c6:  33 1f         adc  r19, r19
     7c8:  c2 27         eor  r28, r18
     7ca:  d3 27         eor  r29, r19
     7cc:  c0 93 56 42   sts  0x4256, r28  ; 0x804256 <__xor16_1b3_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:50
    seed_xor16_1b3(seed);
    seed = xor16_1b3();
    SERIALPORT.print("1b3: ");
     7d0:  d0 93 57 42   sts  0x4257, r29  ; 0x804257 <__xor16_1b3_state+0x1>
setup():
     7d4:  8d ef         ldi  r24, 0xFD  ; 253
     7d6:  90 e4         ldi  r25, 0x40  ; 64
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:51
    SERIALPORT.println(seed);
     7d8:  f8 dd         rcall  .-1040     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     7da:  ce 01         movw  r24, r28
     7dc:  fa dd         rcall  .-1036     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_1f6():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f6.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     7de:  20 97         sbiw  r28, 0x00  ; 0
     7e0:  21 f0         breq  .+8        ; 0x7ea <setup+0x38e>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f6.cpp:13
    __xor16_1f6_state = seed;
     7e2:  c0 93 58 42   sts  0x4258, r28  ; 0x804258 <__xor16_1f6_state>
     7e6:  d0 93 59 42   sts  0x4259, r29  ; 0x804259 <__xor16_1f6_state+0x1>
xor16_1f6():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f6.cpp:45
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_1f6_state)::"r18","r19");
     7ea:  c0 91 58 42   lds  r28, 0x4258  ; 0x804258 <__xor16_1f6_state>
     7ee:  d0 91 59 42   lds  r29, 0x4259  ; 0x804259 <__xor16_1f6_state+0x1>
     7f2:  9e 01         movw  r18, r28
     7f4:  22 0f         add  r18, r18
     7f6:  33 1f         adc  r19, r19
     7f8:  c2 27         eor  r28, r18
     7fa:  d3 27         eor  r29, r19
     7fc:  d7 fb         bst  r29, 7
     7fe:  22 27         eor  r18, r18
     800:  20 f9         bld  r18, 0
     802:  c2 27         eor  r28, r18
     804:  9e 01         movw  r18, r28
     806:  22 0f         add  r18, r18
     808:  33 1f         adc  r19, r19
     80a:  22 0f         add  r18, r18
     80c:  33 1f         adc  r19, r19
     80e:  22 0f         add  r18, r18
     810:  33 1f         adc  r19, r19
     812:  22 0f         add  r18, r18
     814:  33 1f         adc  r19, r19
     816:  22 0f         add  r18, r18
     818:  33 1f         adc  r19, r19
     81a:  22 0f         add  r18, r18
     81c:  33 1f         adc  r19, r19
     81e:  c2 27         eor  r28, r18
     820:  d3 27         eor  r29, r19
     822:  c0 93 58 42   sts  0x4258, r28  ; 0x804258 <__xor16_1f6_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:54
    seed_xor16_1f6(seed);
    seed = xor16_1f6();
    SERIALPORT.print("1f6: ");
     826:  d0 93 59 42   sts  0x4259, r29  ; 0x804259 <__xor16_1f6_state+0x1>
setup():
     82a:  83 e0         ldi  r24, 0x03  ; 3
     82c:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:55
    SERIALPORT.println(seed);
     82e:  cd dd         rcall  .-1126     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     830:  ce 01         movw  r24, r28
     832:  cf dd         rcall  .-1122     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_1f7():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f7.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     834:  20 97         sbiw  r28, 0x00  ; 0
     836:  21 f0         breq  .+8        ; 0x840 <setup+0x3e4>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f7.cpp:13
    __xor16_1f7_state = seed;
     838:  c0 93 5a 42   sts  0x425A, r28  ; 0x80425a <__xor16_1f7_state>
     83c:  d0 93 5b 42   sts  0x425B, r29  ; 0x80425b <__xor16_1f7_state+0x1>
xor16_1f7():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_1f7.cpp:38
      "eor    r18, r18"      "\n\t"
      "ror    r19"           "\n\t"
      "ror    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_1f7_state)::"r18","r19");
     840:  c0 91 5a 42   lds  r28, 0x425A  ; 0x80425a <__xor16_1f7_state>
     844:  d0 91 5b 42   lds  r29, 0x425B  ; 0x80425b <__xor16_1f7_state+0x1>
     848:  9e 01         movw  r18, r28
     84a:  22 0f         add  r18, r18
     84c:  33 1f         adc  r19, r19
     84e:  c2 27         eor  r28, r18
     850:  d3 27         eor  r29, r19
     852:  d7 fb         bst  r29, 7
     854:  22 27         eor  r18, r18
     856:  20 f9         bld  r18, 0
     858:  c2 27         eor  r28, r18
     85a:  9e 01         movw  r18, r28
     85c:  36 95         lsr  r19
     85e:  32 2f         mov  r19, r18
     860:  22 27         eor  r18, r18
     862:  37 95         ror  r19
     864:  27 95         ror  r18
     866:  c2 27         eor  r28, r18
     868:  d3 27         eor  r29, r19
     86a:  c0 93 5a 42   sts  0x425A, r28  ; 0x80425a <__xor16_1f7_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:58
    seed_xor16_1f7(seed);
    seed = xor16_1f7();
    SERIALPORT.print("1f7: ");
     86e:  d0 93 5b 42   sts  0x425B, r29  ; 0x80425b <__xor16_1f7_state+0x1>
setup():
     872:  89 e0         ldi  r24, 0x09  ; 9
     874:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:59
    SERIALPORT.println(seed);
     876:  a9 dd         rcall  .-1198     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     878:  ce 01         movw  r24, r28
     87a:  ab dd         rcall  .-1194     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_251():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_251.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     87c:  20 97         sbiw  r28, 0x00  ; 0
     87e:  21 f0         breq  .+8        ; 0x888 <setup+0x42c>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_251.cpp:13
    __xor16_251_state = seed;
     880:  c0 93 5c 42   sts  0x425C, r28  ; 0x80425c <__xor16_251_state>
     884:  d0 93 5d 42   sts  0x425D, r29  ; 0x80425d <__xor16_251_state+0x1>
xor16_251():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_251.cpp:46
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_251_state)::"r18","r19");
     888:  c0 91 5c 42   lds  r28, 0x425C  ; 0x80425c <__xor16_251_state>
     88c:  d0 91 5d 42   lds  r29, 0x425D  ; 0x80425d <__xor16_251_state+0x1>
     890:  9e 01         movw  r18, r28
     892:  22 0f         add  r18, r18
     894:  33 1f         adc  r19, r19
     896:  22 0f         add  r18, r18
     898:  33 1f         adc  r19, r19
     89a:  c2 27         eor  r28, r18
     89c:  d3 27         eor  r29, r19
     89e:  9e 01         movw  r18, r28
     8a0:  36 95         lsr  r19
     8a2:  27 95         ror  r18
     8a4:  36 95         lsr  r19
     8a6:  27 95         ror  r18
     8a8:  36 95         lsr  r19
     8aa:  27 95         ror  r18
     8ac:  36 95         lsr  r19
     8ae:  27 95         ror  r18
     8b0:  36 95         lsr  r19
     8b2:  27 95         ror  r18
     8b4:  c2 27         eor  r28, r18
     8b6:  d3 27         eor  r29, r19
     8b8:  9e 01         movw  r18, r28
     8ba:  22 0f         add  r18, r18
     8bc:  33 1f         adc  r19, r19
     8be:  c2 27         eor  r28, r18
     8c0:  d3 27         eor  r29, r19
     8c2:  c0 93 5c 42   sts  0x425C, r28  ; 0x80425c <__xor16_251_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:62
    seed_xor16_251(seed);
    seed = xor16_251();
    SERIALPORT.print("251: ");
     8c6:  d0 93 5d 42   sts  0x425D, r29  ; 0x80425d <__xor16_251_state+0x1>
setup():
     8ca:  8f e0         ldi  r24, 0x0F  ; 15
     8cc:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:63
    SERIALPORT.println(seed);
     8ce:  7d dd         rcall  .-1286     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     8d0:  ce 01         movw  r24, r28
     8d2:  7f dd         rcall  .-1282     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_25d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     8d4:  20 97         sbiw  r28, 0x00  ; 0
     8d6:  21 f0         breq  .+8        ; 0x8e0 <setup+0x484>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25d.cpp:13
    __xor16_25d_state = seed;
     8d8:  c0 93 5e 42   sts  0x425E, r28  ; 0x80425e <__xor16_25d_state>
     8dc:  d0 93 5f 42   sts  0x425F, r29  ; 0x80425f <__xor16_25d_state+0x1>
xor16_25d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25d.cpp:46
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_25d_state)::"r18","r19");
     8e0:  c0 91 5e 42   lds  r28, 0x425E  ; 0x80425e <__xor16_25d_state>
     8e4:  d0 91 5f 42   lds  r29, 0x425F  ; 0x80425f <__xor16_25d_state+0x1>
     8e8:  9e 01         movw  r18, r28
     8ea:  22 0f         add  r18, r18
     8ec:  33 1f         adc  r19, r19
     8ee:  22 0f         add  r18, r18
     8f0:  33 1f         adc  r19, r19
     8f2:  c2 27         eor  r28, r18
     8f4:  d3 27         eor  r29, r19
     8f6:  9e 01         movw  r18, r28
     8f8:  36 95         lsr  r19
     8fa:  27 95         ror  r18
     8fc:  36 95         lsr  r19
     8fe:  27 95         ror  r18
     900:  36 95         lsr  r19
     902:  27 95         ror  r18
     904:  36 95         lsr  r19
     906:  27 95         ror  r18
     908:  36 95         lsr  r19
     90a:  27 95         ror  r18
     90c:  c2 27         eor  r28, r18
     90e:  d3 27         eor  r29, r19
     910:  3c 2f         mov  r19, r28
     912:  32 95         swap  r19
     914:  33 0f         add  r19, r19
     916:  30 7e         andi  r19, 0xE0  ; 224
     918:  d3 27         eor  r29, r19
     91a:  c0 93 5e 42   sts  0x425E, r28  ; 0x80425e <__xor16_25d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:66
    seed_xor16_25d(seed);
    seed = xor16_25d();
    SERIALPORT.print("25d: ");
     91e:  d0 93 5f 42   sts  0x425F, r29  ; 0x80425f <__xor16_25d_state+0x1>
setup():
     922:  85 e1         ldi  r24, 0x15  ; 21
     924:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:67
    SERIALPORT.println(seed);
     926:  51 dd         rcall  .-1374     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     928:  ce 01         movw  r24, r28
     92a:  53 dd         rcall  .-1370     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_25f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25f.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     92c:  20 97         sbiw  r28, 0x00  ; 0
     92e:  21 f0         breq  .+8        ; 0x938 <setup+0x4dc>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25f.cpp:13
    __xor16_25f_state = seed;
     930:  c0 93 60 42   sts  0x4260, r28  ; 0x804260 <__xor16_25f_state>
     934:  d0 93 61 42   sts  0x4261, r29  ; 0x804261 <__xor16_25f_state+0x1>
xor16_25f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_25f.cpp:45
      "eor    %B0, r19"      "\n\t"
      "eor    r19, r19"      "\n\t"
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_25f_state)::"r18","r19");
     938:  c0 91 60 42   lds  r28, 0x4260  ; 0x804260 <__xor16_25f_state>
     93c:  d0 91 61 42   lds  r29, 0x4261  ; 0x804261 <__xor16_25f_state+0x1>
     940:  9e 01         movw  r18, r28
     942:  22 0f         add  r18, r18
     944:  33 1f         adc  r19, r19
     946:  22 0f         add  r18, r18
     948:  33 1f         adc  r19, r19
     94a:  c2 27         eor  r28, r18
     94c:  d3 27         eor  r29, r19
     94e:  9e 01         movw  r18, r28
     950:  36 95         lsr  r19
     952:  27 95         ror  r18
     954:  36 95         lsr  r19
     956:  27 95         ror  r18
     958:  36 95         lsr  r19
     95a:  27 95         ror  r18
     95c:  36 95         lsr  r19
     95e:  27 95         ror  r18
     960:  36 95         lsr  r19
     962:  27 95         ror  r18
     964:  c2 27         eor  r28, r18
     966:  d3 27         eor  r29, r19
     968:  33 27         eor  r19, r19
     96a:  c0 fb         bst  r28, 0
     96c:  37 f9         bld  r19, 7
     96e:  d3 27         eor  r29, r19
     970:  c0 93 60 42   sts  0x4260, r28  ; 0x804260 <__xor16_25f_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:70
    seed_xor16_25f(seed);
    seed = xor16_25f();
    SERIALPORT.print("25f: ");
     974:  d0 93 61 42   sts  0x4261, r29  ; 0x804261 <__xor16_25f_state+0x1>
setup():
     978:  8b e1         ldi  r24, 0x1B  ; 27
     97a:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:71
    SERIALPORT.println(seed);
     97c:  26 dd         rcall  .-1460     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     97e:  ce 01         movw  r24, r28
     980:  28 dd         rcall  .-1456     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_27d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     982:  20 97         sbiw  r28, 0x00  ; 0
     984:  21 f0         breq  .+8        ; 0x98e <setup+0x532>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27d.cpp:13
    __xor16_27d_state = seed;
     986:  c0 93 62 42   sts  0x4262, r28  ; 0x804262 <__xor16_27d_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27d.cpp:41
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_27d_state)::"r18","r19");
     98a:  d0 93 63 42   sts  0x4263, r29  ; 0x804263 <__xor16_27d_state+0x1>
xor16_27d():
     98e:  c0 91 62 42   lds  r28, 0x4262  ; 0x804262 <__xor16_27d_state>
     992:  d0 91 63 42   lds  r29, 0x4263  ; 0x804263 <__xor16_27d_state+0x1>
     996:  9e 01         movw  r18, r28
     998:  22 0f         add  r18, r18
     99a:  33 1f         adc  r19, r19
     99c:  22 0f         add  r18, r18
     99e:  33 1f         adc  r19, r19
     9a0:  c2 27         eor  r28, r18
     9a2:  d3 27         eor  r29, r19
     9a4:  9e 01         movw  r18, r28
     9a6:  22 0f         add  r18, r18
     9a8:  23 2f         mov  r18, r19
     9aa:  22 1f         adc  r18, r18
     9ac:  33 0b         sbc  r19, r19
     9ae:  31 95         neg  r19
     9b0:  c2 27         eor  r28, r18
     9b2:  d3 27         eor  r29, r19
     9b4:  3c 2f         mov  r19, r28
     9b6:  32 95         swap  r19
     9b8:  33 0f         add  r19, r19
     9ba:  30 7e         andi  r19, 0xE0  ; 224
     9bc:  d3 27         eor  r29, r19
     9be:  c0 93 62 42   sts  0x4262, r28  ; 0x804262 <__xor16_27d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:74
    seed_xor16_27d(seed);
    seed = xor16_27d();
    SERIALPORT.print("27d: ");
     9c2:  d0 93 63 42   sts  0x4263, r29  ; 0x804263 <__xor16_27d_state+0x1>
setup():
     9c6:  81 e2         ldi  r24, 0x21  ; 33
     9c8:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:75
    SERIALPORT.println(seed);
     9ca:  ff dc         rcall  .-1538     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     9cc:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27f.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     9ce:  01 dd         rcall  .-1534     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_27f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27f.cpp:13
    __xor16_27f_state = seed;
     9d0:  20 97         sbiw  r28, 0x00  ; 0
     9d2:  21 f0         breq  .+8        ; 0x9dc <setup+0x580>
     9d4:  c0 93 64 42   sts  0x4264, r28  ; 0x804264 <__xor16_27f_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_27f.cpp:40
      "eor    %B0, r19"      "\n\t"
      "eor    r19, r19"      "\n\t"
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_27f_state)::"r18","r19");
     9d8:  d0 93 65 42   sts  0x4265, r29  ; 0x804265 <__xor16_27f_state+0x1>
xor16_27f():
     9dc:  c0 91 64 42   lds  r28, 0x4264  ; 0x804264 <__xor16_27f_state>
     9e0:  d0 91 65 42   lds  r29, 0x4265  ; 0x804265 <__xor16_27f_state+0x1>
     9e4:  9e 01         movw  r18, r28
     9e6:  22 0f         add  r18, r18
     9e8:  33 1f         adc  r19, r19
     9ea:  22 0f         add  r18, r18
     9ec:  33 1f         adc  r19, r19
     9ee:  c2 27         eor  r28, r18
     9f0:  d3 27         eor  r29, r19
     9f2:  9e 01         movw  r18, r28
     9f4:  22 0f         add  r18, r18
     9f6:  23 2f         mov  r18, r19
     9f8:  22 1f         adc  r18, r18
     9fa:  33 0b         sbc  r19, r19
     9fc:  31 95         neg  r19
     9fe:  c2 27         eor  r28, r18
     a00:  d3 27         eor  r29, r19
     a02:  33 27         eor  r19, r19
     a04:  c0 fb         bst  r28, 0
     a06:  37 f9         bld  r19, 7
     a08:  d3 27         eor  r29, r19
     a0a:  c0 93 64 42   sts  0x4264, r28  ; 0x804264 <__xor16_27f_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:78
    seed_xor16_27f(seed);
    seed = xor16_27f();
    SERIALPORT.print("27f: ");
     a0e:  d0 93 65 42   sts  0x4265, r29  ; 0x804265 <__xor16_27f_state+0x1>
setup():
     a12:  87 e2         ldi  r24, 0x27  ; 39
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:79
    SERIALPORT.println(seed);
     a14:  91 e4         ldi  r25, 0x41  ; 65
     a16:  d9 dc         rcall  .-1614     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31c.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     a18:  ce 01         movw  r24, r28
     a1a:  db dc         rcall  .-1610     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_31c():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31c.cpp:13
    __xor16_31c_state = seed;
     a1c:  20 97         sbiw  r28, 0x00  ; 0
     a1e:  21 f0         breq  .+8        ; 0xa28 <setup+0x5cc>
     a20:  c0 93 66 42   sts  0x4266, r28  ; 0x804266 <__xor16_31c_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31c.cpp:39
      "eor    %B0, r19"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "andi   r19, 0xF0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_31c_state)::"r18","r19");
     a24:  d0 93 67 42   sts  0x4267, r29  ; 0x804267 <__xor16_31c_state+0x1>
xor16_31c():
     a28:  c0 91 66 42   lds  r28, 0x4266  ; 0x804266 <__xor16_31c_state>
     a2c:  d0 91 67 42   lds  r29, 0x4267  ; 0x804267 <__xor16_31c_state+0x1>
     a30:  9e 01         movw  r18, r28
     a32:  22 0f         add  r18, r18
     a34:  33 1f         adc  r19, r19
     a36:  22 0f         add  r18, r18
     a38:  33 1f         adc  r19, r19
     a3a:  22 0f         add  r18, r18
     a3c:  33 1f         adc  r19, r19
     a3e:  c2 27         eor  r28, r18
     a40:  d3 27         eor  r29, r19
     a42:  9e 01         movw  r18, r28
     a44:  36 95         lsr  r19
     a46:  27 95         ror  r18
     a48:  c2 27         eor  r28, r18
     a4a:  d3 27         eor  r29, r19
     a4c:  3c 2f         mov  r19, r28
     a4e:  32 95         swap  r19
     a50:  30 7f         andi  r19, 0xF0  ; 240
     a52:  d3 27         eor  r29, r19
     a54:  c0 93 66 42   sts  0x4266, r28  ; 0x804266 <__xor16_31c_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:82
    seed_xor16_31c(seed);
    seed = xor16_31c();
    SERIALPORT.print("31c: ");
     a58:  d0 93 67 42   sts  0x4267, r29  ; 0x804267 <__xor16_31c_state+0x1>
setup():
     a5c:  8d e2         ldi  r24, 0x2D  ; 45
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:83
    SERIALPORT.println(seed);
     a5e:  91 e4         ldi  r25, 0x41  ; 65
     a60:  b4 dc         rcall  .-1688     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     a62:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31f.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     a64:  b6 dc         rcall  .-1684     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_31f():
     a66:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31f.cpp:13
    __xor16_31f_state = seed;
     a68:  21 f0         breq  .+8        ; 0xa72 <setup+0x616>
     a6a:  c0 93 68 42   sts  0x4268, r28  ; 0x804268 <__xor16_31f_state>
     a6e:  d0 93 69 42   sts  0x4269, r29  ; 0x804269 <__xor16_31f_state+0x1>
xor16_31f():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_31f.cpp:39
      "eor    %B0, r19"      "\n\t"
      "eor    r19, r19"      "\n\t"
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_31f_state)::"r18","r19");
     a72:  c0 91 68 42   lds  r28, 0x4268  ; 0x804268 <__xor16_31f_state>
     a76:  d0 91 69 42   lds  r29, 0x4269  ; 0x804269 <__xor16_31f_state+0x1>
     a7a:  9e 01         movw  r18, r28
     a7c:  22 0f         add  r18, r18
     a7e:  33 1f         adc  r19, r19
     a80:  22 0f         add  r18, r18
     a82:  33 1f         adc  r19, r19
     a84:  22 0f         add  r18, r18
     a86:  33 1f         adc  r19, r19
     a88:  c2 27         eor  r28, r18
     a8a:  d3 27         eor  r29, r19
     a8c:  9e 01         movw  r18, r28
     a8e:  36 95         lsr  r19
     a90:  27 95         ror  r18
     a92:  c2 27         eor  r28, r18
     a94:  d3 27         eor  r29, r19
     a96:  33 27         eor  r19, r19
     a98:  c0 fb         bst  r28, 0
     a9a:  37 f9         bld  r19, 7
     a9c:  d3 27         eor  r29, r19
     a9e:  c0 93 68 42   sts  0x4268, r28  ; 0x804268 <__xor16_31f_state>
     aa2:  d0 93 69 42   sts  0x4269, r29  ; 0x804269 <__xor16_31f_state+0x1>
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:86
    seed_xor16_31f(seed);
    seed = xor16_31f();
    SERIALPORT.print("31f: ");
     aa6:  83 e3         ldi  r24, 0x33  ; 51
     aa8:  91 e4         ldi  r25, 0x41  ; 65
     aaa:  8f dc         rcall  .-1762     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:87
    SERIALPORT.println(seed);
     aac:  ce 01         movw  r24, r28
     aae:  91 dc         rcall  .-1758     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_35b():
     ab0:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_35b.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     ab2:  21 f0         breq  .+8        ; 0xabc <setup+0x660>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_35b.cpp:13
    __xor16_35b_state = seed;
     ab4:  c0 93 6a 42   sts  0x426A, r28  ; 0x80426a <__xor16_35b_state>
     ab8:  d0 93 6b 42   sts  0x426B, r29  ; 0x80426b <__xor16_35b_state+0x1>
xor16_35b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_35b.cpp:48
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_35b_state)::"r18","r19");
     abc:  c0 91 6a 42   lds  r28, 0x426A  ; 0x80426a <__xor16_35b_state>
     ac0:  d0 91 6b 42   lds  r29, 0x426B  ; 0x80426b <__xor16_35b_state+0x1>
     ac4:  9e 01         movw  r18, r28
     ac6:  22 0f         add  r18, r18
     ac8:  33 1f         adc  r19, r19
     aca:  22 0f         add  r18, r18
     acc:  33 1f         adc  r19, r19
     ace:  22 0f         add  r18, r18
     ad0:  33 1f         adc  r19, r19
     ad2:  c2 27         eor  r28, r18
     ad4:  d3 27         eor  r29, r19
     ad6:  9e 01         movw  r18, r28
     ad8:  36 95         lsr  r19
     ada:  27 95         ror  r18
     adc:  36 95         lsr  r19
     ade:  27 95         ror  r18
     ae0:  36 95         lsr  r19
     ae2:  27 95         ror  r18
     ae4:  36 95         lsr  r19
     ae6:  27 95         ror  r18
     ae8:  36 95         lsr  r19
     aea:  27 95         ror  r18
     aec:  c2 27         eor  r28, r18
     aee:  d3 27         eor  r29, r19
     af0:  3c 2f         mov  r19, r28
     af2:  33 0f         add  r19, r19
     af4:  33 0f         add  r19, r19
     af6:  33 0f         add  r19, r19
     af8:  d3 27         eor  r29, r19
     afa:  c0 93 6a 42   sts  0x426A, r28  ; 0x80426a <__xor16_35b_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:90
    seed_xor16_35b(seed);
    seed = xor16_35b();
    SERIALPORT.print("35b: ");
     afe:  d0 93 6b 42   sts  0x426B, r29  ; 0x80426b <__xor16_35b_state+0x1>
setup():
     b02:  89 e3         ldi  r24, 0x39  ; 57
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:91
    SERIALPORT.println(seed);
     b04:  91 e4         ldi  r25, 0x41  ; 65
     b06:  61 dc         rcall  .-1854     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     b08:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3b1.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     b0a:  63 dc         rcall  .-1850     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_3b1():
     b0c:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3b1.cpp:13
    __xor16_3b1_state = seed;
     b0e:  21 f0         breq  .+8        ; 0xb18 <setup+0x6bc>
     b10:  c0 93 6c 42   sts  0x426C, r28  ; 0x80426c <__xor16_3b1_state>
     b14:  d0 93 6d 42   sts  0x426D, r29  ; 0x80426d <__xor16_3b1_state+0x1>
xor16_3b1():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3b1.cpp:40
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_3b1_state)::"r18","r19");
     b18:  c0 91 6c 42   lds  r28, 0x426C  ; 0x80426c <__xor16_3b1_state>
     b1c:  d0 91 6d 42   lds  r29, 0x426D  ; 0x80426d <__xor16_3b1_state+0x1>
     b20:  9e 01         movw  r18, r28
     b22:  22 0f         add  r18, r18
     b24:  33 1f         adc  r19, r19
     b26:  22 0f         add  r18, r18
     b28:  33 1f         adc  r19, r19
     b2a:  22 0f         add  r18, r18
     b2c:  33 1f         adc  r19, r19
     b2e:  c2 27         eor  r28, r18
     b30:  d3 27         eor  r29, r19
     b32:  2d 2f         mov  r18, r29
     b34:  26 95         lsr  r18
     b36:  26 95         lsr  r18
     b38:  26 95         lsr  r18
     b3a:  c2 27         eor  r28, r18
     b3c:  9e 01         movw  r18, r28
     b3e:  22 0f         add  r18, r18
     b40:  33 1f         adc  r19, r19
     b42:  c2 27         eor  r28, r18
     b44:  d3 27         eor  r29, r19
     b46:  c0 93 6c 42   sts  0x426C, r28  ; 0x80426c <__xor16_3b1_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:94
    seed_xor16_3b1(seed);
    seed = xor16_3b1();
    SERIALPORT.print("3b1: ");
     b4a:  d0 93 6d 42   sts  0x426D, r29  ; 0x80426d <__xor16_3b1_state+0x1>
setup():
     b4e:  8f e3         ldi  r24, 0x3F  ; 63
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:95
    SERIALPORT.println(seed);
     b50:  91 e4         ldi  r25, 0x41  ; 65
     b52:  3b dc         rcall  .-1930     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     b54:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3bb.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     b56:  3d dc         rcall  .-1926     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_3bb():
     b58:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3bb.cpp:13
    __xor16_3bb_state = seed;
     b5a:  21 f0         breq  .+8        ; 0xb64 <setup+0x708>
     b5c:  c0 93 6e 42   sts  0x426E, r28  ; 0x80426e <__xor16_3bb_state>
     b60:  d0 93 6f 42   sts  0x426F, r29  ; 0x80426f <__xor16_3bb_state+0x1>
xor16_3bb():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3bb.cpp:40
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_3bb_state)::"r18","r19");
     b64:  c0 91 6e 42   lds  r28, 0x426E  ; 0x80426e <__xor16_3bb_state>
     b68:  d0 91 6f 42   lds  r29, 0x426F  ; 0x80426f <__xor16_3bb_state+0x1>
     b6c:  9e 01         movw  r18, r28
     b6e:  22 0f         add  r18, r18
     b70:  33 1f         adc  r19, r19
     b72:  22 0f         add  r18, r18
     b74:  33 1f         adc  r19, r19
     b76:  22 0f         add  r18, r18
     b78:  33 1f         adc  r19, r19
     b7a:  c2 27         eor  r28, r18
     b7c:  d3 27         eor  r29, r19
     b7e:  2d 2f         mov  r18, r29
     b80:  26 95         lsr  r18
     b82:  26 95         lsr  r18
     b84:  26 95         lsr  r18
     b86:  c2 27         eor  r28, r18
     b88:  3c 2f         mov  r19, r28
     b8a:  33 0f         add  r19, r19
     b8c:  33 0f         add  r19, r19
     b8e:  33 0f         add  r19, r19
     b90:  d3 27         eor  r29, r19
     b92:  c0 93 6e 42   sts  0x426E, r28  ; 0x80426e <__xor16_3bb_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:98
    seed_xor16_3bb(seed);
    seed = xor16_3bb();
    SERIALPORT.print("3bb: ");
     b96:  d0 93 6f 42   sts  0x426F, r29  ; 0x80426f <__xor16_3bb_state+0x1>
setup():
     b9a:  85 e4         ldi  r24, 0x45  ; 69
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:99
    SERIALPORT.println(seed);
     b9c:  91 e4         ldi  r25, 0x41  ; 65
     b9e:  15 dc         rcall  .-2006     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     ba0:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3d9.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     ba2:  17 dc         rcall  .-2002     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_3d9():
     ba4:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3d9.cpp:13
    __xor16_3d9_state = seed;
     ba6:  21 f0         breq  .+8        ; 0xbb0 <setup+0x754>
     ba8:  c0 93 70 42   sts  0x4270, r28  ; 0x804270 <__xor16_3d9_state>
     bac:  d0 93 71 42   sts  0x4271, r29  ; 0x804271 <__xor16_3d9_state+0x1>
xor16_3d9():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_3d9.cpp:38
      "andi   r18, 0x07"     "\n\t"
      "eor    %A0, r18"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_3d9_state)::"r18","r19");
     bb0:  c0 91 70 42   lds  r28, 0x4270  ; 0x804270 <__xor16_3d9_state>
     bb4:  d0 91 71 42   lds  r29, 0x4271  ; 0x804271 <__xor16_3d9_state+0x1>
     bb8:  9e 01         movw  r18, r28
     bba:  22 0f         add  r18, r18
     bbc:  33 1f         adc  r19, r19
     bbe:  22 0f         add  r18, r18
     bc0:  33 1f         adc  r19, r19
     bc2:  22 0f         add  r18, r18
     bc4:  33 1f         adc  r19, r19
     bc6:  c2 27         eor  r28, r18
     bc8:  d3 27         eor  r29, r19
     bca:  2d 2f         mov  r18, r29
     bcc:  22 95         swap  r18
     bce:  26 95         lsr  r18
     bd0:  27 70         andi  r18, 0x07  ; 7
     bd2:  c2 27         eor  r28, r18
     bd4:  3c 2f         mov  r19, r28
     bd6:  33 0f         add  r19, r19
     bd8:  d3 27         eor  r29, r19
     bda:  c0 93 70 42   sts  0x4270, r28  ; 0x804270 <__xor16_3d9_state>
     bde:  d0 93 71 42   sts  0x4271, r29  ; 0x804271 <__xor16_3d9_state+0x1>
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:102
    seed_xor16_3d9(seed);
    seed = xor16_3d9();
    SERIALPORT.print("3d9: ");
     be2:  8b e4         ldi  r24, 0x4B  ; 75
     be4:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:103
    SERIALPORT.println(seed);
     be6:  f1 db         rcall  .-2078     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     be8:  ce 01         movw  r24, r28
     bea:  f3 db         rcall  .-2074     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_437():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_437.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     bec:  20 97         sbiw  r28, 0x00  ; 0
     bee:  21 f0         breq  .+8        ; 0xbf8 <setup+0x79c>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_437.cpp:13
    __xor16_437_state = seed;
     bf0:  c0 93 72 42   sts  0x4272, r28  ; 0x804272 <__xor16_437_state>
     bf4:  d0 93 73 42   sts  0x4273, r29  ; 0x804273 <__xor16_437_state+0x1>
xor16_437():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_437.cpp:49
      "eor    r18, r18"      "\n\t"
      "ror    r19"           "\n\t"
      "ror    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_437_state)::"r18","r19");
     bf8:  c0 91 72 42   lds  r28, 0x4272  ; 0x804272 <__xor16_437_state>
     bfc:  d0 91 73 42   lds  r29, 0x4273  ; 0x804273 <__xor16_437_state+0x1>
     c00:  9e 01         movw  r18, r28
     c02:  22 0f         add  r18, r18
     c04:  33 1f         adc  r19, r19
     c06:  22 0f         add  r18, r18
     c08:  33 1f         adc  r19, r19
     c0a:  22 0f         add  r18, r18
     c0c:  33 1f         adc  r19, r19
     c0e:  22 0f         add  r18, r18
     c10:  33 1f         adc  r19, r19
     c12:  c2 27         eor  r28, r18
     c14:  d3 27         eor  r29, r19
     c16:  9e 01         movw  r18, r28
     c18:  36 95         lsr  r19
     c1a:  27 95         ror  r18
     c1c:  36 95         lsr  r19
     c1e:  27 95         ror  r18
     c20:  36 95         lsr  r19
     c22:  27 95         ror  r18
     c24:  c2 27         eor  r28, r18
     c26:  d3 27         eor  r29, r19
     c28:  9e 01         movw  r18, r28
     c2a:  36 95         lsr  r19
     c2c:  32 2f         mov  r19, r18
     c2e:  22 27         eor  r18, r18
     c30:  37 95         ror  r19
     c32:  27 95         ror  r18
     c34:  c2 27         eor  r28, r18
     c36:  d3 27         eor  r29, r19
     c38:  c0 93 72 42   sts  0x4272, r28  ; 0x804272 <__xor16_437_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:106
    seed_xor16_437(seed);
    seed = xor16_437();
    SERIALPORT.print("437: ");
     c3c:  d0 93 73 42   sts  0x4273, r29  ; 0x804273 <__xor16_437_state+0x1>
setup():
     c40:  81 e5         ldi  r24, 0x51  ; 81
     c42:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:107
    SERIALPORT.println(seed);
     c44:  c2 db         rcall  .-2172     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     c46:  ce 01         movw  r24, r28
     c48:  c4 db         rcall  .-2168     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_471():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_471.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     c4a:  20 97         sbiw  r28, 0x00  ; 0
     c4c:  21 f0         breq  .+8        ; 0xc56 <setup+0x7fa>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_471.cpp:13
    __xor16_471_state = seed;
     c4e:  c0 93 74 42   sts  0x4274, r28  ; 0x804274 <__xor16_471_state>
     c52:  d0 93 75 42   sts  0x4275, r29  ; 0x804275 <__xor16_471_state+0x1>
xor16_471():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_471.cpp:45
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_471_state)::"r18","r19");
     c56:  c0 91 74 42   lds  r28, 0x4274  ; 0x804274 <__xor16_471_state>
     c5a:  d0 91 75 42   lds  r29, 0x4275  ; 0x804275 <__xor16_471_state+0x1>
     c5e:  9e 01         movw  r18, r28
     c60:  22 0f         add  r18, r18
     c62:  33 1f         adc  r19, r19
     c64:  22 0f         add  r18, r18
     c66:  33 1f         adc  r19, r19
     c68:  22 0f         add  r18, r18
     c6a:  33 1f         adc  r19, r19
     c6c:  22 0f         add  r18, r18
     c6e:  33 1f         adc  r19, r19
     c70:  c2 27         eor  r28, r18
     c72:  d3 27         eor  r29, r19
     c74:  9e 01         movw  r18, r28
     c76:  22 0f         add  r18, r18
     c78:  23 2f         mov  r18, r19
     c7a:  22 1f         adc  r18, r18
     c7c:  33 0b         sbc  r19, r19
     c7e:  31 95         neg  r19
     c80:  c2 27         eor  r28, r18
     c82:  d3 27         eor  r29, r19
     c84:  9e 01         movw  r18, r28
     c86:  22 0f         add  r18, r18
     c88:  33 1f         adc  r19, r19
     c8a:  c2 27         eor  r28, r18
     c8c:  d3 27         eor  r29, r19
     c8e:  c0 93 74 42   sts  0x4274, r28  ; 0x804274 <__xor16_471_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:110
    seed_xor16_471(seed);
    seed = xor16_471();
    SERIALPORT.print("471: ");
     c92:  d0 93 75 42   sts  0x4275, r29  ; 0x804275 <__xor16_471_state+0x1>
setup():
     c96:  87 e5         ldi  r24, 0x57  ; 87
     c98:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:111
    SERIALPORT.println(seed);
     c9a:  97 db         rcall  .-2258     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     c9c:  ce 01         movw  r24, r28
     c9e:  99 db         rcall  .-2254     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_4bb():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_4bb.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     ca0:  20 97         sbiw  r28, 0x00  ; 0
     ca2:  21 f0         breq  .+8        ; 0xcac <setup+0x850>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_4bb.cpp:13
    __xor16_4bb_state = seed;
     ca4:  c0 93 76 42   sts  0x4276, r28  ; 0x804276 <__xor16_4bb_state>
     ca8:  d0 93 77 42   sts  0x4277, r29  ; 0x804277 <__xor16_4bb_state+0x1>
xor16_4bb():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_4bb.cpp:42
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_4bb_state)::"r18","r19");
     cac:  c0 91 76 42   lds  r28, 0x4276  ; 0x804276 <__xor16_4bb_state>
     cb0:  d0 91 77 42   lds  r29, 0x4277  ; 0x804277 <__xor16_4bb_state+0x1>
     cb4:  9e 01         movw  r18, r28
     cb6:  22 0f         add  r18, r18
     cb8:  33 1f         adc  r19, r19
     cba:  22 0f         add  r18, r18
     cbc:  33 1f         adc  r19, r19
     cbe:  22 0f         add  r18, r18
     cc0:  33 1f         adc  r19, r19
     cc2:  22 0f         add  r18, r18
     cc4:  33 1f         adc  r19, r19
     cc6:  c2 27         eor  r28, r18
     cc8:  d3 27         eor  r29, r19
     cca:  2d 2f         mov  r18, r29
     ccc:  26 95         lsr  r18
     cce:  26 95         lsr  r18
     cd0:  26 95         lsr  r18
     cd2:  c2 27         eor  r28, r18
     cd4:  3c 2f         mov  r19, r28
     cd6:  33 0f         add  r19, r19
     cd8:  33 0f         add  r19, r19
     cda:  33 0f         add  r19, r19
     cdc:  d3 27         eor  r29, r19
     cde:  c0 93 76 42   sts  0x4276, r28  ; 0x804276 <__xor16_4bb_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:114
    seed_xor16_4bb(seed);
    seed = xor16_4bb();
    SERIALPORT.print("4bb: ");
     ce2:  d0 93 77 42   sts  0x4277, r29  ; 0x804277 <__xor16_4bb_state+0x1>
setup():
     ce6:  8d e5         ldi  r24, 0x5D  ; 93
     ce8:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:115
    SERIALPORT.println(seed);
     cea:  6f db         rcall  .-2338     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     cec:  ce 01         movw  r24, r28
     cee:  71 db         rcall  .-2334     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_57e():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_57e.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     cf0:  20 97         sbiw  r28, 0x00  ; 0
     cf2:  21 f0         breq  .+8        ; 0xcfc <setup+0x8a0>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_57e.cpp:13
    __xor16_57e_state = seed;
     cf4:  c0 93 78 42   sts  0x4278, r28  ; 0x804278 <__xor16_57e_state>
     cf8:  d0 93 79 42   sts  0x4279, r29  ; 0x804279 <__xor16_57e_state+0x1>
xor16_57e():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_57e.cpp:48
      "bst    %A0, 0"        "\n\t"
      "bld    r19, 6"        "\n\t"
      "bst    %A0, 1"        "\n\t"
      "bld    r19, 7"        "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_57e_state)::"r18","r19");
     cfc:  c0 91 78 42   lds  r28, 0x4278  ; 0x804278 <__xor16_57e_state>
     d00:  d0 91 79 42   lds  r29, 0x4279  ; 0x804279 <__xor16_57e_state+0x1>
     d04:  9e 01         movw  r18, r28
     d06:  22 0f         add  r18, r18
     d08:  33 1f         adc  r19, r19
     d0a:  22 0f         add  r18, r18
     d0c:  33 1f         adc  r19, r19
     d0e:  22 0f         add  r18, r18
     d10:  33 1f         adc  r19, r19
     d12:  22 0f         add  r18, r18
     d14:  33 1f         adc  r19, r19
     d16:  22 0f         add  r18, r18
     d18:  33 1f         adc  r19, r19
     d1a:  c2 27         eor  r28, r18
     d1c:  d3 27         eor  r29, r19
     d1e:  9e 01         movw  r18, r28
     d20:  22 0f         add  r18, r18
     d22:  23 2f         mov  r18, r19
     d24:  22 1f         adc  r18, r18
     d26:  33 0b         sbc  r19, r19
     d28:  31 95         neg  r19
     d2a:  c2 27         eor  r28, r18
     d2c:  d3 27         eor  r29, r19
     d2e:  33 27         eor  r19, r19
     d30:  c0 fb         bst  r28, 0
     d32:  36 f9         bld  r19, 6
     d34:  c1 fb         bst  r28, 1
     d36:  37 f9         bld  r19, 7
     d38:  d3 27         eor  r29, r19
     d3a:  c0 93 78 42   sts  0x4278, r28  ; 0x804278 <__xor16_57e_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:118
    seed_xor16_57e(seed);
    seed = xor16_57e();
    SERIALPORT.print("57e: ");
     d3e:  d0 93 79 42   sts  0x4279, r29  ; 0x804279 <__xor16_57e_state+0x1>
setup():
     d42:  83 e6         ldi  r24, 0x63  ; 99
     d44:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:119
    SERIALPORT.println(seed);
     d46:  41 db         rcall  .-2430     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     d48:  ce 01         movw  r24, r28
     d4a:  43 db         rcall  .-2426     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_598():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_598.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     d4c:  20 97         sbiw  r28, 0x00  ; 0
     d4e:  21 f0         breq  .+8        ; 0xd58 <setup+0x8fc>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_598.cpp:13
    __xor16_598_state = seed;
     d50:  c0 93 7a 42   sts  0x427A, r28  ; 0x80427a <__xor16_598_state>
     d54:  d0 93 7b 42   sts  0x427B, r29  ; 0x80427b <__xor16_598_state+0x1>
xor16_598():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_598.cpp:39
      "mov    r18, %B0"      "\n\t"
      "lsr    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_598_state)::"r18","r19");
     d58:  c0 91 7a 42   lds  r28, 0x427A  ; 0x80427a <__xor16_598_state>
     d5c:  d0 91 7b 42   lds  r29, 0x427B  ; 0x80427b <__xor16_598_state+0x1>
     d60:  9e 01         movw  r18, r28
     d62:  22 0f         add  r18, r18
     d64:  33 1f         adc  r19, r19
     d66:  22 0f         add  r18, r18
     d68:  33 1f         adc  r19, r19
     d6a:  22 0f         add  r18, r18
     d6c:  33 1f         adc  r19, r19
     d6e:  22 0f         add  r18, r18
     d70:  33 1f         adc  r19, r19
     d72:  22 0f         add  r18, r18
     d74:  33 1f         adc  r19, r19
     d76:  c2 27         eor  r28, r18
     d78:  d3 27         eor  r29, r19
     d7a:  2d 2f         mov  r18, r29
     d7c:  26 95         lsr  r18
     d7e:  c2 27         eor  r28, r18
     d80:  3c 2f         mov  r19, r28
     d82:  d3 27         eor  r29, r19
     d84:  c0 93 7a 42   sts  0x427A, r28  ; 0x80427a <__xor16_598_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:122
    seed_xor16_598(seed);
    seed = xor16_598();
    SERIALPORT.print("598: ");
     d88:  d0 93 7b 42   sts  0x427B, r29  ; 0x80427b <__xor16_598_state+0x1>
setup():
     d8c:  89 e6         ldi  r24, 0x69  ; 105
     d8e:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:123
    SERIALPORT.println(seed);
     d90:  1c db         rcall  .-2504     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     d92:  ce 01         movw  r24, r28
     d94:  1e db         rcall  .-2500     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_5b6():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5b6.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     d96:  20 97         sbiw  r28, 0x00  ; 0
     d98:  21 f0         breq  .+8        ; 0xda2 <setup+0x946>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5b6.cpp:13
    __xor16_5b6_state = seed;
     d9a:  c0 93 7c 42   sts  0x427C, r28  ; 0x80427c <__xor16_5b6_state>
     d9e:  d0 93 7d 42   sts  0x427D, r29  ; 0x80427d <__xor16_5b6_state+0x1>
xor16_5b6():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5b6.cpp:54
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_5b6_state)::"r18","r19");
     da2:  c0 91 7c 42   lds  r28, 0x427C  ; 0x80427c <__xor16_5b6_state>
     da6:  d0 91 7d 42   lds  r29, 0x427D  ; 0x80427d <__xor16_5b6_state+0x1>
     daa:  9e 01         movw  r18, r28
     dac:  22 0f         add  r18, r18
     dae:  33 1f         adc  r19, r19
     db0:  22 0f         add  r18, r18
     db2:  33 1f         adc  r19, r19
     db4:  22 0f         add  r18, r18
     db6:  33 1f         adc  r19, r19
     db8:  22 0f         add  r18, r18
     dba:  33 1f         adc  r19, r19
     dbc:  22 0f         add  r18, r18
     dbe:  33 1f         adc  r19, r19
     dc0:  c2 27         eor  r28, r18
     dc2:  d3 27         eor  r29, r19
     dc4:  2d 2f         mov  r18, r29
     dc6:  26 95         lsr  r18
     dc8:  26 95         lsr  r18
     dca:  26 95         lsr  r18
     dcc:  c2 27         eor  r28, r18
     dce:  9e 01         movw  r18, r28
     dd0:  22 0f         add  r18, r18
     dd2:  33 1f         adc  r19, r19
     dd4:  22 0f         add  r18, r18
     dd6:  33 1f         adc  r19, r19
     dd8:  22 0f         add  r18, r18
     dda:  33 1f         adc  r19, r19
     ddc:  22 0f         add  r18, r18
     dde:  33 1f         adc  r19, r19
     de0:  22 0f         add  r18, r18
     de2:  33 1f         adc  r19, r19
     de4:  22 0f         add  r18, r18
     de6:  33 1f         adc  r19, r19
     de8:  c2 27         eor  r28, r18
     dea:  d3 27         eor  r29, r19
     dec:  c0 93 7c 42   sts  0x427C, r28  ; 0x80427c <__xor16_5b6_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:126
    seed_xor16_5b6(seed);
    seed = xor16_5b6();
    SERIALPORT.print("5b6: ");
     df0:  d0 93 7d 42   sts  0x427D, r29  ; 0x80427d <__xor16_5b6_state+0x1>
setup():
     df4:  8f e6         ldi  r24, 0x6F  ; 111
     df6:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:127
    SERIALPORT.println(seed);
     df8:  e8 da         rcall  .-2608     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     dfa:  ce 01         movw  r24, r28
     dfc:  ea da         rcall  .-2604     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_5bb():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5bb.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     dfe:  20 97         sbiw  r28, 0x00  ; 0
     e00:  21 f0         breq  .+8        ; 0xe0a <setup+0x9ae>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5bb.cpp:13
    __xor16_5bb_state = seed;
     e02:  c0 93 7e 42   sts  0x427E, r28  ; 0x80427e <__xor16_5bb_state>
     e06:  d0 93 7f 42   sts  0x427F, r29  ; 0x80427f <__xor16_5bb_state+0x1>
xor16_5bb():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_5bb.cpp:44
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_5bb_state)::"r18","r19");
     e0a:  c0 91 7e 42   lds  r28, 0x427E  ; 0x80427e <__xor16_5bb_state>
     e0e:  d0 91 7f 42   lds  r29, 0x427F  ; 0x80427f <__xor16_5bb_state+0x1>
     e12:  9e 01         movw  r18, r28
     e14:  22 0f         add  r18, r18
     e16:  33 1f         adc  r19, r19
     e18:  22 0f         add  r18, r18
     e1a:  33 1f         adc  r19, r19
     e1c:  22 0f         add  r18, r18
     e1e:  33 1f         adc  r19, r19
     e20:  22 0f         add  r18, r18
     e22:  33 1f         adc  r19, r19
     e24:  22 0f         add  r18, r18
     e26:  33 1f         adc  r19, r19
     e28:  c2 27         eor  r28, r18
     e2a:  d3 27         eor  r29, r19
     e2c:  2d 2f         mov  r18, r29
     e2e:  26 95         lsr  r18
     e30:  26 95         lsr  r18
     e32:  26 95         lsr  r18
     e34:  c2 27         eor  r28, r18
     e36:  3c 2f         mov  r19, r28
     e38:  33 0f         add  r19, r19
     e3a:  33 0f         add  r19, r19
     e3c:  33 0f         add  r19, r19
     e3e:  d3 27         eor  r29, r19
     e40:  c0 93 7e 42   sts  0x427E, r28  ; 0x80427e <__xor16_5bb_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:130
    seed_xor16_5bb(seed);
    seed = xor16_5bb();
    SERIALPORT.print("5bb: ");
     e44:  d0 93 7f 42   sts  0x427F, r29  ; 0x80427f <__xor16_5bb_state+0x1>
setup():
     e48:  85 e7         ldi  r24, 0x75  ; 117
     e4a:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:131
    SERIALPORT.println(seed);
     e4c:  be da         rcall  .-2692     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     e4e:  ce 01         movw  r24, r28
     e50:  c0 da         rcall  .-2688     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_67d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_67d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     e52:  20 97         sbiw  r28, 0x00  ; 0
     e54:  21 f0         breq  .+8        ; 0xe5e <setup+0xa02>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_67d.cpp:13
    __xor16_67d_state = seed;
     e56:  c0 93 80 42   sts  0x4280, r28  ; 0x804280 <__xor16_67d_state>
     e5a:  d0 93 81 42   sts  0x4281, r29  ; 0x804281 <__xor16_67d_state+0x1>
xor16_67d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_67d.cpp:49
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_67d_state)::"r18","r19");
     e5e:  c0 91 80 42   lds  r28, 0x4280  ; 0x804280 <__xor16_67d_state>
     e62:  d0 91 81 42   lds  r29, 0x4281  ; 0x804281 <__xor16_67d_state+0x1>
     e66:  9e 01         movw  r18, r28
     e68:  22 0f         add  r18, r18
     e6a:  33 1f         adc  r19, r19
     e6c:  22 0f         add  r18, r18
     e6e:  33 1f         adc  r19, r19
     e70:  22 0f         add  r18, r18
     e72:  33 1f         adc  r19, r19
     e74:  22 0f         add  r18, r18
     e76:  33 1f         adc  r19, r19
     e78:  22 0f         add  r18, r18
     e7a:  33 1f         adc  r19, r19
     e7c:  22 0f         add  r18, r18
     e7e:  33 1f         adc  r19, r19
     e80:  c2 27         eor  r28, r18
     e82:  d3 27         eor  r29, r19
     e84:  9e 01         movw  r18, r28
     e86:  22 0f         add  r18, r18
     e88:  23 2f         mov  r18, r19
     e8a:  22 1f         adc  r18, r18
     e8c:  33 0b         sbc  r19, r19
     e8e:  31 95         neg  r19
     e90:  c2 27         eor  r28, r18
     e92:  d3 27         eor  r29, r19
     e94:  3c 2f         mov  r19, r28
     e96:  32 95         swap  r19
     e98:  33 0f         add  r19, r19
     e9a:  30 7e         andi  r19, 0xE0  ; 224
     e9c:  d3 27         eor  r29, r19
     e9e:  c0 93 80 42   sts  0x4280, r28  ; 0x804280 <__xor16_67d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:134
    seed_xor16_67d(seed);
    seed = xor16_67d();
    SERIALPORT.print("67d: ");
     ea2:  d0 93 81 42   sts  0x4281, r29  ; 0x804281 <__xor16_67d_state+0x1>
setup():
     ea6:  8b e7         ldi  r24, 0x7B  ; 123
     ea8:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:135
    SERIALPORT.println(seed);
     eaa:  8f da         rcall  .-2786     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     eac:  ce 01         movw  r24, r28
     eae:  91 da         rcall  .-2782     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_6b5():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6b5.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     eb0:  20 97         sbiw  r28, 0x00  ; 0
     eb2:  21 f0         breq  .+8        ; 0xebc <setup+0xa60>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6b5.cpp:13
    __xor16_6b5_state = seed;
     eb4:  c0 93 82 42   sts  0x4282, r28  ; 0x804282 <__xor16_6b5_state>
     eb8:  d0 93 83 42   sts  0x4283, r29  ; 0x804283 <__xor16_6b5_state+0x1>
xor16_6b5():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6b5.cpp:54
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_6b5_state)::"r18","r19");
     ebc:  c0 91 82 42   lds  r28, 0x4282  ; 0x804282 <__xor16_6b5_state>
     ec0:  d0 91 83 42   lds  r29, 0x4283  ; 0x804283 <__xor16_6b5_state+0x1>
     ec4:  9e 01         movw  r18, r28
     ec6:  22 0f         add  r18, r18
     ec8:  33 1f         adc  r19, r19
     eca:  22 0f         add  r18, r18
     ecc:  33 1f         adc  r19, r19
     ece:  22 0f         add  r18, r18
     ed0:  33 1f         adc  r19, r19
     ed2:  22 0f         add  r18, r18
     ed4:  33 1f         adc  r19, r19
     ed6:  22 0f         add  r18, r18
     ed8:  33 1f         adc  r19, r19
     eda:  22 0f         add  r18, r18
     edc:  33 1f         adc  r19, r19
     ede:  c2 27         eor  r28, r18
     ee0:  d3 27         eor  r29, r19
     ee2:  2d 2f         mov  r18, r29
     ee4:  26 95         lsr  r18
     ee6:  26 95         lsr  r18
     ee8:  26 95         lsr  r18
     eea:  c2 27         eor  r28, r18
     eec:  9e 01         movw  r18, r28
     eee:  22 0f         add  r18, r18
     ef0:  33 1f         adc  r19, r19
     ef2:  22 0f         add  r18, r18
     ef4:  33 1f         adc  r19, r19
     ef6:  22 0f         add  r18, r18
     ef8:  33 1f         adc  r19, r19
     efa:  22 0f         add  r18, r18
     efc:  33 1f         adc  r19, r19
     efe:  22 0f         add  r18, r18
     f00:  33 1f         adc  r19, r19
     f02:  c2 27         eor  r28, r18
     f04:  d3 27         eor  r29, r19
     f06:  c0 93 82 42   sts  0x4282, r28  ; 0x804282 <__xor16_6b5_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:138
    seed_xor16_6b5(seed);
    seed = xor16_6b5();
    SERIALPORT.print("6b5: ");
     f0a:  d0 93 83 42   sts  0x4283, r29  ; 0x804283 <__xor16_6b5_state+0x1>
setup():
     f0e:  81 e8         ldi  r24, 0x81  ; 129
     f10:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:139
    SERIALPORT.println(seed);
     f12:  5b da         rcall  .-2890     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     f14:  ce 01         movw  r24, r28
     f16:  5d da         rcall  .-2886     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_6f1():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6f1.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     f18:  20 97         sbiw  r28, 0x00  ; 0
     f1a:  21 f0         breq  .+8        ; 0xf24 <setup+0xac8>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6f1.cpp:13
    __xor16_6f1_state = seed;
     f1c:  c0 93 84 42   sts  0x4284, r28  ; 0x804284 <__xor16_6f1_state>
     f20:  d0 93 85 42   sts  0x4285, r29  ; 0x804285 <__xor16_6f1_state+0x1>
xor16_6f1():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_6f1.cpp:45
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_6f1_state)::"r18","r19");
     f24:  c0 91 84 42   lds  r28, 0x4284  ; 0x804284 <__xor16_6f1_state>
     f28:  d0 91 85 42   lds  r29, 0x4285  ; 0x804285 <__xor16_6f1_state+0x1>
     f2c:  9e 01         movw  r18, r28
     f2e:  22 0f         add  r18, r18
     f30:  33 1f         adc  r19, r19
     f32:  22 0f         add  r18, r18
     f34:  33 1f         adc  r19, r19
     f36:  22 0f         add  r18, r18
     f38:  33 1f         adc  r19, r19
     f3a:  22 0f         add  r18, r18
     f3c:  33 1f         adc  r19, r19
     f3e:  22 0f         add  r18, r18
     f40:  33 1f         adc  r19, r19
     f42:  22 0f         add  r18, r18
     f44:  33 1f         adc  r19, r19
     f46:  c2 27         eor  r28, r18
     f48:  d3 27         eor  r29, r19
     f4a:  d7 fb         bst  r29, 7
     f4c:  22 27         eor  r18, r18
     f4e:  20 f9         bld  r18, 0
     f50:  c2 27         eor  r28, r18
     f52:  9e 01         movw  r18, r28
     f54:  22 0f         add  r18, r18
     f56:  33 1f         adc  r19, r19
     f58:  c2 27         eor  r28, r18
     f5a:  d3 27         eor  r29, r19
     f5c:  c0 93 84 42   sts  0x4284, r28  ; 0x804284 <__xor16_6f1_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:142
    seed_xor16_6f1(seed);
    seed = xor16_6f1();
    SERIALPORT.print("6f1: ");
     f60:  d0 93 85 42   sts  0x4285, r29  ; 0x804285 <__xor16_6f1_state+0x1>
setup():
     f64:  87 e8         ldi  r24, 0x87  ; 135
     f66:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:143
    SERIALPORT.println(seed);
     f68:  30 da         rcall  .-2976     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     f6a:  ce 01         movw  r24, r28
     f6c:  32 da         rcall  .-2972     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_71b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_71b.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     f6e:  20 97         sbiw  r28, 0x00  ; 0
     f70:  21 f0         breq  .+8        ; 0xf7a <setup+0xb1e>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_71b.cpp:13
    __xor16_71b_state = seed;
     f72:  c0 93 86 42   sts  0x4286, r28  ; 0x804286 <__xor16_71b_state>
     f76:  d0 93 87 42   sts  0x4287, r29  ; 0x804287 <__xor16_71b_state+0x1>
xor16_71b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_71b.cpp:39
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_71b_state)::"r18","r19");
     f7a:  c0 91 86 42   lds  r28, 0x4286  ; 0x804286 <__xor16_71b_state>
     f7e:  d0 91 87 42   lds  r29, 0x4287  ; 0x804287 <__xor16_71b_state+0x1>
     f82:  9e 01         movw  r18, r28
     f84:  36 95         lsr  r19
     f86:  32 2f         mov  r19, r18
     f88:  22 27         eor  r18, r18
     f8a:  37 95         ror  r19
     f8c:  27 95         ror  r18
     f8e:  c2 27         eor  r28, r18
     f90:  d3 27         eor  r29, r19
     f92:  9e 01         movw  r18, r28
     f94:  36 95         lsr  r19
     f96:  27 95         ror  r18
     f98:  c2 27         eor  r28, r18
     f9a:  d3 27         eor  r29, r19
     f9c:  3c 2f         mov  r19, r28
     f9e:  33 0f         add  r19, r19
     fa0:  33 0f         add  r19, r19
     fa2:  33 0f         add  r19, r19
     fa4:  d3 27         eor  r29, r19
     fa6:  c0 93 86 42   sts  0x4286, r28  ; 0x804286 <__xor16_71b_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:146
    seed_xor16_71b(seed);
    seed = xor16_71b();
    SERIALPORT.print("71b: ");
     faa:  d0 93 87 42   sts  0x4287, r29  ; 0x804287 <__xor16_71b_state+0x1>
setup():
     fae:  8d e8         ldi  r24, 0x8D  ; 141
     fb0:  91 e4         ldi  r25, 0x41  ; 65
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:147
    SERIALPORT.println(seed);
     fb2:  0b da         rcall  .-3050     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
     fb4:  ce 01         movw  r24, r28
     fb6:  0d da         rcall  .-3046     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_734():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_734.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
     fb8:  20 97         sbiw  r28, 0x00  ; 0
     fba:  21 f0         breq  .+8        ; 0xfc4 <setup+0xb68>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_734.cpp:13
    __xor16_734_state = seed;
     fbc:  c0 93 88 42   sts  0x4288, r28  ; 0x804288 <__xor16_734_state>
     fc0:  d0 93 89 42   sts  0x4289, r29  ; 0x804289 <__xor16_734_state+0x1>
xor16_734():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_734.cpp:49
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_734_state)::"r18","r19");
     fc4:  c0 91 88 42   lds  r28, 0x4288  ; 0x804288 <__xor16_734_state>
     fc8:  d0 91 89 42   lds  r29, 0x4289  ; 0x804289 <__xor16_734_state+0x1>
     fcc:  9e 01         movw  r18, r28
     fce:  36 95         lsr  r19
     fd0:  32 2f         mov  r19, r18
     fd2:  22 27         eor  r18, r18
     fd4:  37 95         ror  r19
     fd6:  27 95         ror  r18
     fd8:  c2 27         eor  r28, r18
     fda:  d3 27         eor  r29, r19
     fdc:  9e 01         movw  r18, r28
     fde:  36 95         lsr  r19
     fe0:  27 95         ror  r18
     fe2:  36 95         lsr  r19
     fe4:  27 95         ror  r18
     fe6:  36 95         lsr  r19
     fe8:  27 95         ror  r18
     fea:  c2 27         eor  r28, r18
     fec:  d3 27         eor  r29, r19
     fee:  9e 01         movw  r18, r28
     ff0:  22 0f         add  r18, r18
     ff2:  33 1f         adc  r19, r19
     ff4:  22 0f         add  r18, r18
     ff6:  33 1f         adc  r19, r19
     ff8:  22 0f         add  r18, r18
     ffa:  33 1f         adc  r19, r19
     ffc:  22 0f         add  r18, r18
     ffe:  33 1f         adc  r19, r19
    1000:  c2 27         eor  r28, r18
    1002:  d3 27         eor  r29, r19
    1004:  c0 93 88 42   sts  0x4288, r28  ; 0x804288 <__xor16_734_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:150
    seed_xor16_734(seed);
    seed = xor16_734();
    SERIALPORT.print("734: ");
    1008:  d0 93 89 42   sts  0x4289, r29  ; 0x804289 <__xor16_734_state+0x1>
setup():
    100c:  83 e9         ldi  r24, 0x93  ; 147
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:151
    SERIALPORT.println(seed);
    100e:  91 e4         ldi  r25, 0x41  ; 65
    1010:  dc d9         rcall  .-3144     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    1012:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_798.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1014:  de d9         rcall  .-3140     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_798():
    1016:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_798.cpp:13
    __xor16_798_state = seed;
    1018:  21 f0         breq  .+8        ; 0x1022 <setup+0xbc6>
    101a:  c0 93 8a 42   sts  0x428A, r28  ; 0x80428a <__xor16_798_state>
    101e:  d0 93 8b 42   sts  0x428B, r29  ; 0x80428b <__xor16_798_state+0x1>
xor16_798():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_798.cpp:34
      "mov    r18, %B0"      "\n\t"
      "lsr    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_798_state)::"r18","r19");
    1022:  c0 91 8a 42   lds  r28, 0x428A  ; 0x80428a <__xor16_798_state>
    1026:  d0 91 8b 42   lds  r29, 0x428B  ; 0x80428b <__xor16_798_state+0x1>
    102a:  9e 01         movw  r18, r28
    102c:  36 95         lsr  r19
    102e:  32 2f         mov  r19, r18
    1030:  22 27         eor  r18, r18
    1032:  37 95         ror  r19
    1034:  27 95         ror  r18
    1036:  c2 27         eor  r28, r18
    1038:  d3 27         eor  r29, r19
    103a:  2d 2f         mov  r18, r29
    103c:  26 95         lsr  r18
    103e:  c2 27         eor  r28, r18
    1040:  3c 2f         mov  r19, r28
    1042:  d3 27         eor  r29, r19
    1044:  c0 93 8a 42   sts  0x428A, r28  ; 0x80428a <__xor16_798_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:154
    seed_xor16_798(seed);
    seed = xor16_798();
    SERIALPORT.print("798: ");
    1048:  d0 93 8b 42   sts  0x428B, r29  ; 0x80428b <__xor16_798_state+0x1>
setup():
    104c:  89 e9         ldi  r24, 0x99  ; 153
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:155
    SERIALPORT.println(seed);
    104e:  91 e4         ldi  r25, 0x41  ; 65
    1050:  bc d9         rcall  .-3208     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    1052:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_79d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1054:  be d9         rcall  .-3204     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_79d():
    1056:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_79d.cpp:13
    __xor16_79d_state = seed;
    1058:  21 f0         breq  .+8        ; 0x1062 <setup+0xc06>
    105a:  c0 93 8c 42   sts  0x428C, r28  ; 0x80428c <__xor16_79d_state>
    105e:  d0 93 8d 42   sts  0x428D, r29  ; 0x80428d <__xor16_79d_state+0x1>
xor16_79d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_79d.cpp:37
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_79d_state)::"r18","r19");
    1062:  c0 91 8c 42   lds  r28, 0x428C  ; 0x80428c <__xor16_79d_state>
    1066:  d0 91 8d 42   lds  r29, 0x428D  ; 0x80428d <__xor16_79d_state+0x1>
    106a:  9e 01         movw  r18, r28
    106c:  36 95         lsr  r19
    106e:  32 2f         mov  r19, r18
    1070:  22 27         eor  r18, r18
    1072:  37 95         ror  r19
    1074:  27 95         ror  r18
    1076:  c2 27         eor  r28, r18
    1078:  d3 27         eor  r29, r19
    107a:  2d 2f         mov  r18, r29
    107c:  26 95         lsr  r18
    107e:  c2 27         eor  r28, r18
    1080:  3c 2f         mov  r19, r28
    1082:  32 95         swap  r19
    1084:  33 0f         add  r19, r19
    1086:  30 7e         andi  r19, 0xE0  ; 224
    1088:  d3 27         eor  r29, r19
    108a:  c0 93 8c 42   sts  0x428C, r28  ; 0x80428c <__xor16_79d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:158
    seed_xor16_79d(seed);
    seed = xor16_79d();
    SERIALPORT.print("79d: ");
    108e:  d0 93 8d 42   sts  0x428D, r29  ; 0x80428d <__xor16_79d_state+0x1>
setup():
    1092:  8f e9         ldi  r24, 0x9F  ; 159
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:159
    SERIALPORT.println(seed);
    1094:  91 e4         ldi  r25, 0x41  ; 65
    1096:  99 d9         rcall  .-3278     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    1098:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_7f1.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    109a:  9b d9         rcall  .-3274     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_7f1():
    109c:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_7f1.cpp:13
    __xor16_7f1_state = seed;
    109e:  21 f0         breq  .+8        ; 0x10a8 <setup+0xc4c>
    10a0:  c0 93 8e 42   sts  0x428E, r28  ; 0x80428e <__xor16_7f1_state>
    10a4:  d0 93 8f 42   sts  0x428F, r29  ; 0x80428f <__xor16_7f1_state+0x1>
xor16_7f1():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_7f1.cpp:38
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_7f1_state)::"r18","r19");
    10a8:  c0 91 8e 42   lds  r28, 0x428E  ; 0x80428e <__xor16_7f1_state>
    10ac:  d0 91 8f 42   lds  r29, 0x428F  ; 0x80428f <__xor16_7f1_state+0x1>
    10b0:  9e 01         movw  r18, r28
    10b2:  36 95         lsr  r19
    10b4:  32 2f         mov  r19, r18
    10b6:  22 27         eor  r18, r18
    10b8:  37 95         ror  r19
    10ba:  27 95         ror  r18
    10bc:  c2 27         eor  r28, r18
    10be:  d3 27         eor  r29, r19
    10c0:  d7 fb         bst  r29, 7
    10c2:  22 27         eor  r18, r18
    10c4:  20 f9         bld  r18, 0
    10c6:  c2 27         eor  r28, r18
    10c8:  9e 01         movw  r18, r28
    10ca:  22 0f         add  r18, r18
    10cc:  33 1f         adc  r19, r19
    10ce:  c2 27         eor  r28, r18
    10d0:  d3 27         eor  r29, r19
    10d2:  c0 93 8e 42   sts  0x428E, r28  ; 0x80428e <__xor16_7f1_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:162
    seed_xor16_7f1(seed);
    seed = xor16_7f1();
    SERIALPORT.print("7f1: ");
    10d6:  d0 93 8f 42   sts  0x428F, r29  ; 0x80428f <__xor16_7f1_state+0x1>
setup():
    10da:  85 ea         ldi  r24, 0xA5  ; 165
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:163
    SERIALPORT.println(seed);
    10dc:  91 e4         ldi  r25, 0x41  ; 65
    10de:  75 d9         rcall  .-3350     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    10e0:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_895.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    10e2:  77 d9         rcall  .-3346     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_895():
    10e4:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_895.cpp:13
    __xor16_895_state = seed;
    10e6:  21 f0         breq  .+8        ; 0x10f0 <setup+0xc94>
    10e8:  c0 93 90 42   sts  0x4290, r28  ; 0x804290 <__xor16_895_state>
    10ec:  d0 93 91 42   sts  0x4291, r29  ; 0x804291 <__xor16_895_state+0x1>
xor16_895():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_895.cpp:39
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_895_state)::"r18","r19");
    10f0:  c0 91 90 42   lds  r28, 0x4290  ; 0x804290 <__xor16_895_state>
    10f4:  d0 91 91 42   lds  r29, 0x4291  ; 0x804291 <__xor16_895_state+0x1>
    10f8:  3c 2f         mov  r19, r28
    10fa:  d3 27         eor  r29, r19
    10fc:  2d 2f         mov  r18, r29
    10fe:  26 95         lsr  r18
    1100:  c2 27         eor  r28, r18
    1102:  9e 01         movw  r18, r28
    1104:  22 0f         add  r18, r18
    1106:  33 1f         adc  r19, r19
    1108:  22 0f         add  r18, r18
    110a:  33 1f         adc  r19, r19
    110c:  22 0f         add  r18, r18
    110e:  33 1f         adc  r19, r19
    1110:  22 0f         add  r18, r18
    1112:  33 1f         adc  r19, r19
    1114:  22 0f         add  r18, r18
    1116:  33 1f         adc  r19, r19
    1118:  c2 27         eor  r28, r18
    111a:  d3 27         eor  r29, r19
    111c:  c0 93 90 42   sts  0x4290, r28  ; 0x804290 <__xor16_895_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:166
    seed_xor16_895(seed);
    seed = xor16_895();
    SERIALPORT.print("895: ");
    1120:  d0 93 91 42   sts  0x4291, r29  ; 0x804291 <__xor16_895_state+0x1>
setup():
    1124:  8b ea         ldi  r24, 0xAB  ; 171
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:167
    SERIALPORT.println(seed);
    1126:  91 e4         ldi  r25, 0x41  ; 65
    1128:  50 d9         rcall  .-3424     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    112a:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_897.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    112c:  52 d9         rcall  .-3420     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_897():
    112e:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_897.cpp:13
    __xor16_897_state = seed;
    1130:  21 f0         breq  .+8        ; 0x113a <setup+0xcde>
    1132:  c0 93 92 42   sts  0x4292, r28  ; 0x804292 <__xor16_897_state>
    1136:  d0 93 93 42   sts  0x4293, r29  ; 0x804293 <__xor16_897_state+0x1>
xor16_897():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_897.cpp:34
      "eor    r18, r18"      "\n\t"
      "ror    r19"           "\n\t"
      "ror    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_897_state)::"r18","r19");
    113a:  c0 91 92 42   lds  r28, 0x4292  ; 0x804292 <__xor16_897_state>
    113e:  d0 91 93 42   lds  r29, 0x4293  ; 0x804293 <__xor16_897_state+0x1>
    1142:  3c 2f         mov  r19, r28
    1144:  d3 27         eor  r29, r19
    1146:  2d 2f         mov  r18, r29
    1148:  26 95         lsr  r18
    114a:  c2 27         eor  r28, r18
    114c:  9e 01         movw  r18, r28
    114e:  36 95         lsr  r19
    1150:  32 2f         mov  r19, r18
    1152:  22 27         eor  r18, r18
    1154:  37 95         ror  r19
    1156:  27 95         ror  r18
    1158:  c2 27         eor  r28, r18
    115a:  d3 27         eor  r29, r19
    115c:  c0 93 92 42   sts  0x4292, r28  ; 0x804292 <__xor16_897_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:170
    seed_xor16_897(seed);
    seed = xor16_897();
    SERIALPORT.print("897: ");
    1160:  d0 93 93 42   sts  0x4293, r29  ; 0x804293 <__xor16_897_state+0x1>
setup():
    1164:  81 eb         ldi  r24, 0xB1  ; 177
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:171
    SERIALPORT.println(seed);
    1166:  91 e4         ldi  r25, 0x41  ; 65
    1168:  30 d9         rcall  .-3488     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    116a:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_97d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    116c:  32 d9         rcall  .-3484     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_97d():
    116e:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_97d.cpp:13
    __xor16_97d_state = seed;
    1170:  21 f0         breq  .+8        ; 0x117a <setup+0xd1e>
    1172:  c0 93 94 42   sts  0x4294, r28  ; 0x804294 <__xor16_97d_state>
    1176:  d0 93 95 42   sts  0x4295, r29  ; 0x804295 <__xor16_97d_state+0x1>
xor16_97d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_97d.cpp:37
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_97d_state)::"r18","r19");
    117a:  c0 91 94 42   lds  r28, 0x4294  ; 0x804294 <__xor16_97d_state>
    117e:  d0 91 95 42   lds  r29, 0x4295  ; 0x804295 <__xor16_97d_state+0x1>
    1182:  3c 2f         mov  r19, r28
    1184:  33 0f         add  r19, r19
    1186:  d3 27         eor  r29, r19
    1188:  9e 01         movw  r18, r28
    118a:  22 0f         add  r18, r18
    118c:  23 2f         mov  r18, r19
    118e:  22 1f         adc  r18, r18
    1190:  33 0b         sbc  r19, r19
    1192:  31 95         neg  r19
    1194:  c2 27         eor  r28, r18
    1196:  d3 27         eor  r29, r19
    1198:  3c 2f         mov  r19, r28
    119a:  32 95         swap  r19
    119c:  33 0f         add  r19, r19
    119e:  30 7e         andi  r19, 0xE0  ; 224
    11a0:  d3 27         eor  r29, r19
    11a2:  c0 93 94 42   sts  0x4294, r28  ; 0x804294 <__xor16_97d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:174
    seed_xor16_97d(seed);
    seed = xor16_97d();
    SERIALPORT.print("97d: ");
    11a6:  d0 93 95 42   sts  0x4295, r29  ; 0x804295 <__xor16_97d_state+0x1>
setup():
    11aa:  87 eb         ldi  r24, 0xB7  ; 183
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:175
    SERIALPORT.println(seed);
    11ac:  91 e4         ldi  r25, 0x41  ; 65
    11ae:  0d d9         rcall  .-3558     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    11b0:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_9d3.cpp:13
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    11b2:  0f d9         rcall  .-3554     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_9d3():
    11b4:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_9d3.cpp:14
    __xor16_9d3_state = seed;
    11b6:  21 f0         breq  .+8        ; 0x11c0 <setup+0xd64>
    11b8:  c0 93 96 42   sts  0x4296, r28  ; 0x804296 <__xor16_9d3_state>
    11bc:  d0 93 97 42   sts  0x4297, r29  ; 0x804297 <__xor16_9d3_state+0x1>
xor16_9d3():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_9d3.cpp:39
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_9d3_state)::"r18","r19");
    11c0:  c0 91 96 42   lds  r28, 0x4296  ; 0x804296 <__xor16_9d3_state>
    11c4:  d0 91 97 42   lds  r29, 0x4297  ; 0x804297 <__xor16_9d3_state+0x1>
    11c8:  3c 2f         mov  r19, r28
    11ca:  33 0f         add  r19, r19
    11cc:  d3 27         eor  r29, r19
    11ce:  2d 2f         mov  r18, r29
    11d0:  22 95         swap  r18
    11d2:  26 95         lsr  r18
    11d4:  27 70         andi  r18, 0x07  ; 7
    11d6:  c2 27         eor  r28, r18
    11d8:  9e 01         movw  r18, r28
    11da:  22 0f         add  r18, r18
    11dc:  33 1f         adc  r19, r19
    11de:  22 0f         add  r18, r18
    11e0:  33 1f         adc  r19, r19
    11e2:  22 0f         add  r18, r18
    11e4:  33 1f         adc  r19, r19
    11e6:  c2 27         eor  r28, r18
    11e8:  d3 27         eor  r29, r19
    11ea:  c0 93 96 42   sts  0x4296, r28  ; 0x804296 <__xor16_9d3_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:178
    seed_xor16_9d3(seed);
    seed = xor16_9d3();
    SERIALPORT.print("9d3: ");
    11ee:  d0 93 97 42   sts  0x4297, r29  ; 0x804297 <__xor16_9d3_state+0x1>
setup():
    11f2:  8d eb         ldi  r24, 0xBD  ; 189
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:179
    SERIALPORT.println(seed);
    11f4:  91 e4         ldi  r25, 0x41  ; 65
    11f6:  e9 d8         rcall  .-3630     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    11f8:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b17.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    11fa:  eb d8         rcall  .-3626     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_b17():
    11fc:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b17.cpp:13
    __xor16_b17_state = seed;
    11fe:  21 f0         breq  .+8        ; 0x1208 <setup+0xdac>
    1200:  c0 93 98 42   sts  0x4298, r28  ; 0x804298 <__xor16_b17_state>
    1204:  d0 93 99 42   sts  0x4299, r29  ; 0x804299 <__xor16_b17_state+0x1>
xor16_b17():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b17.cpp:39
      "eor    r18, r18"      "\n\t"
      "ror    r19"           "\n\t"
      "ror    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_b17_state)::"r18","r19");
    1208:  c0 91 98 42   lds  r28, 0x4298  ; 0x804298 <__xor16_b17_state>
    120c:  d0 91 99 42   lds  r29, 0x4299  ; 0x804299 <__xor16_b17_state+0x1>
    1210:  3c 2f         mov  r19, r28
    1212:  33 0f         add  r19, r19
    1214:  33 0f         add  r19, r19
    1216:  33 0f         add  r19, r19
    1218:  d3 27         eor  r29, r19
    121a:  9e 01         movw  r18, r28
    121c:  36 95         lsr  r19
    121e:  27 95         ror  r18
    1220:  c2 27         eor  r28, r18
    1222:  d3 27         eor  r29, r19
    1224:  9e 01         movw  r18, r28
    1226:  36 95         lsr  r19
    1228:  32 2f         mov  r19, r18
    122a:  22 27         eor  r18, r18
    122c:  37 95         ror  r19
    122e:  27 95         ror  r18
    1230:  c2 27         eor  r28, r18
    1232:  d3 27         eor  r29, r19
    1234:  c0 93 98 42   sts  0x4298, r28  ; 0x804298 <__xor16_b17_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:182
    seed_xor16_b17(seed);
    seed = xor16_b17();
    SERIALPORT.print("b17: ");
    1238:  d0 93 99 42   sts  0x4299, r29  ; 0x804299 <__xor16_b17_state+0x1>
setup():
    123c:  83 ec         ldi  r24, 0xC3  ; 195
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:183
    SERIALPORT.println(seed);
    123e:  91 e4         ldi  r25, 0x41  ; 65
    1240:  c4 d8         rcall  .-3704     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    1242:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b3d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1244:  c6 d8         rcall  .-3700     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_b3d():
    1246:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b3d.cpp:13
    __xor16_b3d_state = seed;
    1248:  21 f0         breq  .+8        ; 0x1252 <setup+0xdf6>
    124a:  c0 93 9a 42   sts  0x429A, r28  ; 0x80429a <__xor16_b3d_state>
    124e:  d0 93 9b 42   sts  0x429B, r29  ; 0x80429b <__xor16_b3d_state+0x1>
xor16_b3d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b3d.cpp:40
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_b3d_state)::"r18","r19");
    1252:  c0 91 9a 42   lds  r28, 0x429A  ; 0x80429a <__xor16_b3d_state>
    1256:  d0 91 9b 42   lds  r29, 0x429B  ; 0x80429b <__xor16_b3d_state+0x1>
    125a:  3c 2f         mov  r19, r28
    125c:  33 0f         add  r19, r19
    125e:  33 0f         add  r19, r19
    1260:  33 0f         add  r19, r19
    1262:  d3 27         eor  r29, r19
    1264:  9e 01         movw  r18, r28
    1266:  36 95         lsr  r19
    1268:  27 95         ror  r18
    126a:  36 95         lsr  r19
    126c:  27 95         ror  r18
    126e:  36 95         lsr  r19
    1270:  27 95         ror  r18
    1272:  c2 27         eor  r28, r18
    1274:  d3 27         eor  r29, r19
    1276:  3c 2f         mov  r19, r28
    1278:  32 95         swap  r19
    127a:  33 0f         add  r19, r19
    127c:  30 7e         andi  r19, 0xE0  ; 224
    127e:  d3 27         eor  r29, r19
    1280:  c0 93 9a 42   sts  0x429A, r28  ; 0x80429a <__xor16_b3d_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:186
    seed_xor16_b3d(seed);
    seed = xor16_b3d();
    SERIALPORT.print("b3d: ");
    1284:  d0 93 9b 42   sts  0x429B, r29  ; 0x80429b <__xor16_b3d_state+0x1>
setup():
    1288:  89 ec         ldi  r24, 0xC9  ; 201
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:187
    SERIALPORT.println(seed);
    128a:  91 e4         ldi  r25, 0x41  ; 65
    128c:  9e d8         rcall  .-3780     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    128e:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b53.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1290:  a0 d8         rcall  .-3776     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_b53():
    1292:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b53.cpp:13
    __xor16_b53_state = seed;
    1294:  21 f0         breq  .+8        ; 0x129e <setup+0xe42>
    1296:  c0 93 9c 42   sts  0x429C, r28  ; 0x80429c <__xor16_b53_state>
    129a:  d0 93 9d 42   sts  0x429D, r29  ; 0x80429d <__xor16_b53_state+0x1>
xor16_b53():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b53.cpp:48
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_b53_state)::"r18","r19");
    129e:  c0 91 9c 42   lds  r28, 0x429C  ; 0x80429c <__xor16_b53_state>
    12a2:  d0 91 9d 42   lds  r29, 0x429D  ; 0x80429d <__xor16_b53_state+0x1>
    12a6:  3c 2f         mov  r19, r28
    12a8:  33 0f         add  r19, r19
    12aa:  33 0f         add  r19, r19
    12ac:  33 0f         add  r19, r19
    12ae:  d3 27         eor  r29, r19
    12b0:  9e 01         movw  r18, r28
    12b2:  36 95         lsr  r19
    12b4:  27 95         ror  r18
    12b6:  36 95         lsr  r19
    12b8:  27 95         ror  r18
    12ba:  36 95         lsr  r19
    12bc:  27 95         ror  r18
    12be:  36 95         lsr  r19
    12c0:  27 95         ror  r18
    12c2:  36 95         lsr  r19
    12c4:  27 95         ror  r18
    12c6:  c2 27         eor  r28, r18
    12c8:  d3 27         eor  r29, r19
    12ca:  9e 01         movw  r18, r28
    12cc:  22 0f         add  r18, r18
    12ce:  33 1f         adc  r19, r19
    12d0:  22 0f         add  r18, r18
    12d2:  33 1f         adc  r19, r19
    12d4:  22 0f         add  r18, r18
    12d6:  33 1f         adc  r19, r19
    12d8:  c2 27         eor  r28, r18
    12da:  d3 27         eor  r29, r19
    12dc:  c0 93 9c 42   sts  0x429C, r28  ; 0x80429c <__xor16_b53_state>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:190
    seed_xor16_b53(seed);
    seed = xor16_b53();
    SERIALPORT.print("b53: ");
    12e0:  d0 93 9d 42   sts  0x429D, r29  ; 0x80429d <__xor16_b53_state+0x1>
setup():
    12e4:  8f ec         ldi  r24, 0xCF  ; 207
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:191
    SERIALPORT.println(seed);
    12e6:  91 e4         ldi  r25, 0x41  ; 65
    12e8:  70 d8         rcall  .-3872     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    12ea:  ce 01         movw  r24, r28
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b71.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    12ec:  72 d8         rcall  .-3868     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_b71():
    12ee:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b71.cpp:13
    __xor16_b71_state = seed;
    12f0:  21 f0         breq  .+8        ; 0x12fa <setup+0xe9e>
    12f2:  c0 93 9e 42   sts  0x429E, r28  ; 0x80429e <__xor16_b71_state>
    12f6:  d0 93 9f 42   sts  0x429F, r29  ; 0x80429f <__xor16_b71_state+0x1>
xor16_b71():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_b71.cpp:39
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_b71_state)::"r18","r19");
    12fa:  c0 91 9e 42   lds  r28, 0x429E  ; 0x80429e <__xor16_b71_state>
    12fe:  d0 91 9f 42   lds  r29, 0x429F  ; 0x80429f <__xor16_b71_state+0x1>
    1302:  3c 2f         mov  r19, r28
    1304:  33 0f         add  r19, r19
    1306:  33 0f         add  r19, r19
    1308:  33 0f         add  r19, r19
    130a:  d3 27         eor  r29, r19
    130c:  9e 01         movw  r18, r28
    130e:  22 0f         add  r18, r18
    1310:  23 2f         mov  r18, r19
    1312:  22 1f         adc  r18, r18
    1314:  33 0b         sbc  r19, r19
    1316:  31 95         neg  r19
    1318:  c2 27         eor  r28, r18
    131a:  d3 27         eor  r29, r19
    131c:  9e 01         movw  r18, r28
    131e:  22 0f         add  r18, r18
    1320:  33 1f         adc  r19, r19
    1322:  c2 27         eor  r28, r18
    1324:  d3 27         eor  r29, r19
    1326:  c0 93 9e 42   sts  0x429E, r28  ; 0x80429e <__xor16_b71_state>
    132a:  d0 93 9f 42   sts  0x429F, r29  ; 0x80429f <__xor16_b71_state+0x1>
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:194
    seed_xor16_b71(seed);
    seed = xor16_b71();
    SERIALPORT.print("b71: ");
    132e:  85 ed         ldi  r24, 0xD5  ; 213
    1330:  91 e4         ldi  r25, 0x41  ; 65
    1332:  4b d8         rcall  .-3946     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:195
    SERIALPORT.println(seed);
    1334:  ce 01         movw  r24, r28
    1336:  4d d8         rcall  .-3942     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_bb3():
    1338:  20 97         sbiw  r28, 0x00  ; 0
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb3.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    133a:  21 f0         breq  .+8        ; 0x1344 <setup+0xee8>
    133c:  c0 93 a0 42   sts  0x42A0, r28  ; 0x8042a0 <__xor16_bb3_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb3.cpp:13
    __xor16_bb3_state = seed;
    1340:  d0 93 a1 42   sts  0x42A1, r29  ; 0x8042a1 <__xor16_bb3_state+0x1>
xor16_bb3():
    1344:  c0 91 a0 42   lds  r28, 0x42A0  ; 0x8042a0 <__xor16_bb3_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb3.cpp:40
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_bb3_state)::"r18","r19");
    1348:  d0 91 a1 42   lds  r29, 0x42A1  ; 0x8042a1 <__xor16_bb3_state+0x1>
    134c:  3c 2f         mov  r19, r28
    134e:  33 0f         add  r19, r19
    1350:  33 0f         add  r19, r19
    1352:  33 0f         add  r19, r19
    1354:  d3 27         eor  r29, r19
    1356:  2d 2f         mov  r18, r29
    1358:  26 95         lsr  r18
    135a:  26 95         lsr  r18
    135c:  26 95         lsr  r18
    135e:  c2 27         eor  r28, r18
    1360:  9e 01         movw  r18, r28
    1362:  22 0f         add  r18, r18
    1364:  33 1f         adc  r19, r19
    1366:  22 0f         add  r18, r18
    1368:  33 1f         adc  r19, r19
    136a:  22 0f         add  r18, r18
    136c:  33 1f         adc  r19, r19
    136e:  c2 27         eor  r28, r18
    1370:  d3 27         eor  r29, r19
    1372:  c0 93 a0 42   sts  0x42A0, r28  ; 0x8042a0 <__xor16_bb3_state>
    1376:  d0 93 a1 42   sts  0x42A1, r29  ; 0x8042a1 <__xor16_bb3_state+0x1>
setup():
    137a:  8b ed         ldi  r24, 0xDB  ; 219
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:198
    seed_xor16_bb3(seed);
    seed = xor16_bb3();
    SERIALPORT.print("bb3: ");
    137c:  91 e4         ldi  r25, 0x41  ; 65
    137e:  25 d8         rcall  .-4022     ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
    1380:  ce 01         movw  r24, r28
    1382:  27 d8         rcall  .-4018     ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_bb4():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:199
    SERIALPORT.println(seed);
    1384:  20 97         sbiw  r28, 0x00  ; 0
    1386:  21 f0         breq  .+8        ; 0x1390 <setup+0xf34>
    1388:  c0 93 a2 42   sts  0x42A2, r28  ; 0x8042a2 <__xor16_bb4_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb4.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    138c:  d0 93 a3 42   sts  0x42A3, r29  ; 0x8042a3 <__xor16_bb4_state+0x1>
xor16_bb4():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb4.cpp:13
    __xor16_bb4_state = seed;
    1390:  c0 91 a2 42   lds  r28, 0x42A2  ; 0x8042a2 <__xor16_bb4_state>
    1394:  d0 91 a3 42   lds  r29, 0x42A3  ; 0x8042a3 <__xor16_bb4_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb4.cpp:42
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_bb4_state)::"r18","r19");
    1398:  3c 2f         mov  r19, r28
    139a:  33 0f         add  r19, r19
    139c:  33 0f         add  r19, r19
    139e:  33 0f         add  r19, r19
    13a0:  d3 27         eor  r29, r19
    13a2:  2d 2f         mov  r18, r29
    13a4:  26 95         lsr  r18
    13a6:  26 95         lsr  r18
    13a8:  26 95         lsr  r18
    13aa:  c2 27         eor  r28, r18
    13ac:  9e 01         movw  r18, r28
    13ae:  22 0f         add  r18, r18
    13b0:  33 1f         adc  r19, r19
    13b2:  22 0f         add  r18, r18
    13b4:  33 1f         adc  r19, r19
    13b6:  22 0f         add  r18, r18
    13b8:  33 1f         adc  r19, r19
    13ba:  22 0f         add  r18, r18
    13bc:  33 1f         adc  r19, r19
    13be:  c2 27         eor  r28, r18
    13c0:  d3 27         eor  r29, r19
    13c2:  c0 93 a2 42   sts  0x42A2, r28  ; 0x8042a2 <__xor16_bb4_state>
    13c6:  d0 93 a3 42   sts  0x42A3, r29  ; 0x8042a3 <__xor16_bb4_state+0x1>
setup():
    13ca:  81 ee         ldi  r24, 0xE1  ; 225
    13cc:  91 e4         ldi  r25, 0x41  ; 65
    13ce:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:202
    seed_xor16_bb4(seed);
    seed = xor16_bb4();
    SERIALPORT.print("bb4: ");
    13d2:  ce 01         movw  r24, r28
    13d4:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_bb5():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:203
    SERIALPORT.println(seed);
    13d8:  20 97         sbiw  r28, 0x00  ; 0
    13da:  21 f0         breq  .+8        ; 0x13e4 <setup+0xf88>
    13dc:  c0 93 a4 42   sts  0x42A4, r28  ; 0x8042a4 <__xor16_bb5_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb5.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    13e0:  d0 93 a5 42   sts  0x42A5, r29  ; 0x8042a5 <__xor16_bb5_state+0x1>
xor16_bb5():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb5.cpp:13
    __xor16_bb5_state = seed;
    13e4:  c0 91 a4 42   lds  r28, 0x42A4  ; 0x8042a4 <__xor16_bb5_state>
    13e8:  d0 91 a5 42   lds  r29, 0x42A5  ; 0x8042a5 <__xor16_bb5_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_bb5.cpp:44
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_bb5_state)::"r18","r19");
    13ec:  3c 2f         mov  r19, r28
    13ee:  33 0f         add  r19, r19
    13f0:  33 0f         add  r19, r19
    13f2:  33 0f         add  r19, r19
    13f4:  d3 27         eor  r29, r19
    13f6:  2d 2f         mov  r18, r29
    13f8:  26 95         lsr  r18
    13fa:  26 95         lsr  r18
    13fc:  26 95         lsr  r18
    13fe:  c2 27         eor  r28, r18
    1400:  9e 01         movw  r18, r28
    1402:  22 0f         add  r18, r18
    1404:  33 1f         adc  r19, r19
    1406:  22 0f         add  r18, r18
    1408:  33 1f         adc  r19, r19
    140a:  22 0f         add  r18, r18
    140c:  33 1f         adc  r19, r19
    140e:  22 0f         add  r18, r18
    1410:  33 1f         adc  r19, r19
    1412:  22 0f         add  r18, r18
    1414:  33 1f         adc  r19, r19
    1416:  c2 27         eor  r28, r18
    1418:  d3 27         eor  r29, r19
    141a:  c0 93 a4 42   sts  0x42A4, r28  ; 0x8042a4 <__xor16_bb5_state>
    141e:  d0 93 a5 42   sts  0x42A5, r29  ; 0x8042a5 <__xor16_bb5_state+0x1>
setup():
    1422:  87 ee         ldi  r24, 0xE7  ; 231
    1424:  91 e4         ldi  r25, 0x41  ; 65
    1426:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:206
    seed_xor16_bb5(seed);
    seed = xor16_bb5();
    SERIALPORT.print("bb5: ");
    142a:  ce 01         movw  r24, r28
    142c:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_c13():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:207
    SERIALPORT.println(seed);
    1430:  20 97         sbiw  r28, 0x00  ; 0
    1432:  21 f0         breq  .+8        ; 0x143c <setup+0xfe0>
    1434:  c0 93 a6 42   sts  0x42A6, r28  ; 0x8042a6 <__xor16_c13_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c13.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1438:  d0 93 a7 42   sts  0x42A7, r29  ; 0x8042a7 <__xor16_c13_state+0x1>
xor16_c13():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c13.cpp:13
    __xor16_c13_state = seed;
    143c:  c0 91 a6 42   lds  r28, 0x42A6  ; 0x8042a6 <__xor16_c13_state>
    1440:  d0 91 a7 42   lds  r29, 0x42A7  ; 0x8042a7 <__xor16_c13_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c13.cpp:39
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_c13_state)::"r18","r19");
    1444:  3c 2f         mov  r19, r28
    1446:  32 95         swap  r19
    1448:  30 7f         andi  r19, 0xF0  ; 240
    144a:  d3 27         eor  r29, r19
    144c:  9e 01         movw  r18, r28
    144e:  36 95         lsr  r19
    1450:  27 95         ror  r18
    1452:  c2 27         eor  r28, r18
    1454:  d3 27         eor  r29, r19
    1456:  9e 01         movw  r18, r28
    1458:  22 0f         add  r18, r18
    145a:  33 1f         adc  r19, r19
    145c:  22 0f         add  r18, r18
    145e:  33 1f         adc  r19, r19
    1460:  22 0f         add  r18, r18
    1462:  33 1f         adc  r19, r19
    1464:  c2 27         eor  r28, r18
    1466:  d3 27         eor  r29, r19
    1468:  c0 93 a6 42   sts  0x42A6, r28  ; 0x8042a6 <__xor16_c13_state>
    146c:  d0 93 a7 42   sts  0x42A7, r29  ; 0x8042a7 <__xor16_c13_state+0x1>
setup():
    1470:  8d ee         ldi  r24, 0xED  ; 237
    1472:  91 e4         ldi  r25, 0x41  ; 65
    1474:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:210
    seed_xor16_c13(seed);
    seed = xor16_c13();
    SERIALPORT.print("c13: ");
    1478:  ce 01         movw  r24, r28
    147a:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d3b():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:211
    SERIALPORT.println(seed);
    147e:  20 97         sbiw  r28, 0x00  ; 0
    1480:  21 f0         breq  .+8        ; 0x148a <setup+0x102e>
    1482:  c0 93 a8 42   sts  0x42A8, r28  ; 0x8042a8 <__xor16_d3b_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3b.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1486:  d0 93 a9 42   sts  0x42A9, r29  ; 0x8042a9 <__xor16_d3b_state+0x1>
xor16_d3b():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3b.cpp:13
    __xor16_d3b_state = seed;
    148a:  c0 91 a8 42   lds  r28, 0x42A8  ; 0x8042a8 <__xor16_d3b_state>
    148e:  d0 91 a9 42   lds  r29, 0x42A9  ; 0x8042a9 <__xor16_d3b_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3b.cpp:40
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d3b_state)::"r18","r19");
    1492:  3c 2f         mov  r19, r28
    1494:  32 95         swap  r19
    1496:  33 0f         add  r19, r19
    1498:  30 7e         andi  r19, 0xE0  ; 224
    149a:  d3 27         eor  r29, r19
    149c:  9e 01         movw  r18, r28
    149e:  36 95         lsr  r19
    14a0:  27 95         ror  r18
    14a2:  36 95         lsr  r19
    14a4:  27 95         ror  r18
    14a6:  36 95         lsr  r19
    14a8:  27 95         ror  r18
    14aa:  c2 27         eor  r28, r18
    14ac:  d3 27         eor  r29, r19
    14ae:  3c 2f         mov  r19, r28
    14b0:  33 0f         add  r19, r19
    14b2:  33 0f         add  r19, r19
    14b4:  33 0f         add  r19, r19
    14b6:  d3 27         eor  r29, r19
    14b8:  c0 93 a8 42   sts  0x42A8, r28  ; 0x8042a8 <__xor16_d3b_state>
    14bc:  d0 93 a9 42   sts  0x42A9, r29  ; 0x8042a9 <__xor16_d3b_state+0x1>
setup():
    14c0:  83 ef         ldi  r24, 0xF3  ; 243
    14c2:  91 e4         ldi  r25, 0x41  ; 65
    14c4:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:214
    seed_xor16_d3b(seed);
    seed = xor16_d3b();
    SERIALPORT.print("d3b: ");
    14c8:  ce 01         movw  r24, r28
    14ca:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_c3d():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:215
    SERIALPORT.println(seed);
    14ce:  20 97         sbiw  r28, 0x00  ; 0
    14d0:  21 f0         breq  .+8        ; 0x14da <setup+0x107e>
    14d2:  c0 93 aa 42   sts  0x42AA, r28  ; 0x8042aa <__xor16_c3d_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c3d.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    14d6:  d0 93 ab 42   sts  0x42AB, r29  ; 0x8042ab <__xor16_c3d_state+0x1>
xor16_c3d():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c3d.cpp:13
    __xor16_c3d_state = seed;
    14da:  c0 91 aa 42   lds  r28, 0x42AA  ; 0x8042aa <__xor16_c3d_state>
    14de:  d0 91 ab 42   lds  r29, 0x42AB  ; 0x8042ab <__xor16_c3d_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_c3d.cpp:39
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "add    r19, r19"      "\n\t"
      "andi   r19, 0xE0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_c3d_state)::"r18","r19");
    14e2:  3c 2f         mov  r19, r28
    14e4:  32 95         swap  r19
    14e6:  30 7f         andi  r19, 0xF0  ; 240
    14e8:  d3 27         eor  r29, r19
    14ea:  9e 01         movw  r18, r28
    14ec:  36 95         lsr  r19
    14ee:  27 95         ror  r18
    14f0:  36 95         lsr  r19
    14f2:  27 95         ror  r18
    14f4:  36 95         lsr  r19
    14f6:  27 95         ror  r18
    14f8:  c2 27         eor  r28, r18
    14fa:  d3 27         eor  r29, r19
    14fc:  3c 2f         mov  r19, r28
    14fe:  32 95         swap  r19
    1500:  33 0f         add  r19, r19
    1502:  30 7e         andi  r19, 0xE0  ; 224
    1504:  d3 27         eor  r29, r19
    1506:  c0 93 aa 42   sts  0x42AA, r28  ; 0x8042aa <__xor16_c3d_state>
    150a:  d0 93 ab 42   sts  0x42AB, r29  ; 0x8042ab <__xor16_c3d_state+0x1>
setup():
    150e:  89 ef         ldi  r24, 0xF9  ; 249
    1510:  91 e4         ldi  r25, 0x41  ; 65
    1512:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:218
    seed_xor16_c3d(seed);
    seed = xor16_c3d();
    SERIALPORT.print("c3d: ");
    1516:  ce 01         movw  r24, r28
    1518:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d3c():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:219
    SERIALPORT.println(seed);
    151c:  20 97         sbiw  r28, 0x00  ; 0
    151e:  21 f0         breq  .+8        ; 0x1528 <setup+0x10cc>
    1520:  c0 93 ac 42   sts  0x42AC, r28  ; 0x8042ac <__xor16_d3c_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3c.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1524:  d0 93 ad 42   sts  0x42AD, r29  ; 0x8042ad <__xor16_d3c_state+0x1>
xor16_d3c():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3c.cpp:13
    __xor16_d3c_state = seed;
    1528:  c0 91 ac 42   lds  r28, 0x42AC  ; 0x8042ac <__xor16_d3c_state>
    152c:  d0 91 ad 42   lds  r29, 0x42AD  ; 0x8042ad <__xor16_d3c_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d3c.cpp:39
      "eor    %B0, r19"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "swap   r19"           "\n\t"
      "andi   r19, 0xF0"     "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d3c_state)::"r18","r19");
    1530:  3c 2f         mov  r19, r28
    1532:  32 95         swap  r19
    1534:  33 0f         add  r19, r19
    1536:  30 7e         andi  r19, 0xE0  ; 224
    1538:  d3 27         eor  r29, r19
    153a:  9e 01         movw  r18, r28
    153c:  36 95         lsr  r19
    153e:  27 95         ror  r18
    1540:  36 95         lsr  r19
    1542:  27 95         ror  r18
    1544:  36 95         lsr  r19
    1546:  27 95         ror  r18
    1548:  c2 27         eor  r28, r18
    154a:  d3 27         eor  r29, r19
    154c:  3c 2f         mov  r19, r28
    154e:  32 95         swap  r19
    1550:  30 7f         andi  r19, 0xF0  ; 240
    1552:  d3 27         eor  r29, r19
    1554:  c0 93 ac 42   sts  0x42AC, r28  ; 0x8042ac <__xor16_d3c_state>
    1558:  d0 93 ad 42   sts  0x42AD, r29  ; 0x8042ad <__xor16_d3c_state+0x1>
setup():
    155c:  8f ef         ldi  r24, 0xFF  ; 255
    155e:  91 e4         ldi  r25, 0x41  ; 65
    1560:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:222
    seed_xor16_d3c(seed);
    seed = xor16_d3c();
    SERIALPORT.print("d3c: ");
    1564:  ce 01         movw  r24, r28
    1566:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d52():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:223
    SERIALPORT.println(seed);
    156a:  20 97         sbiw  r28, 0x00  ; 0
    156c:  21 f0         breq  .+8        ; 0x1576 <setup+0x111a>
    156e:  c0 93 ae 42   sts  0x42AE, r28  ; 0x8042ae <__xor16_d52_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d52.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1572:  d0 93 af 42   sts  0x42AF, r29  ; 0x8042af <__xor16_d52_state+0x1>
xor16_d52():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d52.cpp:13
    __xor16_d52_state = seed;
    1576:  c0 91 ae 42   lds  r28, 0x42AE  ; 0x8042ae <__xor16_d52_state>
    157a:  d0 91 af 42   lds  r29, 0x42AF  ; 0x8042af <__xor16_d52_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d52.cpp:46
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d52_state)::"r18","r19");
    157e:  3c 2f         mov  r19, r28
    1580:  32 95         swap  r19
    1582:  33 0f         add  r19, r19
    1584:  30 7e         andi  r19, 0xE0  ; 224
    1586:  d3 27         eor  r29, r19
    1588:  9e 01         movw  r18, r28
    158a:  36 95         lsr  r19
    158c:  27 95         ror  r18
    158e:  36 95         lsr  r19
    1590:  27 95         ror  r18
    1592:  36 95         lsr  r19
    1594:  27 95         ror  r18
    1596:  36 95         lsr  r19
    1598:  27 95         ror  r18
    159a:  36 95         lsr  r19
    159c:  27 95         ror  r18
    159e:  c2 27         eor  r28, r18
    15a0:  d3 27         eor  r29, r19
    15a2:  9e 01         movw  r18, r28
    15a4:  22 0f         add  r18, r18
    15a6:  33 1f         adc  r19, r19
    15a8:  22 0f         add  r18, r18
    15aa:  33 1f         adc  r19, r19
    15ac:  c2 27         eor  r28, r18
    15ae:  d3 27         eor  r29, r19
    15b0:  c0 93 ae 42   sts  0x42AE, r28  ; 0x8042ae <__xor16_d52_state>
    15b4:  d0 93 af 42   sts  0x42AF, r29  ; 0x8042af <__xor16_d52_state+0x1>
setup():
    15b8:  85 e0         ldi  r24, 0x05  ; 5
    15ba:  92 e4         ldi  r25, 0x42  ; 66
    15bc:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:226
    seed_xor16_d52(seed);
    seed = xor16_d52();
    SERIALPORT.print("d52: ");
    15c0:  ce 01         movw  r24, r28
    15c2:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d72():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:227
    SERIALPORT.println(seed);
    15c6:  20 97         sbiw  r28, 0x00  ; 0
    15c8:  21 f0         breq  .+8        ; 0x15d2 <setup+0x1176>
    15ca:  c0 93 b0 42   sts  0x42B0, r28  ; 0x8042b0 <__xor16_d72_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d72.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    15ce:  d0 93 b1 42   sts  0x42B1, r29  ; 0x8042b1 <__xor16_d72_state+0x1>
xor16_d72():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d72.cpp:13
    __xor16_d72_state = seed;
    15d2:  c0 91 b0 42   lds  r28, 0x42B0  ; 0x8042b0 <__xor16_d72_state>
    15d6:  d0 91 b1 42   lds  r29, 0x42B1  ; 0x8042b1 <__xor16_d72_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d72.cpp:41
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d72_state)::"r18","r19");
    15da:  3c 2f         mov  r19, r28
    15dc:  32 95         swap  r19
    15de:  33 0f         add  r19, r19
    15e0:  30 7e         andi  r19, 0xE0  ; 224
    15e2:  d3 27         eor  r29, r19
    15e4:  9e 01         movw  r18, r28
    15e6:  22 0f         add  r18, r18
    15e8:  23 2f         mov  r18, r19
    15ea:  22 1f         adc  r18, r18
    15ec:  33 0b         sbc  r19, r19
    15ee:  31 95         neg  r19
    15f0:  c2 27         eor  r28, r18
    15f2:  d3 27         eor  r29, r19
    15f4:  9e 01         movw  r18, r28
    15f6:  22 0f         add  r18, r18
    15f8:  33 1f         adc  r19, r19
    15fa:  22 0f         add  r18, r18
    15fc:  33 1f         adc  r19, r19
    15fe:  c2 27         eor  r28, r18
    1600:  d3 27         eor  r29, r19
    1602:  c0 93 b0 42   sts  0x42B0, r28  ; 0x8042b0 <__xor16_d72_state>
    1606:  d0 93 b1 42   sts  0x42B1, r29  ; 0x8042b1 <__xor16_d72_state+0x1>
setup():
    160a:  8b e0         ldi  r24, 0x0B  ; 11
    160c:  92 e4         ldi  r25, 0x42  ; 66
    160e:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:230
    seed_xor16_d72(seed);
    seed = xor16_d72();
    SERIALPORT.print("d72: ");
    1612:  ce 01         movw  r24, r28
    1614:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d76():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:231
    SERIALPORT.println(seed);
    1618:  20 97         sbiw  r28, 0x00  ; 0
    161a:  21 f0         breq  .+8        ; 0x1624 <setup+0x11c8>
    161c:  c0 93 b2 42   sts  0x42B2, r28  ; 0x8042b2 <__xor16_d76_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d76.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1620:  d0 93 b3 42   sts  0x42B3, r29  ; 0x8042b3 <__xor16_d76_state+0x1>
xor16_d76():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d76.cpp:13
    __xor16_d76_state = seed;
    1624:  c0 91 b2 42   lds  r28, 0x42B2  ; 0x8042b2 <__xor16_d76_state>
    1628:  d0 91 b3 42   lds  r29, 0x42B3  ; 0x8042b3 <__xor16_d76_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d76.cpp:49
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d76_state)::"r18","r19");
    162c:  3c 2f         mov  r19, r28
    162e:  32 95         swap  r19
    1630:  33 0f         add  r19, r19
    1632:  30 7e         andi  r19, 0xE0  ; 224
    1634:  d3 27         eor  r29, r19
    1636:  9e 01         movw  r18, r28
    1638:  22 0f         add  r18, r18
    163a:  23 2f         mov  r18, r19
    163c:  22 1f         adc  r18, r18
    163e:  33 0b         sbc  r19, r19
    1640:  31 95         neg  r19
    1642:  c2 27         eor  r28, r18
    1644:  d3 27         eor  r29, r19
    1646:  9e 01         movw  r18, r28
    1648:  22 0f         add  r18, r18
    164a:  33 1f         adc  r19, r19
    164c:  22 0f         add  r18, r18
    164e:  33 1f         adc  r19, r19
    1650:  22 0f         add  r18, r18
    1652:  33 1f         adc  r19, r19
    1654:  22 0f         add  r18, r18
    1656:  33 1f         adc  r19, r19
    1658:  22 0f         add  r18, r18
    165a:  33 1f         adc  r19, r19
    165c:  22 0f         add  r18, r18
    165e:  33 1f         adc  r19, r19
    1660:  c2 27         eor  r28, r18
    1662:  d3 27         eor  r29, r19
    1664:  c0 93 b2 42   sts  0x42B2, r28  ; 0x8042b2 <__xor16_d76_state>
    1668:  d0 93 b3 42   sts  0x42B3, r29  ; 0x8042b3 <__xor16_d76_state+0x1>
setup():
    166c:  81 e1         ldi  r24, 0x11  ; 17
    166e:  92 e4         ldi  r25, 0x42  ; 66
    1670:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:234
    seed_xor16_d76(seed);
    seed = xor16_d76();
    SERIALPORT.print("d76: ");
    1674:  ce 01         movw  r24, r28
    1676:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d79():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:235
    SERIALPORT.println(seed);
    167a:  20 97         sbiw  r28, 0x00  ; 0
    167c:  21 f0         breq  .+8        ; 0x1686 <setup+0x122a>
    167e:  c0 93 b4 42   sts  0x42B4, r28  ; 0x8042b4 <__xor16_d79_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d79.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1682:  d0 93 b5 42   sts  0x42B5, r29  ; 0x8042b5 <__xor16_d79_state+0x1>
xor16_d79():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d79.cpp:13
    __xor16_d79_state = seed;
    1686:  c0 91 b4 42   lds  r28, 0x42B4  ; 0x8042b4 <__xor16_d79_state>
    168a:  d0 91 b5 42   lds  r29, 0x42B5  ; 0x8042b5 <__xor16_d79_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d79.cpp:37
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
      "mov    r19, %A0"      "\n\t"
      "add    r19, r19"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d79_state)::"r18","r19");
    168e:  3c 2f         mov  r19, r28
    1690:  32 95         swap  r19
    1692:  33 0f         add  r19, r19
    1694:  30 7e         andi  r19, 0xE0  ; 224
    1696:  d3 27         eor  r29, r19
    1698:  9e 01         movw  r18, r28
    169a:  22 0f         add  r18, r18
    169c:  23 2f         mov  r18, r19
    169e:  22 1f         adc  r18, r18
    16a0:  33 0b         sbc  r19, r19
    16a2:  31 95         neg  r19
    16a4:  c2 27         eor  r28, r18
    16a6:  d3 27         eor  r29, r19
    16a8:  3c 2f         mov  r19, r28
    16aa:  33 0f         add  r19, r19
    16ac:  d3 27         eor  r29, r19
    16ae:  c0 93 b4 42   sts  0x42B4, r28  ; 0x8042b4 <__xor16_d79_state>
    16b2:  d0 93 b5 42   sts  0x42B5, r29  ; 0x8042b5 <__xor16_d79_state+0x1>
setup():
    16b6:  87 e1         ldi  r24, 0x17  ; 23
    16b8:  92 e4         ldi  r25, 0x42  ; 66
    16ba:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:238
    seed_xor16_d79(seed);
    seed = xor16_d79();
    SERIALPORT.print("d79: ");
    16be:  ce 01         movw  r24, r28
    16c0:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_d97():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:239
    SERIALPORT.println(seed);
    16c4:  20 97         sbiw  r28, 0x00  ; 0
    16c6:  21 f0         breq  .+8        ; 0x16d0 <setup+0x1274>
    16c8:  c0 93 b6 42   sts  0x42B6, r28  ; 0x8042b6 <__xor16_d97_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d97.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    16cc:  d0 93 b7 42   sts  0x42B7, r29  ; 0x8042b7 <__xor16_d97_state+0x1>
xor16_d97():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d97.cpp:13
    __xor16_d97_state = seed;
    16d0:  c0 91 b6 42   lds  r28, 0x42B6  ; 0x8042b6 <__xor16_d97_state>
    16d4:  d0 91 b7 42   lds  r29, 0x42B7  ; 0x8042b7 <__xor16_d97_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_d97.cpp:37
      "eor    r18, r18"      "\n\t"
      "ror    r19"           "\n\t"
      "ror    r18"           "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_d97_state)::"r18","r19");
    16d8:  3c 2f         mov  r19, r28
    16da:  32 95         swap  r19
    16dc:  33 0f         add  r19, r19
    16de:  30 7e         andi  r19, 0xE0  ; 224
    16e0:  d3 27         eor  r29, r19
    16e2:  2d 2f         mov  r18, r29
    16e4:  26 95         lsr  r18
    16e6:  c2 27         eor  r28, r18
    16e8:  9e 01         movw  r18, r28
    16ea:  36 95         lsr  r19
    16ec:  32 2f         mov  r19, r18
    16ee:  22 27         eor  r18, r18
    16f0:  37 95         ror  r19
    16f2:  27 95         ror  r18
    16f4:  c2 27         eor  r28, r18
    16f6:  d3 27         eor  r29, r19
    16f8:  c0 93 b6 42   sts  0x42B6, r28  ; 0x8042b6 <__xor16_d97_state>
    16fc:  d0 93 b7 42   sts  0x42B7, r29  ; 0x8042b7 <__xor16_d97_state+0x1>
setup():
    1700:  8d e1         ldi  r24, 0x1D  ; 29
    1702:  92 e4         ldi  r25, 0x42  ; 66
    1704:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:242
    seed_xor16_d97(seed);
    seed = xor16_d97();
    SERIALPORT.print("d97: ");
    1708:  ce 01         movw  r24, r28
    170a:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_e11():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:243
    SERIALPORT.println(seed);
    170e:  20 97         sbiw  r28, 0x00  ; 0
    1710:  21 f0         breq  .+8        ; 0x171a <setup+0x12be>
    1712:  c0 93 b8 42   sts  0x42B8, r28  ; 0x8042b8 <__xor16_e11_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e11.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1716:  d0 93 b9 42   sts  0x42B9, r29  ; 0x8042b9 <__xor16_e11_state+0x1>
xor16_e11():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e11.cpp:13
    __xor16_e11_state = seed;
    171a:  c0 91 b8 42   lds  r28, 0x42B8  ; 0x8042b8 <__xor16_e11_state>
    171e:  d0 91 b9 42   lds  r29, 0x42B9  ; 0x8042b9 <__xor16_e11_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e11.cpp:37
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_e11_state)::"r18","r19");
    1722:  33 27         eor  r19, r19
    1724:  c0 fb         bst  r28, 0
    1726:  36 f9         bld  r19, 6
    1728:  c1 fb         bst  r28, 1
    172a:  37 f9         bld  r19, 7
    172c:  d3 27         eor  r29, r19
    172e:  9e 01         movw  r18, r28
    1730:  36 95         lsr  r19
    1732:  27 95         ror  r18
    1734:  c2 27         eor  r28, r18
    1736:  d3 27         eor  r29, r19
    1738:  9e 01         movw  r18, r28
    173a:  22 0f         add  r18, r18
    173c:  33 1f         adc  r19, r19
    173e:  c2 27         eor  r28, r18
    1740:  d3 27         eor  r29, r19
    1742:  c0 93 b8 42   sts  0x42B8, r28  ; 0x8042b8 <__xor16_e11_state>
    1746:  d0 93 b9 42   sts  0x42B9, r29  ; 0x8042b9 <__xor16_e11_state+0x1>
setup():
    174a:  83 e2         ldi  r24, 0x23  ; 35
    174c:  92 e4         ldi  r25, 0x42  ; 66
    174e:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:246
    seed_xor16_e11(seed);
    seed = xor16_e11();
    SERIALPORT.print("e11: ");
    1752:  ce 01         movw  r24, r28
    1754:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_e75():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:247
    SERIALPORT.println(seed);
    1758:  20 97         sbiw  r28, 0x00  ; 0
    175a:  21 f0         breq  .+8        ; 0x1764 <setup+0x1308>
    175c:  c0 93 ba 42   sts  0x42BA, r28  ; 0x8042ba <__xor16_e75_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e75.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1760:  d0 93 bb 42   sts  0x42BB, r29  ; 0x8042bb <__xor16_e75_state+0x1>
xor16_e75():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e75.cpp:13
    __xor16_e75_state = seed;
    1764:  c0 91 ba 42   lds  r28, 0x42BA  ; 0x8042ba <__xor16_e75_state>
    1768:  d0 91 bb 42   lds  r29, 0x42BB  ; 0x8042bb <__xor16_e75_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_e75.cpp:48
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_e75_state)::"r18","r19");
    176c:  33 27         eor  r19, r19
    176e:  c0 fb         bst  r28, 0
    1770:  36 f9         bld  r19, 6
    1772:  c1 fb         bst  r28, 1
    1774:  37 f9         bld  r19, 7
    1776:  d3 27         eor  r29, r19
    1778:  9e 01         movw  r18, r28
    177a:  22 0f         add  r18, r18
    177c:  23 2f         mov  r18, r19
    177e:  22 1f         adc  r18, r18
    1780:  33 0b         sbc  r19, r19
    1782:  31 95         neg  r19
    1784:  c2 27         eor  r28, r18
    1786:  d3 27         eor  r29, r19
    1788:  9e 01         movw  r18, r28
    178a:  22 0f         add  r18, r18
    178c:  33 1f         adc  r19, r19
    178e:  22 0f         add  r18, r18
    1790:  33 1f         adc  r19, r19
    1792:  22 0f         add  r18, r18
    1794:  33 1f         adc  r19, r19
    1796:  22 0f         add  r18, r18
    1798:  33 1f         adc  r19, r19
    179a:  22 0f         add  r18, r18
    179c:  33 1f         adc  r19, r19
    179e:  c2 27         eor  r28, r18
    17a0:  d3 27         eor  r29, r19
    17a2:  c0 93 ba 42   sts  0x42BA, r28  ; 0x8042ba <__xor16_e75_state>
    17a6:  d0 93 bb 42   sts  0x42BB, r29  ; 0x8042bb <__xor16_e75_state+0x1>
setup():
    17aa:  89 e2         ldi  r24, 0x29  ; 41
    17ac:  92 e4         ldi  r25, 0x42  ; 66
    17ae:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:250
    seed_xor16_e75(seed);
    seed = xor16_e75();
    SERIALPORT.print("e75: ");
    17b2:  ce 01         movw  r24, r28
    17b4:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_f11():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:251
    SERIALPORT.println(seed);
    17b8:  20 97         sbiw  r28, 0x00  ; 0
    17ba:  21 f0         breq  .+8        ; 0x17c4 <setup+0x1368>
    17bc:  c0 93 bc 42   sts  0x42BC, r28  ; 0x8042bc <__xor16_f11_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f11.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    17c0:  d0 93 bd 42   sts  0x42BD, r29  ; 0x8042bd <__xor16_f11_state+0x1>
xor16_f11():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f11.cpp:13
    __xor16_f11_state = seed;
    17c4:  c0 91 bc 42   lds  r28, 0x42BC  ; 0x8042bc <__xor16_f11_state>
    17c8:  d0 91 bd 42   lds  r29, 0x42BD  ; 0x8042bd <__xor16_f11_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f11.cpp:35
      "movw   r18, %A0"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_f11_state)::"r18","r19");
    17cc:  33 27         eor  r19, r19
    17ce:  c0 fb         bst  r28, 0
    17d0:  37 f9         bld  r19, 7
    17d2:  d3 27         eor  r29, r19
    17d4:  9e 01         movw  r18, r28
    17d6:  36 95         lsr  r19
    17d8:  27 95         ror  r18
    17da:  c2 27         eor  r28, r18
    17dc:  d3 27         eor  r29, r19
    17de:  9e 01         movw  r18, r28
    17e0:  22 0f         add  r18, r18
    17e2:  33 1f         adc  r19, r19
    17e4:  c2 27         eor  r28, r18
    17e6:  d3 27         eor  r29, r19
    17e8:  c0 93 bc 42   sts  0x42BC, r28  ; 0x8042bc <__xor16_f11_state>
    17ec:  d0 93 bd 42   sts  0x42BD, r29  ; 0x8042bd <__xor16_f11_state+0x1>
setup():
    17f0:  8f e2         ldi  r24, 0x2F  ; 47
    17f2:  92 e4         ldi  r25, 0x42  ; 66
    17f4:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:254
    seed_xor16_f11(seed);
    seed = xor16_f11();
    SERIALPORT.print("f11: ");
    17f8:  ce 01         movw  r24, r28
    17fa:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_f13():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:255
    SERIALPORT.println(seed);
    17fe:  20 97         sbiw  r28, 0x00  ; 0
    1800:  21 f0         breq  .+8        ; 0x180a <setup+0x13ae>
    1802:  c0 93 be 42   sts  0x42BE, r28  ; 0x8042be <__xor16_f13_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f13.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1806:  d0 93 bf 42   sts  0x42BF, r29  ; 0x8042bf <__xor16_f13_state+0x1>
xor16_f13():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f13.cpp:13
    __xor16_f13_state = seed;
    180a:  c0 91 be 42   lds  r28, 0x42BE  ; 0x8042be <__xor16_f13_state>
    180e:  d0 91 bf 42   lds  r29, 0x42BF  ; 0x8042bf <__xor16_f13_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f13.cpp:39
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_f13_state)::"r18","r19");
    1812:  33 27         eor  r19, r19
    1814:  c0 fb         bst  r28, 0
    1816:  37 f9         bld  r19, 7
    1818:  d3 27         eor  r29, r19
    181a:  9e 01         movw  r18, r28
    181c:  36 95         lsr  r19
    181e:  27 95         ror  r18
    1820:  c2 27         eor  r28, r18
    1822:  d3 27         eor  r29, r19
    1824:  9e 01         movw  r18, r28
    1826:  22 0f         add  r18, r18
    1828:  33 1f         adc  r19, r19
    182a:  22 0f         add  r18, r18
    182c:  33 1f         adc  r19, r19
    182e:  22 0f         add  r18, r18
    1830:  33 1f         adc  r19, r19
    1832:  c2 27         eor  r28, r18
    1834:  d3 27         eor  r29, r19
    1836:  c0 93 be 42   sts  0x42BE, r28  ; 0x8042be <__xor16_f13_state>
    183a:  d0 93 bf 42   sts  0x42BF, r29  ; 0x8042bf <__xor16_f13_state+0x1>
setup():
    183e:  85 e3         ldi  r24, 0x35  ; 53
    1840:  92 e4         ldi  r25, 0x42  ; 66
    1842:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:258
    seed_xor16_f13(seed);
    seed = xor16_f13();
    SERIALPORT.print("f13: ");
    1846:  ce 01         movw  r24, r28
    1848:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_f52():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:259
    SERIALPORT.println(seed);
    184c:  20 97         sbiw  r28, 0x00  ; 0
    184e:  21 f0         breq  .+8        ; 0x1858 <setup+0x13fc>
    1850:  c0 93 c0 42   sts  0x42C0, r28  ; 0x8042c0 <__xor16_f52_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f52.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    1854:  d0 93 c1 42   sts  0x42C1, r29  ; 0x8042c1 <__xor16_f52_state+0x1>
xor16_f52():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f52.cpp:13
    __xor16_f52_state = seed;
    1858:  c0 91 c0 42   lds  r28, 0x42C0  ; 0x8042c0 <__xor16_f52_state>
    185c:  d0 91 c1 42   lds  r29, 0x42C1  ; 0x8042c1 <__xor16_f52_state+0x1>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f52.cpp:45
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_f52_state)::"r18","r19");
    1860:  33 27         eor  r19, r19
    1862:  c0 fb         bst  r28, 0
    1864:  37 f9         bld  r19, 7
    1866:  d3 27         eor  r29, r19
    1868:  9e 01         movw  r18, r28
    186a:  36 95         lsr  r19
    186c:  27 95         ror  r18
    186e:  36 95         lsr  r19
    1870:  27 95         ror  r18
    1872:  36 95         lsr  r19
    1874:  27 95         ror  r18
    1876:  36 95         lsr  r19
    1878:  27 95         ror  r18
    187a:  36 95         lsr  r19
    187c:  27 95         ror  r18
    187e:  c2 27         eor  r28, r18
    1880:  d3 27         eor  r29, r19
    1882:  9e 01         movw  r18, r28
    1884:  22 0f         add  r18, r18
    1886:  33 1f         adc  r19, r19
    1888:  22 0f         add  r18, r18
    188a:  33 1f         adc  r19, r19
    188c:  c2 27         eor  r28, r18
    188e:  d3 27         eor  r29, r19
    1890:  c0 93 c0 42   sts  0x42C0, r28  ; 0x8042c0 <__xor16_f52_state>
    1894:  d0 93 c1 42   sts  0x42C1, r29  ; 0x8042c1 <__xor16_f52_state+0x1>
setup():
    1898:  8b e3         ldi  r24, 0x3B  ; 59
    189a:  92 e4         ldi  r25, 0x42  ; 66
    189c:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:262
    seed_xor16_f52(seed);
    seed = xor16_f52();
    SERIALPORT.print("f52: ");
    18a0:  ce 01         movw  r24, r28
    18a2:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
seed_xor16_f72():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:263
    SERIALPORT.println(seed);
    18a6:  20 97         sbiw  r28, 0x00  ; 0
    18a8:  21 f0         breq  .+8        ; 0x18b2 <setup+0x1456>
    18aa:  c0 93 c2 42   sts  0x42C2, r28  ; 0x8042c2 <__xor16_f72_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f72.cpp:12
  if (__builtin_constant_p(seed)) {
    if(seed == 0) {
      badArg("rng's must be seeded with a non-zero value, but the argument passed is always zero");
    }
  }
  if(seed) {
    18ae:  d0 93 c3 42   sts  0x42C3, r29  ; 0x8042c3 <__xor16_f72_state+0x1>
xor16_f72():
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f72.cpp:13
    __xor16_f72_state = seed;
    18b2:  c0 91 c2 42   lds  r28, 0x42C2  ; 0x8042c2 <__xor16_f72_state>
C:\Users\Spence\Documents\Arduino\libraries\rngBetter\src/xor16_f72.cpp:40
      "adc    r19, r19"      "\n\t"
      "add    r18, r18"      "\n\t"
      "adc    r19, r19"      "\n\t"
      "eor    %A0, r18"      "\n\t"
      "eor    %B0, r19"      "\n\t"
    :"+d"((uint16_t)__xor16_f72_state)::"r18","r19");
    18b6:  d0 91 c3 42   lds  r29, 0x42C3  ; 0x8042c3 <__xor16_f72_state+0x1>
    18ba:  33 27         eor  r19, r19
    18bc:  c0 fb         bst  r28, 0
    18be:  37 f9         bld  r19, 7
    18c0:  d3 27         eor  r29, r19
    18c2:  9e 01         movw  r18, r28
    18c4:  22 0f         add  r18, r18
    18c6:  23 2f         mov  r18, r19
    18c8:  22 1f         adc  r18, r18
    18ca:  33 0b         sbc  r19, r19
    18cc:  31 95         neg  r19
    18ce:  c2 27         eor  r28, r18
    18d0:  d3 27         eor  r29, r19
    18d2:  9e 01         movw  r18, r28
    18d4:  22 0f         add  r18, r18
    18d6:  33 1f         adc  r19, r19
    18d8:  22 0f         add  r18, r18
    18da:  33 1f         adc  r19, r19
    18dc:  c2 27         eor  r28, r18
    18de:  d3 27         eor  r29, r19
    18e0:  c0 93 c2 42   sts  0x42C2, r28  ; 0x8042c2 <__xor16_f72_state>
    18e4:  d0 93 c3 42   sts  0x42C3, r29  ; 0x8042c3 <__xor16_f72_state+0x1>
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:266
    seed_xor16_f72(seed);
    seed = xor16_f72();
    SERIALPORT.print("f72: ");
    18e8:  81 e4         ldi  r24, 0x41  ; 65
    18ea:  92 e4         ldi  r25, 0x42  ; 66
    18ec:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:267
    SERIALPORT.println(seed);
    18f0:  ce 01         movw  r24, r28
    18f2:  0e 94 e9 01   call  0x3d2  ; 0x3d2 <Print::println(unsigned int, int) [clone .constprop.10]>
write():
    18f6:  67 e4         ldi  r22, 0x47  ; 71
    18f8:  72 e4         ldi  r23, 0x42  ; 66
    18fa:  88 ec         ldi  r24, 0xC8  ; 200
    18fc:  92 e4         ldi  r25, 0x42  ; 66
    18fe:  0e 94 dc 01   call  0x3b8  ; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
    1902:  67 e5         ldi  r22, 0x57  ; 87
    1904:  70 e4         ldi  r23, 0x40  ; 64
    1906:  88 ec         ldi  r24, 0xC8  ; 200
    1908:  92 e4         ldi  r25, 0x42  ; 66
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:271
    SERIALPORT.println("Done");
  #endif
#endif
}
    190a:  df 91         pop  r29
    190c:  cf 91         pop  r28
    190e:  ff 90         pop  r15
    1910:  ef 90         pop  r14
    1912:  df 90         pop  r13
    1914:  cf 90         pop  r12
write():
    1916:  0c 94 dc 01   jmp  0x3b8  ; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
setup():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:661
   */

  /*******************************
   *  Phase 1: Input Processing  |
   ******************************/
  if (!(ADC0.CTRLA & 0x01)) return ADC_ENH_ERROR_DISABLED;
    191a:  c9 ef         ldi  r28, 0xF9  ; 249
write():
    191c:  6a e7         ldi  r22, 0x7A  ; 122
    191e:  70 e4         ldi  r23, 0x40  ; 64
    1920:  88 ec         ldi  r24, 0xC8  ; 200
    1922:  92 e4         ldi  r25, 0x42  ; 66
    1924:  0e 94 dc 01   call  0x3b8  ; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
    1928:  67 e5         ldi  r22, 0x57  ; 87
    192a:  70 e4         ldi  r23, 0x40  ; 64
    192c:  88 ec         ldi  r24, 0xC8  ; 200
    192e:  92 e4         ldi  r25, 0x42  ; 66
    1930:  0e 94 dc 01   call  0x3b8  ; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
setup():
C:\Users\Spence\Documents\Arduino\rngBetterTest/rngBetterTest.ino:23
    #else
      int32_t adcread = analogReadEnh(PIN_PD4, ADC_ACC16);
    #endif
    if (adcread < 0) {
      SERIALPORT.println("ADC failure!! Please report the conditions under which this occurred via github issue. ");
      SERIALPORT.print("Error code: ");
    1934:  82 ed         ldi  r24, 0xD2  ; 210
    1936:  90 e4         ldi  r25, 0x40  ; 64
    1938:  0e 94 e5 01   call  0x3ca  ; 0x3ca <Print::print(char const*) [clone .constprop.9]>
printHex():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:855
          printHex(*(ptr++));
          printHex(*(ptr++));
          printHex(*(ptr));
        } else {
          ptr+=3;
          printHex(*(ptr--));
    193c:  82 e8         ldi  r24, 0x82  ; 130
    193e:  0e 94 6d 01   call  0x2da  ; 0x2da <HardwareSerial::printHex(unsigned char) [clone .constprop.19]>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:856
          printHex(*(ptr--));
    1942:  84 ed         ldi  r24, 0xD4  ; 212
    1944:  0e 94 6d 01   call  0x2da  ; 0x2da <HardwareSerial::printHex(unsigned char) [clone .constprop.19]>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:857
          printHex(*(ptr--));
    1948:  8a e8         ldi  r24, 0x8A  ; 138
    194a:  0e 94 6d 01   call  0x2da  ; 0x2da <HardwareSerial::printHex(unsigned char) [clone .constprop.19]>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:858
          printHex(*(ptr));
    194e:  8c 2f         mov  r24, r28
    1950:  0e 94 6d 01   call  0x2da  ; 0x2da <HardwareSerial::printHex(unsigned char) [clone .constprop.19]>
write():
    1954:  67 e5         ldi  r22, 0x57  ; 87
    1956:  70 e4         ldi  r23, 0x40  ; 64
    1958:  88 ec         ldi  r24, 0xC8  ; 200
    195a:  92 e4         ldi  r25, 0x42  ; 66
    195c:  0e 94 dc 01   call  0x3b8  ; 0x3b8 <Print::write(char const*) [clone .part.2] [clone .constprop.21]>
    1960:  ff cf         rjmp  .-2        ; 0x1960 <setup+0x1504>
setup():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:688
          Not worth wasting on the scale of 20-some-odd bytes of flash just to give an error to people who dynamically generate invalid analog pins
          and try to use them with analogReadEnh(), instead of just returning whatever we get from reading the bogus channel */
    return ADC_ENH_ERROR_BAD_PIN_OR_CHANNEL;
  }
  if (ADC0.COMMAND & ADC_STCONV_bm) {
    return ADC_ENH_ERROR_BUSY;
    1962:  cf ef         ldi  r28, 0xFF  ; 255
    1964:  db cf         rjmp  .-74       ; 0x191c <setup+0x14c0>

00001966 <__vector_22>:
__vector_22():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:119
    ISR(USART0_DRE_vect, ISR_NAKED) {
      __asm__ __volatile__(
                "push  r30"       "\n\t"
                "push  r31"       "\n\t"
                "cbi   0x1F, 0"   "\n\t"
                :::);
    1966:  ef 93         push  r30
    1968:  ff 93         push  r31
    196a:  f8 98         cbi  0x1f, 0  ; 31
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:126
#if PROGMEM_SIZE > 8192
                "jmp _do_dre"     "\n\t"
#else
                "rjmp _do_dre"    "\n\t"
#endif
                ::"z"(&Serial0));
    196c:  e8 ec         ldi  r30, 0xC8  ; 200
    196e:  f2 e4         ldi  r31, 0x42  ; 66
    1970:  0b c0         rjmp  .+22       ; 0x1988 <_do_dre()>

00001972 <__vector_21>:
__vector_21():
    1972:  ef 93         push  r30
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:96
      ISR(USART0_RXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t" //we start out 5-6 clocks behind the ball, then do 2 push + 2 ldi + 2-3 for jump = 11 or 13 clocks to _do_rxc (and dre is the same)
              "push      r31"     "\n\t"
              "cbi   0x1F, 0"     "\n\t"
              :::);
    1974:  ff 93         push  r31
    1976:  f8 98         cbi  0x1f, 0  ; 31
    1978:  e8 ec         ldi  r30, 0xC8  ; 200
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:103
#if PROGMEM_SIZE > 8192
              "jmp   _do_rxc"     "\n\t"
#else
              "rjmp   _do_rxc"    "\n\t"
#endif
              ::"z"(&Serial0));
    197a:  f2 e4         ldi  r31, 0x42  ; 66
    197c:  34 c0         rjmp  .+104      ; 0x19e6 <_do_rxc()>

0000197e <__vector_23>:
__vector_23():
    197e:  ef 93         push  r30
    1980:  ff 93         push  r31
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:59
#elif defined(USE_ASM_TXC) && USE_ASM_TXC == 2
    ISR(USART0_TXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t"
              "push      r31"     "\n\t"
              :::);
    1982:  e8 ec         ldi  r30, 0xC8  ; 200
    1984:  f2 e4         ldi  r31, 0x42  ; 66
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:66
#if PROGMEM_SIZE > 8192
              "jmp   _do_txc"     "\n\t"
#else
              "rjmp   _do_txc"    "\n\t"
#endif
              ::"z"(&Serial0));
    1986:  5f c0         rjmp  .+190      ; 0x1a46 <_do_txc()>

00001988 <_do_dre()>:
_Z7_do_drev():
    1988:  2f 93         push  r18
    198a:  2f b7         in  r18, 0x3f  ; 63
    198c:  2f 93         push  r18
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:387
          "out        0x3f,     r18"      "\n\t"  // restore SREG
          "pop         r18"               "\n\t"  // pop old r18
          "pop         r31"               "\n\t"  // pop the Z that the isr pushed.
          "pop         r30"               "\n\t"
          "reti"                          "\n"   // and RETI!
          ::);
    198e:  8f 93         push  r24
    1990:  9f 93         push  r25
    1992:  af 93         push  r26
    1994:  bf 93         push  r27
    1996:  68 94         set

00001998 <_poll_dre>:
    1998:  cf 93         push  r28
    199a:  df 93         push  r29
    199c:  20 e0         ldi  r18, 0x00  ; 0
    199e:  c0 85         ldd  r28, Z+8  ; 0x08
    19a0:  d8 e0         ldi  r29, 0x08  ; 8
    19a2:  92 89         ldd  r25, Z+18  ; 0x12
    19a4:  df 01         movw  r26, r30
    19a6:  a9 0f         add  r26, r25
    19a8:  b2 1f         adc  r27, r18
    19aa:  ad 5a         subi  r26, 0xAD  ; 173
    19ac:  bf 4f         sbci  r27, 0xFF  ; 255
    19ae:  8c 91         ld  r24, X
    19b0:  20 e4         ldi  r18, 0x40  ; 64
    19b2:  2c 83         std  Y+4, r18  ; 0x04
    19b4:  8a 83         std  Y+2, r24  ; 0x02
    19b6:  9f 5f         subi  r25, 0xFF  ; 255
    19b8:  9f 73         andi  r25, 0x3F  ; 63
    19ba:  8d 81         ldd  r24, Y+5  ; 0x05
    19bc:  21 89         ldd  r18, Z+17  ; 0x11
    19be:  29 13         cpse  r18, r25
    19c0:  02 c0         rjmp  .+4        ; 0x19c6 <_done_dre_irq>
    19c2:  8f 7d         andi  r24, 0xDF  ; 223
    19c4:  8d 83         std  Y+5, r24  ; 0x05

000019c6 <_done_dre_irq>:
    19c6:  92 8b         std  Z+18, r25  ; 0x12
    19c8:  df 91         pop  r29
    19ca:  cf 91         pop  r28
    19cc:  16 f0         brts  .+4        ; 0x19d2 <_done_dre_irq+0xc>
    19ce:  0c 94 20 01   jmp  0x240  ; 0x240 <_poll_dre_done>
    19d2:  bf 91         pop  r27
    19d4:  af 91         pop  r26
    19d6:  9f 91         pop  r25
    19d8:  8f 91         pop  r24
    19da:  2f 91         pop  r18
    19dc:  2f bf         out  0x3f, r18  ; 63
    19de:  2f 91         pop  r18
    19e0:  ff 91         pop  r31
    19e2:  ef 91         pop  r30
    19e4:  18 95         reti

000019e6 <_do_rxc()>:
_Z7_do_rxcv():
    19e6:  2f 93         push  r18
    19e8:  2f b7         in  r18, 0x3f  ; 63
    19ea:  2f 93         push  r18
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:252
            "pop        r30"              "\n\t" // pointer to serial instance
            "reti"                        "\n\t" // return
          "_buff_full_rxc:"               "\n\t" // _buff_full_rxc moved to after the reti, and then rjmps back, saving 2 clocks for the common case
            "ori        r19,      0x40"   "\n\t" // record that there was a ring buffer overflow. 1 clk
            "rjmp _end_rxc"               "\n\t" // and now jump back to end. That way we don't need to jump over this in the middle of the common case.
            ::); // total: 77 or 79 clocks, just barely squeaks by for cyclic RX of up to RX_BUFFER_SIZE characters.
    19ec:  3f 93         push  r19
    19ee:  8f 93         push  r24
    19f0:  9f 93         push  r25
    19f2:  cf 93         push  r28
    19f4:  df 93         push  r29
    19f6:  c0 85         ldd  r28, Z+8  ; 0x08
    19f8:  d8 e0         ldi  r29, 0x08  ; 8
    19fa:  2e 81         ldd  r18, Y+6  ; 0x06
    19fc:  2f 7e         andi  r18, 0xEF  ; 239
    19fe:  2e 83         std  Y+6, r18  ; 0x06
    1a00:  89 81         ldd  r24, Y+1  ; 0x01
    1a02:  98 81         ld  r25, Y
    1a04:  86 74         andi  r24, 0x46  ; 70
    1a06:  88 0f         add  r24, r24
    1a08:  36 85         ldd  r19, Z+14  ; 0x0e
    1a0a:  38 2b         or  r19, r24
    1a0c:  82 fd         sbrc  r24, 2
    1a0e:  0d c0         rjmp  .+26       ; 0x1a2a <_end_rxc>
    1a10:  c7 85         ldd  r28, Z+15  ; 0x0f
    1a12:  81 e0         ldi  r24, 0x01  ; 1
    1a14:  8c 0f         add  r24, r28
    1a16:  8f 73         andi  r24, 0x3F  ; 63
    1a18:  20 89         ldd  r18, Z+16  ; 0x10
    1a1a:  28 17         cp  r18, r24
    1a1c:  91 f0         breq  .+36       ; 0x1a42 <_buff_full_rxc>
    1a1e:  ce 0f         add  r28, r30
    1a20:  df 2f         mov  r29, r31
    1a22:  20 e0         ldi  r18, 0x00  ; 0
    1a24:  d2 1f         adc  r29, r18
    1a26:  9b 8b         std  Y+19, r25  ; 0x13
    1a28:  87 87         std  Z+15, r24  ; 0x0f

00001a2a <_end_rxc>:
    1a2a:  36 87         std  Z+14, r19  ; 0x0e
    1a2c:  df 91         pop  r29
    1a2e:  cf 91         pop  r28
    1a30:  9f 91         pop  r25
    1a32:  8f 91         pop  r24
    1a34:  3f 91         pop  r19
    1a36:  2f 91         pop  r18
    1a38:  2f bf         out  0x3f, r18  ; 63
    1a3a:  2f 91         pop  r18
    1a3c:  ff 91         pop  r31
    1a3e:  ef 91         pop  r30
    1a40:  18 95         reti

00001a42 <_buff_full_rxc>:
    1a42:  30 64         ori  r19, 0x40  ; 64
    1a44:  f2 cf         rjmp  .-28       ; 0x1a2a <_end_rxc>

00001a46 <_do_txc()>:
_Z7_do_txcv():
    1a46:  8f 93         push  r24
    1a48:  8f b7         in  r24, 0x3f  ; 63
    1a4a:  8f 93         push  r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:127
            "pop        r24"              "\n\t"  // pop r24 restore it
            "pop        r31"              "\n\t"  // and r31
            "pop        r30"              "\n\t"  // Pop the register the ISR did
            "reti"                        "\n"    // return from the interrupt.
            ::
          );
    1a4c:  9f 93         push  r25
    1a4e:  cf 93         push  r28
    1a50:  df 93         push  r29
    1a52:  c0 85         ldd  r28, Z+8  ; 0x08
    1a54:  d8 e0         ldi  r29, 0x08  ; 8
    1a56:  9d 81         ldd  r25, Y+5  ; 0x05

00001a58 <_txc_flush_rx>:
    1a58:  88 81         ld  r24, Y
    1a5a:  8c 81         ldd  r24, Y+4  ; 0x04
    1a5c:  87 fd         sbrc  r24, 7
    1a5e:  fc cf         rjmp  .-8        ; 0x1a58 <_txc_flush_rx>
    1a60:  9f 7b         andi  r25, 0xBF  ; 191
    1a62:  90 68         ori  r25, 0x80  ; 128
    1a64:  9d 83         std  Y+5, r25  ; 0x05
    1a66:  df 91         pop  r29
    1a68:  cf 91         pop  r28
    1a6a:  9f 91         pop  r25
    1a6c:  8f 91         pop  r24
    1a6e:  8f bf         out  0x3f, r24  ; 63
    1a70:  8f 91         pop  r24
    1a72:  ff 91         pop  r31
    1a74:  ef 91         pop  r30
    1a76:  18 95         reti

00001a78 <__vector_31>:
__vector_31():
    1a78:  ef 93         push  r30
    1a7a:  ff 93         push  r31
    1a7c:  e4 ec         ldi  r30, 0xC4  ; 196
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:135
      }
      RTC.INTFLAGS = RTC_OVF_bm | RTC_CMP_bm; // clear flag
    }
  #elif !defined(MILLIS_USE_TIMERNONE)
    ISR(MILLIS_VECTOR, ISR_NAKED) {
      __asm__ __volatile__(
    1a7e:  f2 e4         ldi  r31, 0x42  ; 66
    1a80:  8f 93         push  r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:140
      "push       r30"          "\n\t" // First we make room for the pointer to timingStruct by pushing the Z registers
      "push       r31"          "\n\t" //
      ::);
    #if defined(MILLIS_USE_TCB)
      __asm__ __volatile__(
    1a82:  8f b7         in  r24, 0x3f  ; 63
    1a84:  8f 93         push  r24
    1a86:  80 81         ld  r24, Z
    1a88:  8f 5f         subi  r24, 0xFF  ; 255
    1a8a:  80 83         st  Z, r24
    1a8c:  81 81         ldd  r24, Z+1  ; 0x01
    1a8e:  8f 4f         sbci  r24, 0xFF  ; 255
    1a90:  81 83         std  Z+1, r24  ; 0x01
    1a92:  82 81         ldd  r24, Z+2  ; 0x02
    1a94:  8f 4f         sbci  r24, 0xFF  ; 255
    1a96:  82 83         std  Z+2, r24  ; 0x02
    1a98:  83 81         ldd  r24, Z+3  ; 0x03
    1a9a:  8f 4f         sbci  r24, 0xFF  ; 255
    1a9c:  83 83         std  Z+3, r24  ; 0x03
    1a9e:  81 e0         ldi  r24, 0x01  ; 1
    1aa0:  80 93 26 0b   sts  0x0B26, r24  ; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
    1aa4:  8f 91         pop  r24
    1aa6:  8f bf         out  0x3f, r24  ; 63
    1aa8:  8f 91         pop  r24
    1aaa:  ff 91         pop  r31
    1aac:  ef 91         pop  r30
    1aae:  18 95         reti

00001ab0 <main>:
init():
    1ab0:  84 e0         ldi  r24, 0x04  ; 4
    1ab2:  80 93 70 04   sts  0x0470, r24  ; 0x800470 <__TEXT_REGION_LENGTH__+0x7e0470>
init_clock():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1861
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0B << 2));
      #elif (F_CPU == 28000000)
        /* Overclocked - generally quite reliable at room temperature, but a dumb frequency (see PWM section) */
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0A << 2));
      #elif (F_CPU == 24000000)
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x09 << 2));
    1ab6:  88 ed         ldi  r24, 0xD8  ; 216
    1ab8:  94 e2         ldi  r25, 0x24  ; 36
    1aba:  84 bf         out  0x34, r24  ; 52
    1abc:  90 93 68 00   sts  0x0068, r25  ; 0x800068 <__TEXT_REGION_LENGTH__+0x7e0068>
init_TCA0():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2208
}

void __attribute__((weak)) init_TCA0() {
  /* TCA0_PINS from pins_arduino.h */
  /* Enable Split Mode to get more PWM pins, since analogWrite() only provides 8-bit PWM anyway*/
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    1ac0:  31 e0         ldi  r19, 0x01  ; 1
    1ac2:  30 93 03 0a   sts  0x0A03, r19  ; 0x800a03 <__TEXT_REGION_LENGTH__+0x7e0a03>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2213

  // Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    1ac6:  9e ef         ldi  r25, 0xFE  ; 254
    1ac8:  90 93 26 0a   sts  0x0A26, r25  ; 0x800a26 <__TEXT_REGION_LENGTH__+0x7e0a26>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2214
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    1acc:  90 93 27 0a   sts  0x0A27, r25  ; 0x800a27 <__TEXT_REGION_LENGTH__+0x7e0a27>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2241
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) // use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA0) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA0 to different divider"
    #endif
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    1ad0:  8b e0         ldi  r24, 0x0B  ; 11
    1ad2:  80 93 00 0a   sts  0x0A00, r24  ; 0x800a00 <__TEXT_REGION_LENGTH__+0x7e0a00>
init_timers():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2189
  init_TCA0();
  #if (defined(TCA1))
    PORTMUX.TCAROUTEA = TCA0_PINS | TCA1_PINS;
    init_TCA1();
  #else
    PORTMUX.TCAROUTEA = TCA0_PINS;
    1ad6:  23 e0         ldi  r18, 0x03  ; 3
    1ad8:  20 93 e6 05   sts  0x05E6, r18  ; 0x8005e6 <__TEXT_REGION_LENGTH__+0x7e05e6>
init_TCBs():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2319
 * Set up routing (defined in pins_arduino.h)
 * Notice how there's no semicolon until after the preprocessor conditionals.
 * In other words, that's all one line.
 */

  PORTMUX.TCBROUTEA = 0
    1adc:  10 92 e7 05   sts  0x05E7, r1  ; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7e05e7>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2391
    #elif defined(MILLIS_USE_TIMERB7)
      if(timer_B != (TCB_t *)&TCB7)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    1ae0:  47 e0         ldi  r20, 0x07  ; 7
    1ae2:  40 93 01 0b   sts  0x0B01, r20  ; 0x800b01 <__TEXT_REGION_LENGTH__+0x7e0b01>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2394

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    1ae6:  90 93 0c 0b   sts  0x0B0C, r25  ; 0x800b0c <__TEXT_REGION_LENGTH__+0x7e0b0c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2397
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    1aea:  10 92 0d 0b   sts  0x0B0D, r1  ; 0x800b0d <__TEXT_REGION_LENGTH__+0x7e0b0d>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2400

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    1aee:  85 e0         ldi  r24, 0x05  ; 5
    1af0:  80 93 00 0b   sts  0x0B00, r24  ; 0x800b00 <__TEXT_REGION_LENGTH__+0x7e0b00>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2391
    #elif defined(MILLIS_USE_TIMERB7)
      if(timer_B != (TCB_t *)&TCB7)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    1af4:  40 93 11 0b   sts  0x0B11, r20  ; 0x800b11 <__TEXT_REGION_LENGTH__+0x7e0b11>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2394

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    1af8:  90 93 1c 0b   sts  0x0B1C, r25  ; 0x800b1c <__TEXT_REGION_LENGTH__+0x7e0b1c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2397
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    1afc:  10 92 1d 0b   sts  0x0B1D, r1  ; 0x800b1d <__TEXT_REGION_LENGTH__+0x7e0b1d>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2400

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    1b00:  80 93 10 0b   sts  0x0B10, r24  ; 0x800b10 <__TEXT_REGION_LENGTH__+0x7e0b10>
init_TCD0():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2444
 * be set in the status register. We skip checking this here because, as we do many places the  *
 * initiialization functions assume that the chip starts from a reset condition.                */

void __attribute__((weak)) init_TCD0() {
  #if defined(USE_TIMERD0_PWM) || defined (MILLIS_USE_TIMERD0)
    TCD0.CMPACLR  = 0x0FFF;
    1b04:  4f ef         ldi  r20, 0xFF  ; 255
    1b06:  5f e0         ldi  r21, 0x0F  ; 15
    1b08:  40 93 aa 0b   sts  0x0BAA, r20  ; 0x800baa <__TEXT_REGION_LENGTH__+0x7e0baa>
    1b0c:  50 93 ab 0b   sts  0x0BAB, r21  ; 0x800bab <__TEXT_REGION_LENGTH__+0x7e0bab>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2448
    // Match with CMPBCLR clears all outputs. For normal PWM this just needs to be higher than
    // it will count to - so set to maximum (other settings used for non-overlapping PWM and
    // other advanced functionality)
    TCD0.CTRLC    = 0x80;                   // WOD outputs PWM B, WOC outputs PWM A
    1b10:  90 e8         ldi  r25, 0x80  ; 128
    1b12:  90 93 82 0b   sts  0x0B82, r25  ; 0x800b82 <__TEXT_REGION_LENGTH__+0x7e0b82>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2450
    // That doesn't need to be that way, but I declare that that's all we support through analogWrite()
    TCD0.CTRLB    = TIMERD0_WGMODE_SETTING;
    1b16:  10 92 81 0b   sts  0x0B81, r1  ; 0x800b81 <__TEXT_REGION_LENGTH__+0x7e0b81>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2453
    // One ramp or dual slope are the only options that are viable to reproduce classic behavior without
    // considerable calculation overhead. We use one-ramp mode
    TCD0.CMPBCLR  = TIMERD0_TOP_SETTING;
    1b1a:  4b ef         ldi  r20, 0xFB  ; 251
    1b1c:  53 e0         ldi  r21, 0x03  ; 3
    1b1e:  40 93 ae 0b   sts  0x0BAE, r20  ; 0x800bae <__TEXT_REGION_LENGTH__+0x7e0bae>
    1b22:  50 93 af 0b   sts  0x0BAF, r21  ; 0x800baf <__TEXT_REGION_LENGTH__+0x7e0baf>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:2462
    #if defined(TIMERD0_SET_CLOCK)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (TIMERD0_SET_CLOCK));
    #endif


    TCD0.CTRLA    = TIMERD0_CLOCK_SETTING | TCD_ENABLE_bm;
    1b26:  91 e7         ldi  r25, 0x71  ; 113
    1b28:  90 93 80 0b   sts  0x0B80, r25  ; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
init_ADC0():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1703

/********************************* ADC ****************************************/
#if defined(ADC0)
  void __attribute__((weak)) init_ADC0() {
    ADC_t* pADC;
    _fastPtr_d(pADC, &ADC0);
    1b2c:  e0 e0         ldi  r30, 0x00  ; 0
    1b2e:  f6 e0         ldi  r31, 0x06  ; 6
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1714
      #elif F_CPU >= 36000000
        pADC->CTRLC = ADC_PRESC_DIV28_gc; // 1.286 @ 36 MHz
      #elif F_CPU >  28000000
        pADC->CTRLC = ADC_PRESC_DIV24_gc; // 1.33 @ 32 MHz, 1.
      #elif F_CPU >= 24000000
        pADC->CTRLC = ADC_PRESC_DIV20_gc; // 1.2 @ 24, 1.25 @ 25, 1.4 @ 28  MHz
    1b30:  82 83         std  Z+2, r24  ; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1726
      #elif F_CPU >= 4000000
        pADC->CTRLC = ADC_PRESC_DIV4_gc;  // 1 MHz
      #else  // 1 MHz / 2 = 500 kHz - the lowest setting
        pADC->CTRLC = ADC_PRESC_DIV2_gc;
      #endif
      pADC->SAMPCTRL = 14; // 16 ADC clock sampling time - should be about the same amount of *time* as originally?
    1b32:  9e e0         ldi  r25, 0x0E  ; 14
    1b34:  95 83         std  Z+5, r25  ; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1728
      // This is WAY conservative! We could drop it down...
      pADC->CTRLD = ADC_INITDLY_DLY64_gc; // VREF can take 50uS to become ready, and we're running the ADC clock
    1b36:  90 e6         ldi  r25, 0x60  ; 96
    1b38:  93 83         std  Z+3, r25  ; 0x03
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1731
      // at around 1 MHz, so we want 64 ADC clocks when we start up a new reference so we don't get bad readings at first
      /* Enable ADC */
      pADC->CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc;
    1b3a:  80 83         st  Z, r24
analogReference():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:590
  *****************************************************/

void analogReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.ADC0REF = (VREF.ADC0REF & ~(VREF_REFSEL_gm))|(mode);
    1b3c:  80 91 b0 00   lds  r24, 0x00B0  ; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
    1b40:  88 7f         andi  r24, 0xF8  ; 248
    1b42:  85 60         ori  r24, 0x05  ; 5
    1b44:  80 93 b0 00   sts  0x00B0, r24  ; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
DACReference():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:133
#endif

#ifdef DAC0
  void DACReference(uint8_t mode) {
    check_valid_analog_ref(mode);
    VREF.DAC0REF = mode | (VREF.DAC0REF & (~VREF_REFSEL_gm));
    1b48:  80 91 b2 00   lds  r24, 0x00B2  ; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
    1b4c:  88 7f         andi  r24, 0xF8  ; 248
    1b4e:  85 60         ori  r24, 0x05  ; 5
    1b50:  80 93 b2 00   sts  0x00B2, r24  ; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
init_millis():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1623
        #endif
        RTC.INTCTRL         = 0x01; // enable overflow interrupt
        RTC.CTRLA           = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
      */
    #else // It's a type b timer - we have already errored out if that wasn't defined
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
    1b54:  8f ed         ldi  r24, 0xDF  ; 223
    1b56:  9e e2         ldi  r25, 0x2E  ; 46
    1b58:  80 93 2c 0b   sts  0x0B2C, r24  ; 0x800b2c <__TEXT_REGION_LENGTH__+0x7e0b2c>
    1b5c:  90 93 2d 0b   sts  0x0B2D, r25  ; 0x800b2d <__TEXT_REGION_LENGTH__+0x7e0b2d>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1625
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
    1b60:  30 93 25 0b   sts  0x0B25, r19  ; 0x800b25 <__TEXT_REGION_LENGTH__+0x7e0b25>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1627
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
    1b64:  10 92 21 0b   sts  0x0B21, r1  ; 0x800b21 <__TEXT_REGION_LENGTH__+0x7e0b21>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1629
      // CLK_PER/1 is 0b00, . CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
    1b68:  20 93 20 0b   sts  0x0B20, r18  ; 0x800b20 <__TEXT_REGION_LENGTH__+0x7e0b20>
main():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:95
 * just waiting for the DU-series now                                                           */
int main() {
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
    1b6c:  78 94         sei
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:96
  setup();
    1b6e:  0e 94 2e 02   call  0x45c  ; 0x45c <setup>
    1b72:  ff cf         rjmp  .-2        ; 0x1b72 <main+0xc2>

00001b74 <_GLOBAL__sub_I___vector_23>:
_ZN5PrintC2Ev():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:42
  protected:
    void setWriteError(int err = 1) {
      write_error = err;
    }
  public:
    Print() : write_error(0) {}
    1b74:  e8 ec         ldi  r30, 0xC8  ; 200
    1b76:  f2 e4         ldi  r31, 0x42  ; 66
    1b78:  12 82         std  Z+2, r1  ; 0x02
    1b7a:  13 82         std  Z+3, r1  ; 0x03
_ZN6StreamC2Ev():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Stream.h:63
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {
      _timeout = 1000;
    1b7c:  88 ee         ldi  r24, 0xE8  ; 232
    1b7e:  93 e0         ldi  r25, 0x03  ; 3
    1b80:  a0 e0         ldi  r26, 0x00  ; 0
    1b82:  b0 e0         ldi  r27, 0x00  ; 0
    1b84:  84 83         std  Z+4, r24  ; 0x04
    1b86:  95 83         std  Z+5, r25  ; 0x05
    1b88:  a6 83         std  Z+6, r26  ; 0x06
    1b8a:  b7 83         std  Z+7, r27  ; 0x07
_ZN14HardwareSerialC2EPV12USART_structPhhh():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART_private.h:20
#if defined(USART0) || defined(USART1) || defined(USART2) || defined(USART3) || defined(USART4) || defined(USART5)

// Constructor
// no need to set the other variables to zero, init script already does that. Saves some flash
HardwareSerial::HardwareSerial(volatile USART_t *hwserial_module, uint8_t *usart_pins, uint8_t mux_count, uint8_t mux_default) :
    _hwserial_module(hwserial_module), _usart_pins(usart_pins), _mux_count(mux_count), _pin_set(mux_default) {
    1b8c:  89 e4         ldi  r24, 0x49  ; 73
    1b8e:  90 e4         ldi  r25, 0x40  ; 64
    1b90:  80 83         st  Z, r24
    1b92:  91 83         std  Z+1, r25  ; 0x01
    1b94:  80 e0         ldi  r24, 0x00  ; 0
    1b96:  98 e0         ldi  r25, 0x08  ; 8
    1b98:  80 87         std  Z+8, r24  ; 0x08
    1b9a:  91 87         std  Z+9, r25  ; 0x09
    1b9c:  88 ea         ldi  r24, 0xA8  ; 168
    1b9e:  90 e0         ldi  r25, 0x00  ; 0
    1ba0:  82 87         std  Z+10, r24  ; 0x0a
    1ba2:  93 87         std  Z+11, r25  ; 0x0b
    1ba4:  82 e0         ldi  r24, 0x02  ; 2
    1ba6:  84 87         std  Z+12, r24  ; 0x0c
    1ba8:  15 86         std  Z+13, r1  ; 0x0d
    1baa:  16 86         std  Z+14, r1  ; 0x0e
_GLOBAL__sub_I___vector_23():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:130
#endif
                ::"z"(&Serial0));
      __builtin_unreachable();
    }
  #endif
  HardwareSerial Serial0(&USART0, (uint8_t*)_usart0_pins, MUXCOUNT_USART0, HWSERIAL0_MUX_DEFAULT);
    1bac:  08 95         ret

00001bae <__udivmodsi4>:
__udivmodsi4():
    1bae:  a1 e2         ldi  r26, 0x21  ; 33
    1bb0:  1a 2e         mov  r1, r26
    1bb2:  aa 1b         sub  r26, r26
    1bb4:  bb 1b         sub  r27, r27
    1bb6:  fd 01         movw  r30, r26
    1bb8:  0d c0         rjmp  .+26       ; 0x1bd4 <__udivmodsi4_ep>

00001bba <__udivmodsi4_loop>:
    1bba:  aa 1f         adc  r26, r26
    1bbc:  bb 1f         adc  r27, r27
    1bbe:  ee 1f         adc  r30, r30
    1bc0:  ff 1f         adc  r31, r31
    1bc2:  a2 17         cp  r26, r18
    1bc4:  b3 07         cpc  r27, r19
    1bc6:  e4 07         cpc  r30, r20
    1bc8:  f5 07         cpc  r31, r21
    1bca:  20 f0         brcs  .+8        ; 0x1bd4 <__udivmodsi4_ep>
    1bcc:  a2 1b         sub  r26, r18
    1bce:  b3 0b         sbc  r27, r19
    1bd0:  e4 0b         sbc  r30, r20
    1bd2:  f5 0b         sbc  r31, r21

00001bd4 <__udivmodsi4_ep>:
    1bd4:  66 1f         adc  r22, r22
    1bd6:  77 1f         adc  r23, r23
    1bd8:  88 1f         adc  r24, r24
    1bda:  99 1f         adc  r25, r25
    1bdc:  1a 94         dec  r1
    1bde:  69 f7         brne  .-38       ; 0x1bba <__udivmodsi4_loop>
    1be0:  60 95         com  r22
    1be2:  70 95         com  r23
    1be4:  80 95         com  r24
    1be6:  90 95         com  r25
    1be8:  9b 01         movw  r18, r22
    1bea:  ac 01         movw  r20, r24
    1bec:  bd 01         movw  r22, r26
    1bee:  cf 01         movw  r24, r30
    1bf0:  08 95         ret

00001bf2 <__muluhisi3>:
__muluhisi3():
    1bf2:  12 d0         rcall  .+36       ; 0x1c18 <__umulhisi3>
    1bf4:  a5 9f         mul  r26, r21
    1bf6:  90 0d         add  r25, r0
    1bf8:  b4 9f         mul  r27, r20
    1bfa:  90 0d         add  r25, r0
    1bfc:  a4 9f         mul  r26, r20
    1bfe:  80 0d         add  r24, r0
    1c00:  91 1d         adc  r25, r1
    1c02:  11 24         eor  r1, r1
    1c04:  08 95         ret

00001c06 <__tablejump2__>:
__tablejump2__():
    1c06:  ee 0f         add  r30, r30
    1c08:  ff 1f         adc  r31, r31
    1c0a:  00 24         eor  r0, r0
    1c0c:  00 1c         adc  r0, r0
    1c0e:  0b be         out  0x3b, r0  ; 59
    1c10:  07 90         elpm  r0, Z+
    1c12:  f6 91         elpm  r31, Z
    1c14:  e0 2d         mov  r30, r0
    1c16:  09 94         ijmp

00001c18 <__umulhisi3>:
__umulhisi3():
    1c18:  a2 9f         mul  r26, r18
    1c1a:  b0 01         movw  r22, r0
    1c1c:  b3 9f         mul  r27, r19
    1c1e:  c0 01         movw  r24, r0
    1c20:  a3 9f         mul  r26, r19
    1c22:  70 0d         add  r23, r0
    1c24:  81 1d         adc  r24, r1
    1c26:  11 24         eor  r1, r1
    1c28:  91 1d         adc  r25, r1
    1c2a:  b2 9f         mul  r27, r18
    1c2c:  70 0d         add  r23, r0
    1c2e:  81 1d         adc  r24, r1
    1c30:  11 24         eor  r1, r1
    1c32:  91 1d         adc  r25, r1
    1c34:  08 95         ret

00001c36 <_exit>:
exit():
    1c36:  f8 94         cli

00001c38 <__stop_program>:
__stop_program():
    1c38:  ff cf         rjmp  .-2        ; 0x1c38 <__stop_program>
